let INITIAL_SIZE = 8

type Vector = struct {
    length: size_t
    data: [&]
}

type S = struct { a: int }
def destruct(s: *S) {
    print("Destructing S: ", s.a, "\n")
}

def delete(v: type [T]) {
    if defined __destruct__::(*T) {
        for var i in 0..v.size {
            __destruct__(*v[i])
        }
    }
    free(v.value)
}

def destruct(t: *Vector) {
    print("Destructing Vector\n")
    delete(t.data)
}

def length(vec: &Vector) -> size_t {
    return vec.length
}

def resize(data: type [T], size: size_t) {
    data.value = reallocate(data.value, (size_of T) * size)
    data.size = size
}

def roundup(n: size_t) -> size_t {
    if n == 0 {
        return 0
    }
    var r: size_t = 1
    while n > r {
        r *= 2
    }
    return r
}

def make -> &Vector {
    return {
        length = 0,
        data = zero_allocate(type &, INITIAL_SIZE)
    } !Vector
}

def copy(vec: &Vector) -> &Vector {
    let data = zero_allocate(type &, vec.data.size)
    for var i in 0..vec.data.size {
        data[i] = vec.data[i]
    }
    return {
        length = vec.length,
        data = data
    } !Vector
}

def extend(vec: &Vector, delta: size_t) {
    if vec.length + delta < vec.data.size {
        return
    }
    let nelem = max(roundup(vec.length + delta), INITIAL_SIZE) !size_t
    resize(vec.data, nelem)
}

def get(vec: &Vector, index: size_t) -> & {
    assert(index >= 0 and index < vec.length)
    return vec.data[index]
}

def set(vec: &Vector, index: size_t, val: &) {
    assert(index >= 0 and index < vec.length)
    vec.data[index] = val
}

def push(vec: &Vector, elem: &) {
    extend(vec, 1)
    vec.data[vec.length] = elem
    vec.length += 1
}

let s: &S = {0} !S
let vec = make()
vec.push(s)
vec.push({20} !S)
vec.push({30} !S)
vec.push({40} !S)

let vec2 = copy(vec)

for var i in 0..length(vec) {
    let e = vec.get(i) !&S
    print(e.a, " ")
}
print("\n")