@@grammar :: Princess
@@whitespace :: /(?!)/ # TODO https://github.com/neogeny/TatSu/issues/73
@@parseinfo :: False

program::Program = LIST:{statement};

# Whitespace
t_newline = /[\n]+/ | t_eol_comment;
t_ws = /[\t ]+/;

_ = {t_ws | t_comment}; # Whitespace
n_ = {t_newline | _}; # "Continue statement", this wraps around lines
s_ = _; # Expands into _ or n_ depending on context, handled in WrappedParser to simplify the grammar

k_if = "if";
k_else = "else";
k_not = "not";
k_and = "and";
k_or = "or";

t_keyword = k_if | k_else | k_not | k_and | k_or; 

t_term = ';' | $ | t_newline;

digit  = /[0-9]/;
hex_digit = /[a-fA-F0-9]/;
oct_digit = /[0-8]/;
bin_digit = /[01]/;
sign = /[+-]/ | `"+"`;

# Exponent
exp = /[Ee]/ sign:sign ~ num: {digit}+;

t_float_literal::Float =
    | (num: {digit}+ (("." ~ frac: ({digit}+ | `"0"`) exp:[exp]) | frac:`"0"` exp:exp))
    | (num: `"0"` "." ~ frac: {digit}+ exp:[exp]);

t_dec_literal::Integer =
    base: `10`
    num:{digit}+;

t_hex_literal::Integer = "0x" ~
    base: `16`
    num: {hex_digit}+;

t_oct_literal::Integer = "0o" ~
    base: `8`
    num: {oct_digit}+;

t_bin_literal::Integer = "0b" ~
    base: `2`
    num: {bin_digit}+;

t_num_lit = (t_hex_literal | t_bin_literal | t_oct_literal |  t_float_literal | t_dec_literal);

# String literal
esc_char = @+:/[abfnrtv\\'"0]/;
esc_seq =
    | (/x/ ~ hex_digit hex_digit) # Hex digit
    | (/u/ ~ hex_digit hex_digit hex_digit hex_digit) # Unicode
    | (/U/ ~ hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit) # Extended Unicode
    | ~ esc_char; # Normal escape

t_char = (('\\' ~ @:esc_seq) | /[^\0\x7f\x80"\\]+/);
t_char_lit::Char = "'" VALUE:t_char ~ "'";
t_string_lit::String = '"' VALUE:{t_char} ~ '"';

t_ident::Identifier = !t_keyword VALUE:/(?!\d)\w+/;

literal = (t_num_lit | t_char_lit | t_string_lit);
value = t_ident | literal;

t_comment_start = "/*";
t_comment_end = "*/";
t_comment = t_comment_start {(!t_comment_end !t_comment_start /.|\n/) | t_comment} ~ t_comment_end;

t_eol_comment = "//" /[^\n]+/ ('\n' | $);

# FIXME Bug: https://github.com/neogeny/TatSu/issues/69

expr_pre::UnaryPreOp = op:('++' | '+'| '--' | '-' | '@' | '*' | '~' | k_not) n_ ~ right:expr_7;
expr_shift::BinaryOp = left:expr_6 s_ op:('>>' | '<<' | '&' | '|' | '^') n_ ~ right:expr_7;
expr_mul::BinaryOp = left:expr_5 s_ op:('*' | '/' | '%') n_ ~ right:expr_6;
expr_add::BinaryOp = left:expr_4 s_ op:('+' | '-') n_ ~ right:expr_5;

cmp_char = ('<=' | '>=' | '<' | '>' | '==' | '!=');
expr_cmp = s_ op: cmp_char n_ ~ right: expr_4;
expr_cmp_start::Compare = left:expr_4 right:{expr_cmp}+;

expr_and::BinaryOp = left:expr_2 s_ op: k_and n_ ~ right: expr_3;
expr_or::BinaryOp = left:expr_1 s_ op: k_or n_ ~ right: expr_2;

expr_8 =
    | '(' ~ n_ @:n_expression n_ ')'
    | value;

expr_7 = expr_pre | expr_8;
expr_6 = expr_shift | expr_7;
expr_5 = expr_mul | expr_6;
expr_4 = expr_add | expr_5;
expr_3 = expr_cmp_start | expr_4;
expr_2 = expr_and | expr_3;
expr_1 = expr_or | expr_2;

expression::Expression = VALUE:expr_1;
n_expression = expr_1;

statement =
    | _ @:() t_term
    | ~ _ @:expression _ t_term;