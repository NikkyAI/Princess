@@grammar :: Princess
@@whitespace :: /(?!)/ # TODO https://github.com/neogeny/TatSu/issues/73
@@parseinfo :: False
@@namechars :: '_'
@@keyword :: if else not and or false true var let const type
@@keyword :: while for loop continue break in

code_body::Body = '{' LIST:{statement} ~ '}';
program::Program = LIST:{statement} $;

# Whitespace
t_newline = /[\n]+/;
t_term = ';' | t_newline | &$ | &'}';

# Numeric literal

digit  = /[0-9]/;
hex_digit = /[a-fA-F0-9]/;
oct_digit = /[0-8]/;
bin_digit = /[01]/;
sign = /[+-]/ | `"+"`;

# Exponent
exp = /[Ee]/ sign:sign ~ num: {digit}+;

t_float_literal::Float =
    | (num: {digit}+ (("." ~ frac: ({digit}+ | `"0"`) exp:[exp]) | frac:`"0"` exp:exp))
    | (num: `"0"` "." ~ frac: {digit}+ exp:[exp]);

t_dec_literal::Integer =
    base: `10`
    num:{digit}+;

t_hex_literal::Integer = "0x" ~
    base: `16`
    num: {hex_digit}+;

t_oct_literal::Integer = "0o" ~
    base: `8`
    num: {oct_digit}+;

t_bin_literal::Integer = "0b" ~
    base: `2`
    num: {bin_digit}+;

t_num_lit = (t_hex_literal | t_bin_literal | t_oct_literal |  t_float_literal | t_dec_literal);

# String literal
esc_char = @+:/[abfnrtv\\'"0]/;
esc_seq =
    | (/x/ ~ hex_digit hex_digit) # Hex digit
    | (/u/ ~ hex_digit hex_digit hex_digit hex_digit) # Unicode
    | (/U/ ~ hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit) # Extended Unicode
    | ~ esc_char; # Normal escape

t_char = (('\\' ~ @:esc_seq) | /[^\0\x7f\x80"\\]+/);
t_char_lit::Char = "'" VALUE:t_char ~ "'";
t_string_lit::String = '"' VALUE:{t_char} ~ '"';

@name
t_ident = /(?!\d)\w+/;

identifier::Identifier = [root: '::'] ident:'::'.{t_ident}+; # TODO Allow spaces around ::?

# Boolean literal
t_bool::bool = "true" @:`1` | "false" @:`0`; # FIXME Bug: https://github.com/neogeny/TatSu/issues/76
t_bool_lit::Boolean = VALUE:t_bool;

# Array literal
array_element = @:expression;
array_lit::Array::Literal = '[' ~ LIST:','.{array_element} ']';

literal = (array_lit | t_num_lit | t_bool_lit | t_char_lit | t_string_lit);
value = literal | identifier;

# Struct literal
struct_lit::StructInit = '{' ~ '}'; # TODO

# type { ... }
type_structural::StructuralT = '{' ~ '}'; # TODO
type_ptr::PtrT = '*' keyword: ("var" | "let" | `"var"`) [type: type_1];
type_ref::PtrT = '&' keyword: `"let"` [type: type_1];

# Array type
type_array_dyn::ArrayT = '[' keyword: ("var" | "let" | `"var"`) [type: type] ']';
type_array_static::ArrayT = '[' ~ n:('?' | expression) 
    keyword: ("var" | "let" | `"var"`) [type: type] ']';
type_array = type_array_dyn | type_array_static;

# Function type
type_list_elem = @:type;
type_list = ( '(' ~ @:','.{type_list_elem} ')' ) | @+:type;
type_function::FunctionT = 
    | '->' [right: type_list]
    | left: type_list '->' [right: type_list];

# Type expression
type_2 = '(' @:type ')' | expr_10;
type_1 = type_structural | type_ptr | type_ref | type_array | type_2;
type = type_function | type_1;

call_arg_named::CallArg = 
    name: identifier '=' value: (struct_lit | expression);     # Named argument
call_arg::CallArg = value: (struct_lit | expression);                # Positional argument
expr_call::Call::Expression = left: expr_10 '(' args:','.{call_arg_named | call_arg} ~ ')';

expr_array_index::ArrayIndex::Expression = left: expr_10 '[' right: expression ']';
expr_member_access::MemberAccess::Expression = left: expr_10 '.' right: value;
expr_type::Type::Expression = "type" VALUE:type;

expr_postinc::PostInc::UnaryPostOp = left: expr_10 '--';
expr_postdec::PostDec::UnaryPostOp = left: expr_10 '++';

expr_cast::Cast::Expression = left: (struct_lit | expr_9) '!' ~ right: type;

expr_preinc::PreInc::UnaryPreOp = '++'  ~ right:expr_9;
expr_predec::PreDec::UnaryPreOp = '--'  ~ right:expr_9;
expr_uminus::UMinus::UnaryPreOp = '-'   ~ right:expr_9;
expr_deref::Deref::UnaryPreOp   = '@'   ~ right:expr_9;
expr_ptr::Ptr::UnaryPreOp       = '*'   ~ right:expr_9;
expr_invert::Invert::UnaryPreOp = '~'   ~ right:expr_9;
expr_not::Not::UnaryPreOp       = "not" ~ right:expr_9;

expr_shr::Shr::BinaryOp   = left:expr_7 '>>' ~ right:expr_8;
expr_shl::Shl::BinaryOp   = left:expr_7 '<<' ~ right:expr_8;
expr_band::BAnd::BinaryOp = left:expr_7 '&'  ~ right:expr_8;
expr_bor::BOr::BinaryOp   = left:expr_7 '|'  ~ right:expr_8;
expr_xor::Xor::BinaryOp   = left:expr_7 '^'  ~ right:expr_8;

expr_mul::Mul::BinaryOp = left:expr_6 '*' ~ right:expr_7;
expr_div::Div::BinaryOp = left:expr_6 '/' ~ right:expr_7;
expr_mod::Mod::BinaryOp = left:expr_6 '%' ~ right:expr_7;

expr_add::Add::BinaryOp = left:expr_5 '+' ~ right:expr_6;
expr_sub::Sub::BinaryOp = left:expr_5 '-' ~ right:expr_6;

cmp_op = ('<=' | '>=' | '<' | '>' | '==' | '!=');
expr_cmp = op: cmp_op ~ right: expr_5;
expr_cmp_start::Compare = left:expr_5 right:{expr_cmp}+;

expr_and::And::BinaryOp = left:expr_3 "and" ~ right: expr_4;
expr_or::Or::BinaryOp   = left:expr_2 "or"  ~ right: expr_3;

assign_op = ('+=' | '-=' | '*=' | '/=' | '%=' | '|=' | '&=' | '^=' | '>>=' | '<<=');
expr_assign_op::AssignAndOp = left: expr_2 op:assign_op ~ right: expr_1;

expr_assign_lhs = @:expr_2;
expr_assign_rhs = @:(struct_lit | expr_1);
expr_assign::Assign = left: ','.{expr_assign_lhs}+ '=' ~ right: ','.{expr_assign_rhs}+; 

# Chaining on the condition might be confusing
expr_if::IfExpr::Expression = if_true: expr_2 ("if") ~ cond: expr_1 ("else") if_false: expr_1;

expr_range::Range::Expression =
    from: expr_1 ':' to: expr_1 [':' step: expr_1];

# Precedence ladder
expr_11 =
    | '(' ~ @:expression ')'
    | value;

expr_10 = expr_type | expr_call | expr_array_index | expr_member_access | expr_postinc | expr_postdec | expr_11;
expr_9 = expr_preinc | expr_predec | expr_uminus | expr_deref | expr_ptr | expr_invert | expr_not | expr_10;
expr_8 = expr_cast | expr_9;
expr_7 = expr_shr | expr_shl | expr_band | expr_bor | expr_xor | expr_8;
expr_6 = expr_mul | expr_div | expr_mod | expr_7;
expr_5 = expr_add | expr_sub | expr_6;
expr_4 = expr_cmp_start | expr_5;
expr_3 = expr_and | expr_4;
expr_2 = expr_or | expr_3;
expr_1 = expr_assign_op | expr_assign | expr_if | expr_2;
expr_0 = expr_range | expr_1;

expression = expr_0;   # Expression outside brackets

stmt_iddecl::IdDecl = name: identifier [':' type: type];
stmt_vardecl_rhs = @:(struct_lit | expression);
stmt_vardecl::VarDecl::Statement = 
    keyword: ("var" | "let" | "const") left:','.{stmt_iddecl}+ [ '=' right: ','.{stmt_vardecl_rhs}+];

stmt_typedecl_lhs = @:identifier;
stmt_typedecl_rhs = @:type;
stmt_typedecl::TypeDecl::Statement = 
    "type" name: ','.{stmt_typedecl_lhs}+ '=' value: ','.{stmt_typedecl_rhs}+;

# if statement
stmt_else::Else::Statement = "else" ~ body: code_body;
stmt_else_if::If::Statement = "else" "if" ~ cond:expression body:code_body;
stmt_if::If::Statement = 
    "if" ~ cond:expression body:code_body
    else_if:{stmt_else_if}
    [else: stmt_else];

stmt_static_if::StaticIf::Statement = '#' >stmt_if;

# while loop
stmt_while_loop::While::Statement = 'while' cond: expression body: code_body;
stmt_loop::While::Statement = 'loop' body: code_body;

stmt_continue::Continue::Statement = 'continue';
stmt_break::Break::Statement = 'break';

# for loop
expr_in::In::Expression = [keyword: "var"] left:','.{stmt_iddecl}+ 'in' right: ','.{stmt_vardecl_rhs}+;
stmt_for_loop::For::Statement = 'for' iterator: expr_in body: code_body;

statement =
    | @:() t_term
    | @:(stmt_vardecl | stmt_typedecl | stmt_if | stmt_static_if | stmt_for_loop |
        stmt_while_loop | stmt_loop | stmt_continue | stmt_break | expression) t_term;