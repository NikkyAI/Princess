@@grammar :: Princess
@@whitespace :: /(?!)/ # TODO https://github.com/neogeny/TatSu/issues/73
@@parseinfo :: False
@@namechars :: '_'
@@keyword :: if else not and or false true var let type

code_body::Body = '{' n_ LIST:{statement} n_ ~ '}';
program::Program = LIST:{statement} $;

# Whitespace
t_newline = /[\n]+/ | t_eol_comment;
t_ws = /[\t ]+/;

_ = {t_ws | t_comment}; # Whitespace
n_ = {t_newline | _}; # "Continue statement", this wraps around lines
s_ = _; # Expands into _ or n_ depending on context, handled in WrappedParser to simplify the grammar

t_term = ';' | t_newline | &$ | &'}';

# Numeric literal

digit  = /[0-9]/;
hex_digit = /[a-fA-F0-9]/;
oct_digit = /[0-8]/;
bin_digit = /[01]/;
sign = /[+-]/ | `"+"`;

# Exponent
exp = /[Ee]/ sign:sign ~ num: {digit}+;

t_float_literal::Float =
    | (num: {digit}+ (("." ~ frac: ({digit}+ | `"0"`) exp:[exp]) | frac:`"0"` exp:exp))
    | (num: `"0"` "." ~ frac: {digit}+ exp:[exp]);

t_dec_literal::Integer =
    base: `10`
    num:{digit}+;

t_hex_literal::Integer = "0x" ~
    base: `16`
    num: {hex_digit}+;

t_oct_literal::Integer = "0o" ~
    base: `8`
    num: {oct_digit}+;

t_bin_literal::Integer = "0b" ~
    base: `2`
    num: {bin_digit}+;

t_num_lit = (t_hex_literal | t_bin_literal | t_oct_literal |  t_float_literal | t_dec_literal);

# String literal
esc_char = @+:/[abfnrtv\\'"0]/;
esc_seq =
    | (/x/ ~ hex_digit hex_digit) # Hex digit
    | (/u/ ~ hex_digit hex_digit hex_digit hex_digit) # Unicode
    | (/U/ ~ hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit) # Extended Unicode
    | ~ esc_char; # Normal escape

t_char = (('\\' ~ @:esc_seq) | /[^\0\x7f\x80"\\]+/);
t_char_lit::Char = "'" VALUE:t_char ~ "'";
t_string_lit::String = '"' VALUE:{t_char} ~ '"';

@name
t_ident = /(?!\d)\w+/;

identifier::Identifier = [root: '::'] ident:'::'.{t_ident}+; # TODO Allow spaces around ::?

# Boolean literal
t_bool::bool = "true" @:`1` | "false" @:`0`; # FIXME Bug: https://github.com/neogeny/TatSu/issues/76
t_bool_lit::Boolean = VALUE:t_bool;

literal = (t_num_lit | t_bool_lit | t_char_lit | t_string_lit);
value = literal | identifier;

t_comment_start = "/*";
t_comment_end = "*/";
t_comment = t_comment_start {(!t_comment_end !t_comment_start /.|\n/) | t_comment} ~ t_comment_end;

t_eol_comment = "//" /[^\n]+/ ('\n' | $);

# Struct literal
struct_lit::StructInit = '{' n_ ~ '}'; # TODO

# type { ... }
type_structural::TypeStructural = '{' n_ ~ '}'; # TODO

# Type expression
type::Type::Expression = VALUE:(type_structural | expression);

# TODO disallow positional parameter after named parameter
call_arg_named::CallArg = n_ name: identifier n_ '=' n_ value: n_expression n_;     # Named argument
call_arg::CallArg = n_ value: n_expression n_;                                      # Positional argument
expr_call::Call::Expression = left: expr_10 s_ '(' n_ args:','.{call_arg_named | call_arg} ~ ')';

expr_array_index::ArrayIndex::Expression = left: expr_10 s_ '[' n_ right: n_expression n_ ']';
expr_member_access::MemberAccess::Expression = left: expr_10 s_ '.' n_ right: expr_11;
expr_type = "type" n_ @:type;

expr_postinc::PostInc::UnaryPostOp = left: expr_10 '--';
expr_postdec::PostDec::UnaryPostOp = left: expr_10 '++';

expr_cast::Cast::Expression = left: (struct_lit | expr_9) s_ '!' n_ ~ right: type;

expr_preinc::PreInc::UnaryPreOp = '++'  n_ ~ right:expr_9;
expr_predec::PreDec::UnaryPreOp = '--'  n_ ~ right:expr_9;
expr_uminus::UMinus::UnaryPreOp = '-'   n_ ~ right:expr_9;
expr_deref::Deref::UnaryPreOp   = '@'   n_ ~ right:expr_9;
expr_ptr::Ptr::UnaryPreOp       = '*'   n_ ~ right:expr_9;
expr_invert::Invert::UnaryPreOp = '~'   n_ ~ right:expr_9;
expr_not::Not::UnaryPreOp       = "not" n_ ~ right:expr_9;

expr_shr::Shr::BinaryOp   = left:expr_7 s_ '>>' n_ ~ right:expr_8;
expr_shl::Shl::BinaryOp   = left:expr_7 s_ '<<' n_ ~ right:expr_8;
expr_band::BAnd::BinaryOp = left:expr_7 s_ '&'  n_ ~ right:expr_8;
expr_bor::BOr::BinaryOp   = left:expr_7 s_ '|'  n_ ~ right:expr_8;
expr_xor::Xor::BinaryOp   = left:expr_7 s_ '^'  n_ ~ right:expr_8;

expr_mul::Mul::BinaryOp = left:expr_6 s_ '*' n_ ~ right:expr_7;
expr_div::Div::BinaryOp = left:expr_6 s_ '/' n_ ~ right:expr_7;
expr_mod::Mod::BinaryOp = left:expr_6 s_ '%' n_ ~ right:expr_7;

expr_add::Add::BinaryOp = left:expr_5 s_ '+' n_ ~ right:expr_6;
expr_sub::Sub::BinaryOp = left:expr_5 s_ '-' n_ ~ right:expr_6;

cmp_op = ('<=' | '>=' | '<' | '>' | '==' | '!=');
expr_cmp = s_ op: cmp_op n_ ~ right: expr_5;
expr_cmp_start::Compare = left:expr_5 right:{expr_cmp}+;

expr_and::And::BinaryOp = left:expr_3 s_ "and" n_ ~ right: expr_4;
expr_or::Or::BinaryOp   = left:expr_2 s_ "or"  n_ ~ right: expr_3;

assign_op = ('+=' | '-=' | '*=' | '/=' | '%=' | '|=' | '&=' | '^=' | '>>=' | '<<=' | '=');
expr_assign::Assign = left: expr_2 s_ op:assign_op n_ ~ right: expr_1;

# Chaining on the condition might be confusing
expr_if::IfExpr::Expression = if_true: expr_2 (s_ "if" n_) ~ cond: expr_1 (n_ "else" n_) if_false: expr_1;

# Precedence ladder
expr_11 =
    | '(' ~ n_ @:n_expression n_ ')'
    | value;

expr_10 = expr_type | expr_call | expr_array_index | expr_member_access | expr_postinc | expr_postdec | expr_11;
expr_9 = expr_preinc | expr_predec | expr_uminus | expr_deref | expr_ptr | expr_invert | expr_not | expr_10;
expr_8 = expr_cast | expr_9;
expr_7 = expr_shr | expr_shl | expr_band | expr_bor | expr_xor | expr_8;
expr_6 = expr_mul | expr_div | expr_mod | expr_7;
expr_5 = expr_add | expr_sub | expr_6;
expr_4 = expr_cmp_start | expr_5;
expr_3 = expr_and | expr_4;
expr_2 = expr_or | expr_3;
expr_1 = expr_assign | expr_if | expr_2;

n_expression = expr_1; # Expression inside brackets
expression = expr_1; # Expression outside brackets

stmt_vardecl::VarDecl::Statement = keyword: ("var" | "let") n_ name: identifier [n_ ':' n_ type:type] [ n_ '=' n_ value: expression];
stmt_typedecl::TypeDecl::Statement = "type" n_ name: identifier n_ '=' n_ value: type;

# if statement
stmt_else::Else::Statement = n_ "else" ~ n_ body: code_body;
stmt_else_if::If::Statement = n_ "else" n_ "if" ~ n_ cond:expression n_ body:code_body;
stmt_if::If::Statement = 
    "if" ~ n_ cond:expression n_ body:code_body
    else_if:{stmt_else_if}
    [else: stmt_else];

stmt_static_if::StaticIf::Statement = '#' >stmt_if;

statement =
    | _ @:() t_term
    | _ @:(stmt_vardecl | stmt_typedecl | stmt_if | stmt_static_if | expression) _ t_term;