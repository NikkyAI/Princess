import map
import vector
import parser
import buffer
import util

export type TypeKind = enum {
    TYPE
    WORD
    FLOAT
    BOOL
    STRUCT
    UNION
    ENUM
    FUNCTION
    POINTER
    REFERENCE
    STATIC_ARRAY
    ARRAY
    // Type for integer literal, this converts to all sorts of types
    INT_LITERAL
    // This is used for functions that return multiple values
    TUPLE
    // Used for enums
    NAMESPACE
    // Forward declaration
    STUB
    // Auto cast, this type will convert to anything
    // AUTO_CAST // TODO Actually implement this
}

export type Type = struct {
    kind: TypeKind
    // Name of the type as used by the source code
    // Might be the name of a typedef
    name: string
    // Unique name of the type
    type_name: string
    // Size in bytes
    size: size_t
    align: size_t
    unsig: bool
    // Static array
    length: size_t
    // Type both used for array/pointer and enum
    tpe: *Type
    // Fields for both struct and enum
    fields: *map::Map
    // Function
    return_t: *vector::Vector
    parameter_t: *vector::Vector
    // Tuple
    elements: *vector::Vector
    // int literal
    i: uint64
    // -1 for negative numbers, 1 for postive
    // This is so that we can represent all possible numbers
    sign: int
}

type scope::Scope

type State = struct {
    filename: string
    scope: *scope::Scope
}

export def is_function(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::FUNCTION
}

export def is_arithmetic(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::WORD or 
        (@tpe).kind == TypeKind::FLOAT or 
        (@tpe).kind == TypeKind::INT_LITERAL
}

export def is_integer(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::WORD or 
        (@tpe).kind == TypeKind::INT_LITERAL
}

export def is_boolean(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::BOOL or
        (@tpe).kind == TypeKind::WORD or
        (@tpe).kind == TypeKind::FLOAT or
        (@tpe).kind == TypeKind::POINTER or
        (@tpe).kind == TypeKind::REFERENCE
}

def append_module(name: string, node: *parser::Node) -> string {
    var buf = buffer::make_buffer()
    buffer::append_str(*buf, (@node).loc.filename)
    buffer::append_str(*buf, "::")
    buffer::append_str(*buf, name)
    return buffer::to_string(*buf)
}

export def make_type(kind: TypeKind, node: *parser::Node) -> *Type {
    let name = parser::identifier_to_str(node)
    var t = allocate(Type)
    (@t).kind = kind
    (@t).type_name = append_module(name, node)
    (@t).name = name

    return t
}

export def copy(a: *Type) -> *Type {
    var t = allocate(Type)
    (@t).kind = (@a).kind
    (@t).name = (@a).name
    (@t).type_name = (@a).type_name
    (@t).size = (@a).size
    (@t).align = (@a).align
    (@t).unsig = (@a).unsig
    (@t).length = (@a).length
    (@t).tpe = (@a).tpe
    (@t).fields = (@a).fields
    (@t).return_t = (@a).return_t
    (@t).parameter_t = (@a).parameter_t
    (@t).i = (@a).i
    (@t).sign = (@a).sign
    return t
}

export def equals(a: *Type, b: *Type) -> bool {
    if a == b {
        return true
    }
    if (@a).kind != (@b).kind { return false }

    let kind = (@a).kind
    if kind == TypeKind::BOOL { return true }
    if kind == TypeKind::WORD or kind == TypeKind::FLOAT {
        return (@a).size == (@b).size
    }
    if kind == TypeKind::INT_LITERAL {
        return (@a).i == (@b).i and (@a).sign == (@b).sign
    }
    if kind == TypeKind::ENUM or
        kind == TypeKind::STRUCT or
        kind == TypeKind::UNION {

        return (@a).type_name == (@b).type_name        
    }
    if kind == TypeKind::ARRAY or
        kind == TypeKind::POINTER or
        kind == TypeKind::REFERENCE {
        
        return equals((@a).tpe, (@b).tpe)
    }
    if kind == TypeKind::STATIC_ARRAY {
        return (@a).length == (@b).length and equals((@a).tpe, (@b).tpe)
    }
    if kind == TypeKind::FUNCTION {
        if vector::length((@a).parameter_t) != vector::length((@b).parameter_t) or
            vector::length((@a).return_t) != vector::length((@b).return_t) {
            return false        
        }
        for var i in 0..vector::length((@a).parameter_t) {
            if not equals(vector::get((@a).parameter_t, i), vector::get((@b).parameter_t, i)) {
                return false
            }
        }
        for var i in 0..vector::length((@a).return_t) {
            if not equals(vector::get((@a).return_t, i), vector::get((@b).return_t, i)) {
                return false
            }
        }
        return true
    }

    assert(false)
}

// Returns true if b is assignable to a
def is_assignable(a: *Type, b: *Type) -> bool {
    if equals(a, b) { return true }
    if (@a).kind == TypeKind::WORD {
        if (@b).kind == TypeKind::WORD {
            return (@a).size >= (@b).size
        }
        if (@b).kind == TypeKind::INT_LITERAL {
            if (@a).unsig {
                var i: uint64 = (@b).i * (@b).sign
                switch (@a).size {
                    case 1: return i <= util::MAX_UINT8
                    case 2: return i <= util::MAX_UINT16
                    case 4: return i <= util::MAX_UINT32
                    case 8: return true
                    case: assert(false)
                }
            } else {
                if (@b).i > util::MAX_INT64 { return false }
                var i: int64 = (@b).i * (@b).sign
                switch (@a).size {
                    case 1: return i >= util::MIN_INT8  and i <= util::MAX_INT8
                    case 2: return i >= util::MIN_INT16 and i <= util::MAX_INT16
                    case 4: return i >= util::MIN_INT32 and i <= util::MAX_INT32
                    case 8: return true
                    case: assert(false)
                }
            }
        }
    }
    if (@a).kind == TypeKind::FLOAT {
        if (@b).kind == TypeKind::WORD or
            (@b).kind == TypeKind::FLOAT {
            return true
        }
    }
    if (@a).kind == TypeKind::ARRAY {
        if (@b).kind == TypeKind::STATIC_ARRAY {
            return equals((@a).tpe, (@b).tpe)
        }
    }
    if (@a).kind == TypeKind::POINTER and (@a).tpe == null {
        return (@b).kind == TypeKind::POINTER
    }
    if (@a).kind == TypeKind::REFERENCE and (@a).tpe == null {
        return (@b).kind == TypeKind::REFERENCE
    }
    return false
}

// Tries to convert type b to type a
// The return value is -1 if b can't be converted to a
// if the types are equal, 0 is returned.
// Otherwise a positive integer is returned.
def convert_type_score(a: *Type, b: *Type) -> int {
    if equals(a, b) {
        return 0
    }
    if ((@a).kind == TypeKind::WORD or (@a).kind == TypeKind::FLOAT) and 
        (@b).kind == TypeKind::INT_LITERAL {
        if is_assignable(a, b) { return 0 }
        else { return -1 }
    }
    if (@a).kind == TypeKind::WORD and (@b).kind == TypeKind::WORD and
        (@a).size >= (@b).size {
        
        // TODO if we are ever going to allow a 24 bit value this is going to fail
        return log2((@a).size) !int - log2((@b).size) !int
    }
    if (@a).kind == TypeKind::FLOAT and (@b).kind == TypeKind::FLOAT {
        // TODO This works because there are only two float sizes
        return 1
    }
    if (@a).kind == TypeKind::FLOAT and
        (@b).kind == TypeKind::WORD {
        
        return 10
    }
    if ((@a).kind == TypeKind::POINTER and (@b).kind == TypeKind::POINTER or
        (@a).kind == TypeKind::REFERENCE and (@b).kind == TypeKind::REFERENCE) and
        (@a).tpe == null {
        
        return 1
    }
    if (@a).kind == TypeKind::ARRAY and (@b).kind == TypeKind::STATIC_ARRAY and 
        equals((@a).tpe, (@b).tpe) {
        
        return 1
    }
    return -1
}

// Calculates a score for overload resultion, the result is 0 for an exact match
// and a positive integer if the argument types need to be converted.
// -1 is returned if the argument types don't match.
export def overload_score(a: *Type, param_b: *vector::Vector) -> int {
    assert(is_function(a))

    let param_a = (@a).parameter_t
    // TODO varargs
    if vector::length(param_a) != vector::length(param_b) {
        return -1
    }

    var sum = 0
    for var i in 0..vector::length(param_a) {
        var score = convert_type_score(vector::get(param_a, i), vector::get(param_b, i))
        if score < 0 { return -1 }
        sum += score
    }

    return sum
}

export def type_to_str(tpe: *Type) -> string {
    var buf = buffer::make_buffer()

    switch ((@tpe).kind !int) {
        case TypeKind::WORD: 
            if (@tpe).unsig {
                buffer::append_char(*buf, 'u')
            }
            buffer::append_char(*buf, 'i')
            buffer::append_str(*buf, util::int_to_str((@tpe).size))
        case TypeKind::FLOAT:
            buffer::append_char(*buf, 'f')
            buffer::append_str(*buf, util::int_to_str((@tpe).size))
        case TypeKind::BOOL:
            buffer::append_char(*buf, 'b')
        case TypeKind::STRUCT:
            buffer::append_char(*buf, 'S')
            buffer::append_str(*buf, util::int_to_str(length((@tpe).type_name)))
            buffer::append_str(*buf, (@tpe).type_name)
        case TypeKind::UNION:
            buffer::append_char(*buf, 'U')
            buffer::append_str(*buf, util::int_to_str(length((@tpe).type_name)))
            buffer::append_str(*buf, (@tpe).type_name)
        case TypeKind::ENUM:
            buffer::append_char(*buf, 'E')
            buffer::append_str(*buf, util::int_to_str(length((@tpe).type_name)))
            buffer::append_str(*buf, (@tpe).type_name)
        case TypeKind::FUNCTION:
            buffer::append_char(*buf, 'F')
            for var i in 0..vector::length((@tpe).parameter_t) {
                buffer::append_str(*buf, type_to_str(vector::get((@tpe).parameter_t, i) !*Type))
            }
            buffer::append_char(*buf, '_')
            for var i in 0..vector::length((@tpe).return_t) {
                buffer::append_str(*buf, type_to_str(vector::get((@tpe).return_t, i) !*Type))
            }
            buffer::append_char(*buf, '$')
        case TypeKind::POINTER:
            buffer::append_char(*buf, 'P')
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
        case TypeKind::REFERENCE:
            buffer::append_char(*buf, 'R')
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
        case TypeKind::STATIC_ARRAY:
            buffer::append_char(*buf, 'a')
            buffer::append_str(*buf, util::int_to_str((@tpe).length))
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
        case TypeKind::ARRAY:
            buffer::append_char(*buf, 'A')
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
        case: assert(false)
    }

    return buffer::to_string(*buf)
}

export def mangle_function_name(name: string, parameter_t: *vector::Vector) -> string {
    var buf = buffer::make_buffer()
    buffer::append_str(*buf, "_F")
    buffer::append_str(*buf, util::int_to_str(length(name)))
    buffer::append_str(*buf, name)
    buffer::append_str(*buf, "__")

    for var i in 0..vector::length(parameter_t) {
        buffer::append_str(*buf, type_to_str(vector::get(parameter_t, i) !*Type))
    }

    return buffer::to_string(*buf)
}

// TODO Make this function variadic
export def errorn(node: *parser::Node, msg: string) {
    if not node { assert(false) }
    let filename = (@node).loc.filename
    let line = (@node).loc.line
    let column = (@node).loc.column

    error("\n")
    error(filename, "@", line + 1, ":", column + 1, "\n")
    error((@node).loc.lines[line], "\n")
    for var i in 0..column {
        error(" ")
    }
    error("^\n")
    error(msg)
}

import scope
import builtins
import debug

export def typecheck(node: *parser::Node, scope: *scope::Scope, filename: string) 

import toolchain

def unbox_int_literal(tpe: *Type) -> *Type {
    assert(tpe)
    if (@tpe).kind == TypeKind::INT_LITERAL {
        // TODO What about bigger literals
        return builtins::int_
    }
    return tpe
}

def type_lookup(node: *parser::Node, state: *State) -> *Type {
    if (@node).kind == parser::NodeKind::IDENTIFIER {
        return scope::get_type((@state).scope, node)
    }
    // TODO
    return null
}

// Returns the common type of two arithmetic types
// byte -> ubyte -> short -> ushort -> int -> uint -> long -> ulong
def common_type(a: *Type, b: *Type) -> *Type {
    assert(is_arithmetic(a) and is_arithmetic(b))

    a = unbox_int_literal(a)
    b = unbox_int_literal(b)

    if (@a).kind == TypeKind::FLOAT and (@b).kind == TypeKind::WORD {
        return a
    }
    if (@a).kind == (@b).kind {
        if (@a).size == (@b).size {
            if (@b).unsig {
                return b
            } else {
                return a
            }
        } else if (@a).size > (@b).size {
            return a 
        } else {
            return b
        }
    }
}

def walk(node: *parser::Node, state: *State)

let int_literal = make_type(TypeKind::INT_LITERAL, parser::make_identifier(["int_literal"]))

def walk_Integer(node: *parser::Node, state: *State) {
    var tpe = copy(int_literal)
    (@tpe).i = (@node).value.i
    (@tpe).sign = 1
    (@node).tpe = tpe
    (@node).scope = (@state).scope 
}

def walk_Boolean(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::bool_
    (@node).scope = (@state).scope
}

def walk_Float(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::double_
    (@node).scope = (@state).scope
}

def walk_String(node: *parser::Node, state: *State) {
    var tpe = allocate(Type)
    (@tpe).kind = TypeKind::STATIC_ARRAY
    (@tpe).tpe = builtins::char_
    (@tpe).length = (@node).value.str.size
    // Allocated size of the array
    (@tpe).size = (@tpe).length
    (@node).tpe = tpe
}

def walk_Char(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::char_
    (@node).scope = (@state).scope
}

def walk_Identifier(node: *parser::Node, state: *State) {
    let value = scope::get((@state).scope, node)
    if not value {
        errorn(node, "Unknown identifier ")
        error(parser::identifier_to_str(node), "\n")
    } else {
        (@node).tpe = (@value).tpe
    }
    (@node).scope = (@state).scope
}

def collapse_types(right: *vector::Vector, state: *State) -> *vector::Vector { 
    let types = vector::make()
    for var i in 0..vector::length(right) {
        let value = vector::get(right, i) !*parser::Node
        walk(value, state)
        let tpe = (@value).tpe
        if (@tpe).kind == TypeKind::TUPLE {
            for var j in 0..vector::length((@tpe).elements) {
                let tpe = vector::get((@tpe).elements, j) !*Type
                vector::push(types, tpe)
            }
        } else {
            vector::push(types, tpe)
        }
    }
    return types
}

def walk_Assign(node: *parser::Node, state: *State) {
    (@node).scope = (@state).scope
    let left = (@node).value.assign.left
    let right = (@node).value.assign.right

    let types = collapse_types(right, state)

    if vector::length(types) != vector::length(left) {
        errorn(node, "Unbalanced assignment\n")
        return
    }

    for var i in 0..vector::length(left) {
        let node = vector::get(left, i) !*parser::Node
        walk(node, state)
        if (@node).kind == parser::NodeKind::IDENTIFIER {
            let value = scope::get((@state).scope, node)
            if value {
                if (@value).modifier != parser::VarDecl::VAR {
                    errorn(node, "Assignment to non var\n")
                    continue
                }
            }
        }
        let tpe = vector::get(types, i) !*Type
        if not is_assignable((@node).tpe, tpe) {
            errorn(node, "Incompatible types ")
            error(debug::type_to_str((@node).tpe), " and ", debug::type_to_str(tpe), "\n")
        }
    }
}

def walk_VarDecl(node: *parser::Node, state: *State) {
    (@node).scope = (@state).scope

    let share = (@node).value.var_decl.share
    let kw = (@node).value.var_decl.kw
    let left = (@node).value.var_decl.left
    let right = (@node).value.var_decl.right

    let types = collapse_types(right, state)


    if (kw == parser::VarDecl::CONST or 
        kw == parser::VarDecl::LET) and 
        vector::length(types) != vector::length(left) {
        
        errorn(node, "Unbalanced assignment\n")
        return
    }

    if vector::length(types) > vector::length(left) {
        errorn(node, "Too many values to assign\n")
        return
    }

    for var i in 0..vector::length(left) {
        let node = vector::get(left, i) !*parser::Node
        if (@node).kind == parser::NodeKind::ID_DECL {
            var tpe_node = (@node).value.id_decl.tpe
            var tpe: *Type = null
            if tpe_node {
                tpe = type_lookup(tpe_node, state)
            } else {
                tpe = vector::get(types, i) !*Type
                tpe = unbox_int_literal(tpe)
            }

            let ident = (@node).value.id_decl.value

            assert((@ident).kind == parser::NodeKind::IDENTIFIER)

            var value: *parser::Node = null
            if i < vector::length(right) {
                value = vector::get(right, i) !*parser::Node
            }

            if value {
                var rhstpe = (@value).tpe

                if not is_assignable(tpe, rhstpe) {
                    errorn(node, "Incompatible types ")
                    error(debug::type_to_str(tpe), " and ", debug::type_to_str(rhstpe), "\n")
                }
            }

            (@ident).tpe = tpe
            // TODO Implement constants (set a value)
            scope::create_variable((@state).scope, ident, share, kw, tpe, null)

        } else if (@node).kind == parser::NodeKind::ID_ASSIGN {
            walk((@node).value.expr, state)
            let tpe = (@(@node).value.expr).tpe

            if i >= vector::length(types) {
                errorn(node, "Must assign a value\n")
                continue
            }

            let rhstpe = vector::get(types, i) !*Type

            if not is_assignable(tpe, rhstpe) {
                errorn(node, "Incompatible types ")
                error(debug::type_to_str(tpe), " and ", debug::type_to_str(rhstpe), "\n")
            }
        } else { assert(false) }
    }
}

def walk_Not(node: *parser::Node, state: *State) {
    walk((@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not is_boolean(tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str(tpe), ", must be boolean type\n")
    }
    (@node).tpe = tpe
    (@node).scope = (@state).scope
}

def walk_BNot(node: *parser::Node, state: *State) {
    walk((@node).value.expr, state)
    
    let tpe = unbox_int_literal((@(@node).value.expr).tpe)
    if not is_integer(tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str(tpe), ", must be integer type\n")
    }
    (@node).tpe = tpe
    (@node).scope = (@state).scope
}

def walk_UAdd(node: *parser::Node, state: *State) {
    walk((@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not is_arithmetic(tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str(tpe), ", must be arithmetic type\n")
    }
    (@node).tpe = tpe
    (@node).scope = (@state).scope
}

def walk_USub(node: *parser::Node, state: *State) {
    walk((@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not is_arithmetic(tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str(tpe), ", must be arithmetic type\n")
    }
    /*if (@tpe).unsig {
        errorn(node, "Negation on unsigned type ")
        error(debug::type_to_str(tpe))
    }*/ // TODO Maybe give a warning on this?
    if (@tpe).kind == TypeKind::INT_LITERAL {
        (@tpe).sign = -(@tpe).sign
    }
    (@node).tpe = tpe
    (@node).scope = (@state).scope
}

def walk_ArithmeticOp(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    walk(left, state)
    walk(right, state)

    (@node).tpe = common_type((@left).tpe, (@right).tpe)
    (@node).scope = (@state).scope
}

def walk_BitwiseOp(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    walk(left, state)
    walk(right, state)

    if not is_integer((@left).tpe) or not is_integer((@right).tpe) {
        errorn(node, "Invalid operands of type ")
        error(debug::type_to_str((@left).tpe), " and ", debug::type_to_str((@right).tpe), " to bitwise operator")
    }

    (@node).tpe = common_type((@left).tpe, (@right).tpe)
    (@node).scope = (@state).scope
}

def walk_BooleanOp(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    walk(left, state)
    walk(right, state)

    if not is_boolean((@left).tpe) or not is_boolean((@right).tpe) {
        errorn(node, "Invalid operands of type ")
        error(debug::type_to_str((@left).tpe), " and ", debug::type_to_str((@right).tpe), " to boolean operator")
    }

    (@node).tpe = builtins::bool_
    (@node).scope = (@state).scope
}

def walk_Cast(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    walk(left, state)
    walk(right, state)
    (@node).tpe = type_lookup(right, state)
    (@node).scope = (@state).scope
}

def walk_Import(node: *parser::Node, state: *State) {
    let imports = (@node).value.body
    for var i in 0..vector::length(imports) {
        let imprt = vector::get(imports, i) !*parser::Node
        var name = (@imprt).value.import_module.name
        var alias = (@imprt).value.import_module.name
        if not name {
            alias = name
        }
        let sc = toolchain::compile_module(name)
        if not sc {
            errorn(name, "Module ")
            error(parser::identifier_to_str(name), " could not be found\n")
            return
        }
        let ns = scope::enter_namespace((@state).scope, alias)
        if not ns { return }
        let values = map::keys((@sc).fields)
        for var i in 0..values.size {
            let value = map::get((@sc).fields, values[i]) !*scope::Value
            if (@value).share !int & parser::ShareMarker::EXPORT {
                map::put((@ns).fields, values[i], value)
            }
        }
        if not (@(@state).scope).imports {
            (@(@state).scope).imports = vector::make()
        }
        vector::push((@(@state).scope).imports, ns)
    }
}

def walk(node: *parser::Node, state: *State) {
    // Something is seriously going wrong here
    if not node { assert(false) }
    
    switch (@node).kind !int {
        case parser::NodeKind::INTEGER:
            walk_Integer(node, state)
        case parser::NodeKind::BOOLEAN:
            walk_Boolean(node, state)
        case parser::NodeKind::STRING:
            walk_String(node, state)
        case parser::NodeKind::CHAR:
            walk_Char(node, state)
        case parser::NodeKind::FLOAT:
            walk_Float(node, state)
        case parser::NodeKind::IDENTIFIER:
            walk_Identifier(node, state)
        case parser::NodeKind::CAST:
            walk_Cast(node, state)
        case parser::NodeKind::ASSIGN:
            walk_Assign(node, state)
        case parser::NodeKind::VAR_DECL:
            walk_VarDecl(node, state)
        case parser::NodeKind::UADD:
            walk_UAdd(node, state)
        case parser::NodeKind::USUB:
            walk_USub(node, state)
        case parser::NodeKind::BNOT:
            walk_BNot(node, state)
        case parser::NodeKind::NOT:
            walk_Not(node, state)
        case parser::NodeKind::ADD..parser::NodeKind::MOD:
            walk_ArithmeticOp(node, state)
        case parser::NodeKind::BAND..parser::NodeKind::BXOR:
            walk_BitwiseOp(node, state)
        case parser::NodeKind::AND..parser::NodeKind::OR:
            walk_BooleanOp(node, state)
        case:
            assert(false)
    }
}

export def typecheck(node: *parser::Node, scope: *scope::Scope, filename: string) {
    assert((@node).kind == parser::NodeKind::PROGRAM)

    var state: State
    state.filename = filename
    state.scope = scope

    for var i in 0..vector::length((@node).value.body) {
        walk(vector::get((@node).value.body, i) !*parser::Node, *state)
    }
}