import map
import vector
import parser
import buffer
import util

export type TypeKind = enum {
    TYPE
    WORD
    FLOAT
    BOOL
    STRUCT
    UNION
    ENUM
    FUNCTION
    POINTER
    REFERENCE
    STATIC_ARRAY
    ARRAY
    // Type for integer literal, this converts to all sorts of types
    INT_LITERAL
    // Used for enums
    NAMESPACE
    // Auto cast, this type will convert to anything
    // AUTO_CAST // TODO Actually implement this
    // Forward declaration
    STUB
}

export type Type

export type StructMember = struct {
    name: string
    tpe: *Type
    offset: size_t
}

export type Type = struct {
    kind: TypeKind
    // Name of the type as used by the source code
    // Might be the name of a typedef
    name: string
    // Unique name of the type
    type_name: string
    // Size in bytes
    size: size_t
    align: size_t
    unsig: bool
    // Static array
    length: size_t
    // Type both used for array/pointer and enum
    tpe: *Type
    // Fields for struct, array of StructMember
    fields: [StructMember]
    // Function
    return_t: *vector::Vector
    parameter_t: *vector::Vector
    // int literal
    i: uint64
    // -1 for negative numbers, 1 for postive
    // This is so that we can represent all possible numbers
    sign: int
}

export type NamedParameter = struct {
    // Might be empty for positional parameters
    name: string
    value: *Type
}

type scope::Scope

type State = struct {
    filename: string
    module: string
    scope: *scope::Scope
    function_stack: *vector::Vector
}

def current_function(state: *State) -> *Type {
    let length = vector::length((@state).function_stack)
    if length == 0 {
        return null
    } else {
        return vector::get((@state).function_stack, length - 1) !*Type
    }
}

def push_function(state: *State, tpe: *Type) {
    vector::push((@state).function_stack, tpe)
}

def pop_function(state: *State) -> *Type {
    return vector::pop((@state).function_stack) !*Type
}

export def is_function(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::FUNCTION
}

export def is_arithmetic(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::WORD or 
        (@tpe).kind == TypeKind::FLOAT or 
        (@tpe).kind == TypeKind::INT_LITERAL
}

export def is_integer(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::WORD or 
        (@tpe).kind == TypeKind::INT_LITERAL
}

export def is_boolean(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::BOOL or
        (@tpe).kind == TypeKind::WORD or
        (@tpe).kind == TypeKind::FLOAT or
        (@tpe).kind == TypeKind::POINTER or
        (@tpe).kind == TypeKind::REFERENCE
}

def append_module(name: string, node: *parser::Node) -> string {
    var buf = buffer::make_buffer()
    buffer::append_str(*buf, (@node).loc.module)
    buffer::append_str(*buf, "::")
    buffer::append_str(*buf, name)
    return buffer::to_string(*buf)
}

export def make_type(kind: TypeKind, node: *parser::Node) -> *Type {
    assert((@node).kind == parser::NodeKind::IDENTIFIER)
    let name = parser::identifier_to_str(node)
    var t = allocate(Type)
    (@t).kind = kind
    (@t).type_name = append_module(name, node)
    (@t).name = name

    return t
}

def make_anonymous_type(kind: TypeKind, node: *parser::Node) -> *Type {
    let name = util::make_unique_name()
    var t = allocate(Type)
    (@t).kind = kind
    (@t).type_name = append_module(name, node)
    (@t).name = name

    return t
}

export def copy(a: *Type) -> *Type {
    var t = allocate(Type)
    @t = @a
    return t
}

export def equals(a: *Type, b: *Type) -> bool {
    if a == b {
        return true
    }
    if (@a).kind != (@b).kind { return false }

    let kind = (@a).kind
    if kind == TypeKind::BOOL { return true }
    if kind == TypeKind::WORD or kind == TypeKind::FLOAT {
        return (@a).size == (@b).size
    }
    if kind == TypeKind::INT_LITERAL {
        return (@a).i == (@b).i and (@a).sign == (@b).sign
    }
    if kind == TypeKind::ENUM or
        kind == TypeKind::STRUCT or
        kind == TypeKind::UNION {

        return (@a).type_name == (@b).type_name        
    }
    if kind == TypeKind::ARRAY or
        kind == TypeKind::POINTER or
        kind == TypeKind::REFERENCE {
        
        return equals((@a).tpe, (@b).tpe)
    }
    if kind == TypeKind::STATIC_ARRAY {
        return (@a).length == (@b).length and equals((@a).tpe, (@b).tpe)
    }
    if kind == TypeKind::FUNCTION {
        if vector::length((@a).parameter_t) != vector::length((@b).parameter_t) or
            vector::length((@a).return_t) != vector::length((@b).return_t) {
            return false        
        }
        for var i in 0..vector::length((@a).parameter_t) {
            if not equals(vector::get((@a).parameter_t, i), vector::get((@b).parameter_t, i)) {
                return false
            }
        }
        for var i in 0..vector::length((@a).return_t) {
            if not equals(vector::get((@a).return_t, i), vector::get((@b).return_t, i)) {
                return false
            }
        }
        return true
    }

    assert(false)
}

// Returns true if b is assignable to a
def is_assignable(a: *Type, b: *Type) -> bool {
    if equals(a, b) { return true }
    if (@a).kind == TypeKind::WORD {
        if (@b).kind == TypeKind::WORD {
            return (@a).size >= (@b).size
        }
        if (@b).kind == TypeKind::INT_LITERAL {
            if (@a).unsig {
                var i: uint64 = (@b).i * (@b).sign
                switch (@a).size {
                    case 1: return i <= util::MAX_UINT8
                    case 2: return i <= util::MAX_UINT16
                    case 4: return i <= util::MAX_UINT32
                    case 8: return true
                    case: assert(false)
                }
            } else {
                if (@b).i > util::MAX_INT64 { return false }
                var i: int64 = (@b).i * (@b).sign
                switch (@a).size {
                    case 1: return i >= util::MIN_INT8  and i <= util::MAX_INT8
                    case 2: return i >= util::MIN_INT16 and i <= util::MAX_INT16
                    case 4: return i >= util::MIN_INT32 and i <= util::MAX_INT32
                    case 8: return true
                    case: assert(false)
                }
            }
        }
    }
    if (@a).kind == TypeKind::FLOAT {
        if (@b).kind == TypeKind::WORD or
            (@b).kind == TypeKind::FLOAT {
            return true
        }
    }
    if (@a).kind == TypeKind::ARRAY {
        if (@b).kind == TypeKind::STATIC_ARRAY {
            return equals((@a).tpe, (@b).tpe)
        }
    }
    if (@a).kind == TypeKind::POINTER and (@a).tpe == null {
        return (@b).kind == TypeKind::POINTER
    }
    if (@a).kind == TypeKind::REFERENCE and (@a).tpe == null {
        return (@b).kind == TypeKind::REFERENCE
    }
    return false
}

// Tries to convert type b to type a
// The return value is -1 if b can't be converted to a
// if the types are equal, 0 is returned.
// Otherwise a positive integer is returned.
def convert_type_score(a: *Type, b: *Type) -> int {
    if equals(a, b) {
        return 0
    }
    if ((@a).kind == TypeKind::WORD or (@a).kind == TypeKind::FLOAT) and 
        (@b).kind == TypeKind::INT_LITERAL {
        if is_assignable(a, b) { return 0 }
        else { return -1 }
    }
    if (@a).kind == TypeKind::WORD and (@b).kind == TypeKind::WORD and
        (@a).size >= (@b).size {
        
        // TODO if we are ever going to allow a 24 bit value this is going to fail
        return log2((@a).size) !int - log2((@b).size) !int
    }
    if (@a).kind == TypeKind::FLOAT and (@b).kind == TypeKind::FLOAT {
        // TODO This works because there are only two float sizes
        return 1
    }
    if (@a).kind == TypeKind::FLOAT and
        (@b).kind == TypeKind::WORD {
        
        return 10
    }
    if ((@a).kind == TypeKind::POINTER and (@b).kind == TypeKind::POINTER or
        (@a).kind == TypeKind::REFERENCE and (@b).kind == TypeKind::REFERENCE) and
        (@a).tpe == null {
        
        return 1
    }
    if (@a).kind == TypeKind::ARRAY and (@b).kind == TypeKind::STATIC_ARRAY and 
        equals((@a).tpe, (@b).tpe) {
        
        return 1
    }
    return -1
}

// Calculates a score for overload resultion, the result is 0 for an exact match
// and a positive integer if the argument types need to be converted.
// -1 is returned if the argument types don't match.
export def overload_score(a: *Type, param_b: *vector::Vector) -> int {
    assert(is_function(a))

    let param_a = (@a).parameter_t
    // TODO varargs and default arguments
    if vector::length(param_a) != vector::length(param_b) {
        return -1
    }

    var sum = 0
    for var i in 0..vector::length(param_b) {
        let right = vector::get(param_b, i) !*NamedParameter
        var left: *NamedParameter
        if length((@right).name) > 0 {
            for var i in 0..vector::length(param_a) {
                let param = vector::get(param_a, i) !*NamedParameter
                if (@right).name == (@param).name {
                    left = param
                    break
                }
            }
            if not left { return -1 }
        } else {
            left = vector::get(param_a, i) !*NamedParameter
        }
        let score = convert_type_score((@left).value, (@right).value)
        if score < 0 { return -1 }
        sum += score
    }

    return sum
}

export def type_to_str(tpe: *Type) -> string {
    var buf = buffer::make_buffer()

    switch ((@tpe).kind !int) {
        case TypeKind::WORD: 
            if (@tpe).unsig {
                buffer::append_char(*buf, 'u')
            }
            buffer::append_char(*buf, 'i')
            buffer::append_str(*buf, util::int_to_str((@tpe).size))
        case TypeKind::FLOAT:
            buffer::append_char(*buf, 'f')
            buffer::append_str(*buf, util::int_to_str((@tpe).size))
        case TypeKind::BOOL:
            buffer::append_char(*buf, 'b')
        case TypeKind::STRUCT:
            buffer::append_char(*buf, 'S')
            buffer::append_str(*buf, util::int_to_str(length((@tpe).type_name)))
            buffer::append_str(*buf, (@tpe).type_name)
        case TypeKind::UNION:
            buffer::append_char(*buf, 'U')
            buffer::append_str(*buf, util::int_to_str(length((@tpe).type_name)))
            buffer::append_str(*buf, (@tpe).type_name)
        case TypeKind::ENUM:
            buffer::append_char(*buf, 'E')
            buffer::append_str(*buf, util::int_to_str(length((@tpe).type_name)))
            buffer::append_str(*buf, (@tpe).type_name)
        case TypeKind::FUNCTION:
            buffer::append_char(*buf, 'F')
            for var i in 0..vector::length((@tpe).parameter_t) {
                buffer::append_str(*buf, type_to_str(vector::get((@tpe).parameter_t, i) !*Type))
            }
            buffer::append_char(*buf, '_')
            for var i in 0..vector::length((@tpe).return_t) {
                buffer::append_str(*buf, type_to_str(vector::get((@tpe).return_t, i) !*Type))
            }
            buffer::append_char(*buf, '$')
        case TypeKind::POINTER:
            buffer::append_char(*buf, 'P')
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
        case TypeKind::REFERENCE:
            buffer::append_char(*buf, 'R')
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
        case TypeKind::STATIC_ARRAY:
            buffer::append_char(*buf, 'a')
            buffer::append_str(*buf, util::int_to_str((@tpe).length))
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
        case TypeKind::ARRAY:
            buffer::append_char(*buf, 'A')
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
        case: assert(false)
    }

    return buffer::to_string(*buf)
}

export def mangle_function_name(name: string, parameter_t: *vector::Vector) -> string {
    var buf = buffer::make_buffer()
    buffer::append_str(*buf, "_F")
    buffer::append_str(*buf, util::int_to_str(length(name)))
    buffer::append_str(*buf, name)
    buffer::append_str(*buf, "__")

    for var i in 0..vector::length(parameter_t) {
        buffer::append_str(*buf, type_to_str(vector::get(parameter_t, i) !*Type))
    }

    return buffer::to_string(*buf)
}

// TODO Make this function variadic
export def errorn(node: *parser::Node, msg: string) {
    if not node { assert(false) }
    let filename = (@node).loc.filename
    let line = (@node).loc.line
    let column = (@node).loc.column

    error("\n")
    error(filename, "@", line + 1, ":", column + 1, "\n")
    error((@node).loc.lines[line], "\n")
    for var i in 0..column {
        error(" ")
    }
    error("^\n")
    error(msg)
}

def last_ident_to_str(node: *parser::Node) -> string {
    assert((@node).kind == parser::NodeKind::IDENTIFIER)
    if vector::length((@node).value.body) > 1 {
        errorn(node, "Expected plain identifier without path\n")
    }
    return @(vector::get((@node).value.body, 0) !*string)
}

import scope
import builtins
import debug

export def typecheck(node: *parser::Node, scope: *scope::Scope, filename: string, module: string) 

import toolchain

def unbox_int_literal(tpe: *Type) -> *Type {
    assert(tpe)
    if (@tpe).kind == TypeKind::INT_LITERAL {
        // TODO What about bigger literals
        return builtins::int_
    }
    return tpe
}

def type_lookup(node: *parser::Node, state: *State) -> *Type {
    if (@node).kind == parser::NodeKind::IDENTIFIER {
        return scope::get_type((@state).scope, node)
    } else if (@node).kind == parser::NodeKind::STRUCT_T {
        let tpe = make_anonymous_type(TypeKind::STRUCT, node)
        
        let length = vector::length((@node).value.body)
        if length == 0 {
            errorn(node, "Empty struct not allowed\n")
            return null
        }

        let fields = allocate(StructMember, length)

        var offset = 0
        var align = 1
        for var i in 0..length {
            let field = vector::get((@node).value.body, i) !*parser::Node
            // TODO Allow anonymous structs
            assert((@field).kind == parser::NodeKind::ID_DECL_STRUCT)
            
            var name = last_ident_to_str((@field).value.id_decl_struct.ident)
            var tpe = type_lookup((@field).value.id_decl_struct.tpe, state)
            
            offset = (ceil(offset / (@tpe).align !double) * (@tpe).align) !int
            align = util::lcm(align, (@tpe).align)

            fields[i] = { name, tpe, offset } !StructMember
            offset += (@tpe).size
        }
        offset = (ceil(offset / align !double) * align) !int

        (@tpe).size = offset
        (@tpe).align = align
        (@tpe).fields = fields

        return tpe
    } else if (@node).kind == parser::NodeKind::UNION_T {
        let tpe = make_anonymous_type(TypeKind::UNION, node)

        let length = vector::length((@node).value.body)
        if length == 0 {
            errorn(node, "Empty union not allowed\n")
            return null
        }

        let fields = allocate(StructMember, length)

        var size = 0
        var align = 1
        for var i in 0..length {
            let field = vector::get((@node).value.body, i) !*parser::Node
            // TODO Allow anonymous structs
            assert((@field).kind == parser::NodeKind::ID_DECL_STRUCT)

            var name = last_ident_to_str((@field).value.id_decl_struct.ident)
            var tpe = type_lookup((@field).value.id_decl_struct.tpe, state)

            fields[i] = { name, tpe, 0 } !StructMember

            size = max((@tpe).size, size) !int
            align = max((@tpe).align, align) !int
        }

        (@tpe).size = size
        (@tpe).align = align
        (@tpe).fields = fields

        return tpe
    }

    error((@node).kind !int, "\n")
    assert(false)
    // TODO
    return null
}

// Returns the common type of two arithmetic types
// byte -> ubyte -> short -> ushort -> int -> uint -> long -> ulong
def common_type(a: *Type, b: *Type) -> *Type {
    assert(is_arithmetic(a) and is_arithmetic(b))

    a = unbox_int_literal(a)
    b = unbox_int_literal(b)

    if (@a).kind == TypeKind::FLOAT and (@b).kind == TypeKind::WORD {
        return a
    }
    if (@a).kind == (@b).kind {
        if (@a).size == (@b).size {
            if (@b).unsig {
                return b
            } else {
                return a
            }
        } else if (@a).size > (@b).size {
            return a 
        } else {
            return b
        }
    }
}

def walk(node: *parser::Node, state: *State)

let int_literal = make_type(TypeKind::INT_LITERAL, parser::make_identifier(["int_literal"]))

def walk_Integer(node: *parser::Node, state: *State) {
    var tpe = copy(int_literal)
    (@tpe).i = (@node).value.i
    (@tpe).sign = 1
    (@node).tpe = tpe
}

def walk_Boolean(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::bool_
}

def walk_Float(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::double_
}

def walk_String(node: *parser::Node, state: *State) {
    var tpe = allocate(Type)
    (@tpe).kind = TypeKind::STATIC_ARRAY
    (@tpe).tpe = builtins::char_
    (@tpe).length = (@node).value.str.size
    // Allocated size of the array
    (@tpe).size = (@tpe).length
    (@node).tpe = tpe
}

def walk_Char(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::char_
}

def walk_Identifier(node: *parser::Node, state: *State) {
    let value = scope::get((@state).scope, node)
    if not value {
        errorn(node, "Unknown identifier ")
        error(parser::identifier_to_str(node), "\n")
    } else {
        (@node).tpe = (@value).tpe
    }
}

def collapse_types(right: *vector::Vector, state: *State) -> *vector::Vector { 
    let types = vector::make()
    for var i in 0..vector::length(right) {
        let value = vector::get(right, i) !*parser::Node
        walk(value, state)
        let tpe = (@value).tpe
        if (@tpe).kind == TypeKind::FUNCTION {
            for var j in 0..vector::length((@tpe).return_t) {
                let t = vector::get((@tpe).return_t, j) !*Type
                vector::push(types, t)
            }
        } else {
            vector::push(types, tpe)
        }
    }
    return types
}

def walk_Assign(node: *parser::Node, state: *State) {
    let left = (@node).value.assign.left
    let right = (@node).value.assign.right

    let types = collapse_types(right, state)

    if vector::length(types) != vector::length(left) {
        errorn(node, "Unbalanced assignment\n")
        return
    }

    for var i in 0..vector::length(left) {
        let node = vector::get(left, i) !*parser::Node
        walk(node, state)
        if (@node).kind == parser::NodeKind::IDENTIFIER {
            let value = scope::get((@state).scope, node)
            if value {
                if (@value).modifier != parser::VarDecl::VAR {
                    errorn(node, "Assignment to non var\n")
                    continue
                }
            }
        }
        let tpe = vector::get(types, i) !*Type
        if not is_assignable((@node).tpe, tpe) {
            errorn(node, "Incompatible types ")
            error(debug::type_to_str((@node).tpe), " and ", debug::type_to_str(tpe), "\n")
        }
    }
}

def walk_VarDecl(node: *parser::Node, state: *State) {

    let share = (@node).value.var_decl.share
    let kw = (@node).value.var_decl.kw
    let left = (@node).value.var_decl.left
    let right = (@node).value.var_decl.right

    if current_function(state) {
        if share != parser::ShareMarker::NONE {
            errorn(node, "Can't share non top level variable\n")
        }
    }


    let types = collapse_types(right, state)


    if (kw == parser::VarDecl::CONST or 
        kw == parser::VarDecl::LET) and 
        vector::length(types) != vector::length(left) {
        
        errorn(node, "Unbalanced assignment\n")
        return
    }

    if vector::length(types) > vector::length(left) {
        errorn(node, "Too many values to assign\n")
        return
    }

    for var i in 0..vector::length(left) {
        let node = vector::get(left, i) !*parser::Node
        if (@node).kind == parser::NodeKind::ID_DECL {
            var tpe_node = (@node).value.id_decl.tpe
            var tpe: *Type = null
            if tpe_node {
                tpe = type_lookup(tpe_node, state)
            } else {
                if i < vector::length(types) {
                    tpe = vector::get(types, i) !*Type
                    tpe = unbox_int_literal(tpe)
                } else {
                    errorn(node, "Need to specify a type\n")
                    continue
                }
            }

            let ident = (@node).value.id_decl.value

            assert((@ident).kind == parser::NodeKind::IDENTIFIER)

            var value: *parser::Node = null
            if i < vector::length(right) {
                value = vector::get(right, i) !*parser::Node
            }

            if value {
                var rhstpe = (@value).tpe

                if not is_assignable(tpe, rhstpe) {
                    errorn(node, "Incompatible types ")
                    error(debug::type_to_str(tpe), " and ", debug::type_to_str(rhstpe), "\n")
                }
            }

            (@ident).tpe = tpe
            // TODO Implement constants (set a value)
            scope::create_variable((@state).scope, ident, share, kw, tpe, null)

        } else if (@node).kind == parser::NodeKind::ID_ASSIGN {
            walk((@node).value.expr, state)
            let tpe = (@(@node).value.expr).tpe

            if i >= vector::length(types) {
                errorn(node, "Must assign a value\n")
                continue
            }

            let rhstpe = vector::get(types, i) !*Type

            if not is_assignable(tpe, rhstpe) {
                errorn(node, "Incompatible types ")
                error(debug::type_to_str(tpe), " and ", debug::type_to_str(rhstpe), "\n")
            }
        } else { assert(false) }
    }
}

def walk_Not(node: *parser::Node, state: *State) {
    walk((@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not is_boolean(tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str(tpe), ", must be boolean type\n")
    }
    (@node).tpe = tpe
}

def walk_BNot(node: *parser::Node, state: *State) {
    walk((@node).value.expr, state)
    
    let tpe = unbox_int_literal((@(@node).value.expr).tpe)
    if not is_integer(tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str(tpe), ", must be integer type\n")
    }
    (@node).tpe = tpe
}

def walk_UAdd(node: *parser::Node, state: *State) {
    walk((@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not is_arithmetic(tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str(tpe), ", must be arithmetic type\n")
    }
    (@node).tpe = tpe
}

def walk_USub(node: *parser::Node, state: *State) {
    walk((@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not is_arithmetic(tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str(tpe), ", must be arithmetic type\n")
    }
    /*if (@tpe).unsig {
        errorn(node, "Negation on unsigned type ")
        error(debug::type_to_str(tpe))
    }*/ // TODO Maybe give a warning on this?
    if (@tpe).kind == TypeKind::INT_LITERAL {
        (@tpe).sign = -(@tpe).sign
    }
    (@node).tpe = tpe
}

def walk_ArithmeticOp(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    walk(left, state)
    walk(right, state)

    (@node).tpe = common_type((@left).tpe, (@right).tpe)
}

def walk_BitwiseOp(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    walk(left, state)
    walk(right, state)

    if not is_integer((@left).tpe) or not is_integer((@right).tpe) {
        errorn(node, "Invalid operands of type ")
        error(debug::type_to_str((@left).tpe), " and ", debug::type_to_str((@right).tpe), " to bitwise operator")
    }

    (@node).tpe = common_type((@left).tpe, (@right).tpe)
}

def walk_BooleanOp(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    walk(left, state)
    walk(right, state)

    if not is_boolean((@left).tpe) or not is_boolean((@right).tpe) {
        errorn(node, "Invalid operands of type ")
        error(debug::type_to_str((@left).tpe), " and ", debug::type_to_str((@right).tpe), " to boolean operator")
    }

    (@node).tpe = builtins::bool_
}

def walk_Cast(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    walk(left, state)
    walk(right, state)
    (@node).tpe = type_lookup(right, state)
}

def walk_Import(node: *parser::Node, state: *State) {
    let imports = (@node).value.body
    for var i in 0..vector::length(imports) {
        let imprt = vector::get(imports, i) !*parser::Node
        var name = (@imprt).value.import_module.name
        var alias = (@imprt).value.import_module.name
        if not name {
            alias = name
        }
        let sc = toolchain::compile_module(name)
        if not sc {
            errorn(name, "Module ")
            error(parser::identifier_to_str(name), " could not be found\n")
            return
        }
        let ns = scope::enter_namespace((@state).scope, alias)
        if not ns { return }
        let values = map::keys((@sc).fields)
        for var i in 0..values.size {
            let value = map::get((@sc).fields, values[i]) !*scope::Value
            if (@value).share !int & parser::ShareMarker::EXPORT {
                map::put((@ns).fields, values[i], value)
            }
        }
        if not (@(@state).scope).imports {
            (@(@state).scope).imports = vector::make()
        }
        vector::push((@(@state).scope).imports, ns)
    }
}

def walk_Def(node: *parser::Node, state: *State) {
    let share = (@node).value.def_.share
    let body = (@node).value.def_.body
    let name = (@node).value.def_.name
    let params = (@node).value.def_.params
    let returns = (@node).value.def_.returns
    let outer_scope = (@state).scope

    if current_function(state) {
        if share != parser::ShareMarker::NONE {
            errorn(node, "Can't share non top level function\n")
        }
    }

    var forward_declare = true
    if body {
        forward_declare = false
        (@state).scope = scope::enter_scope((@state).scope)
    }

    let parameter_t = vector::make()
    let return_t = vector::make()
    for var i in 0..vector::length(params) {
        let param = vector::get(params, i) !*parser::Node
        assert((@param).kind == parser::NodeKind::PARAMETER)
        let named = allocate(NamedParameter)
        let name = (@param).value.param.name
        let tpe = type_lookup((@param).value.param.tpe, state)
        (@named).name = last_ident_to_str(name)
        (@named).value = tpe

        if body {
            scope::create_variable((@state).scope, name, parser::ShareMarker::NONE, parser::VarDecl::VAR, tpe, null)
        }

        vector::push(parameter_t, named)
    }
    for var i in 0..vector::length(returns) {
        vector::push(return_t, type_lookup(vector::get(returns, i) !*parser::Node, state))
    }
    
    let tpe = make_type(typechecking::TypeKind::FUNCTION, name)
    (@tpe).parameter_t = parameter_t
    (@tpe).return_t = return_t
    if current_function(state) {
        // This is so that we don't create overloaded functions
        // inside of a function
        // TODO what about forward declarations?
        scope::create_variable(outer_scope, name, share, parser::VarDecl::CONST, tpe, null)
    } else {
        scope::create_function(outer_scope, name, share, tpe, forward_declare)
    }
    

    if body {
        push_function(state, tpe)
        for var i in 0..vector::length(body) {
            walk(vector::get(body, i) !*parser::Node, state)
        }
        (@state).scope = scope::exit_scope((@state).scope)
        pop_function(state)
    }

    (@node).tpe = tpe
}

def walk_TypeDecl(node: *parser::Node, state: *State) {
    let share = (@node).value.type_decl.share
    let left = (@node).value.type_decl.left
    let right = (@node).value.type_decl.right

    if vector::length(left) < vector::length(right) {
        errorn(node, "Too many values to assign\n")
        return
    }

    for var i in 0..vector::length(left) {
        let name = vector::get(left, i)
        var value: *parser::Node = null
        if i < vector::length(right) {
            value = vector::get(right, i)
        }
        
        var tpe = make_type(TypeKind::STUB, name)
        if not scope::create_type((@state).scope, name, share, tpe) {
            continue
        }
        
        if value {
            tpe = copy(type_lookup(value, state))
            (@tpe).name = parser::identifier_to_str(name)
            if (@value).kind == parser::NodeKind::STRUCT_T or
                (@value).kind == parser::NodeKind::UNION_T {
                // Name anonymous struct or union
                (@tpe).type_name = append_module((@tpe).name, node)
            }
            scope::create_type((@state).scope, name, share, tpe)
        }
    }
}

def walk_Return(node: *parser::Node, state: *State) {
    let current_fun = current_function(state)
    let body = (@node).value.body
    if not current_fun {
        // TODO This is actually allowed, I just need to infer the types
        // and assign to some sort of internal variable
        errorn(node, "return outside of a function\n")
        return
    }
    
    let types = collapse_types(body, state)
    let returns = (@current_fun).return_t

    if vector::length(types) != vector::length(returns) {
        // TODO Improve error message
        errorn(node, "Wrong number of arguments to return\n")
    }

    for var i in 0..vector::length(returns) {
        let argtpe = vector::get(returns, i)
        let rettpe = vector::get(types, i)
        if not is_assignable(argtpe, rettpe) {
            // TODO This doesn't point to the actual value
            errorn(node, "Wrong type of return argument, got ")
            error(debug::type_to_str(rettpe), ", expected ", debug::type_to_str(argtpe), "\n")
        }
    }
    (@node).tpe = current_fun
}

def walk_FuncCall(node: *parser::Node, state: *State) {
    var arguments = vector::make()

    for var i in 0..vector::length((@node).value.func_call.args) {
        let n = vector::get((@node).value.func_call.args, i) !*parser::Node
        walk(n, state)
        let np = allocate(NamedParameter)
        (@np).name = ""
        (@np).value = (@n).tpe
        vector::push(arguments, np)
    }
    for var i in 0..vector::length((@node).value.func_call.kwargs) {
        let n = vector::get((@node).value.func_call.kwargs, i) !*parser::Node
        walk((@n).value.named_arg.value, state)
        let np = allocate(NamedParameter)
        (@np).name = last_ident_to_str((@n).value.named_arg.name)
        (@np).value = (@n).tpe
        vector::push(arguments, np)
    }
    // TODO What about function pointers and foo.bar(baz) == bar(foo, baz)
    let left = (@node).value.func_call.left
    let function = scope::get_function((@state).scope, left, arguments)

    if not function {
        errorn(left, "Function \"")
        error(parser::identifier_to_str(left), "\" not found\n")
    } else {
        (@node).tpe = (@function).tpe
    }    
}

def walk(node: *parser::Node, state: *State) {
    // Something is seriously going wrong here
    if not node { assert(false) }
    
    switch (@node).kind !int {
        case parser::NodeKind::INTEGER:
            walk_Integer(node, state)
        case parser::NodeKind::BOOLEAN:
            walk_Boolean(node, state)
        case parser::NodeKind::STRING:
            walk_String(node, state)
        case parser::NodeKind::CHAR:
            walk_Char(node, state)
        case parser::NodeKind::FLOAT:
            walk_Float(node, state)
        case parser::NodeKind::IDENTIFIER:
            walk_Identifier(node, state)
        case parser::NodeKind::DEF:
            walk_Def(node, state)
        case parser::NodeKind::IMPORT:
            walk_Import(node, state)
        case parser::NodeKind::CAST:
            walk_Cast(node, state)
        case parser::NodeKind::ASSIGN:
            walk_Assign(node, state)
        case parser::NodeKind::VAR_DECL:
            walk_VarDecl(node, state)
        case parser::NodeKind::UADD:
            walk_UAdd(node, state)
        case parser::NodeKind::USUB:
            walk_USub(node, state)
        case parser::NodeKind::BNOT:
            walk_BNot(node, state)
        case parser::NodeKind::NOT:
            walk_Not(node, state)
        case parser::NodeKind::ADD..parser::NodeKind::MOD:
            walk_ArithmeticOp(node, state)
        case parser::NodeKind::BAND..parser::NodeKind::BXOR:
            walk_BitwiseOp(node, state)
        case parser::NodeKind::AND..parser::NodeKind::OR:
            walk_BooleanOp(node, state)
        case parser::NodeKind::TYPE_DECL:
            walk_TypeDecl(node, state)
        case parser::NodeKind::RETURN:
            walk_Return(node, state)
        case parser::NodeKind::FUNC_CALL:
            walk_FuncCall(node, state)
        case:
            assert(false)
    }
    (@node).scope = (@state).scope
}

export def typecheck(node: *parser::Node, scope: *scope::Scope, filename: string, module: string) {
    assert((@node).kind == parser::NodeKind::PROGRAM)

    var state: State
    state.filename = filename
    state.module = module
    state.scope = scope
    state.function_stack = vector::make()

    for var i in 0..vector::length((@node).value.body) {
        walk(vector::get((@node).value.body, i) !*parser::Node, *state)
    }
    (@node).scope = state.scope
}