// TODO Many of these function will error twice with misleading errors
// Every function needs to check for possible null types and null nodes
// and abort in those cases

import map
import vector
import parser
import buffer
import util

export type TypeKind = enum {
    TYPE
    WORD
    FLOAT
    BOOL
    STRUCT
    UNION
    ENUM
    FUNCTION
    POINTER
    REFERENCE
    STATIC_ARRAY
    ARRAY
    // Type for integer literal, this converts to all sorts of types
    INT_LITERAL
    // Used for enums
    NAMESPACE
    // Auto cast, this type will convert to anything
    // AUTO_CAST // TODO Actually implement this
    // Forward declaration
    STUB
}

export type Type

export type StructMember = struct {
    name: string
    tpe: *Type
    offset: size_t
}

export type Type = struct {
    kind: TypeKind
    // Name of the type as used by the source code
    // Might be the name of a typedef
    name: string
    // Unique name of the type
    type_name: string
    // Size in bytes
    size: size_t
    align: size_t
    unsig: bool
    // TODO Add kw (parser::VarDecl) for arrays and pointers
    // Static array
    length: size_t
    // Type both used for array/pointer and enum
    tpe: *Type
    packed: bool
    // Fields for struct, array of StructMember
    fields: [StructMember]
    // Function
    return_t: *vector::Vector
    parameter_t: *vector::Vector
    // int literal
    i: uint64
    // -1 for negative numbers, 1 for postive
    // This is so that we can represent all possible numbers
    sign: int
}

export type NamedParameter = struct {
    // Might be empty for positional parameters
    name: string
    value: *Type
}

type scope::Scope

type State = struct {
    filename: string
    module: string
    scope: *scope::Scope
    function_stack: *vector::Vector
}

export def errorn(node: *parser::Node, msg: string)

def current_function(state: *State) -> *Type {
    let length = vector::length((@state).function_stack)
    if length == 0 {
        return null
    } else {
        return vector::get((@state).function_stack, length - 1) !*Type
    }
}

def push_function(state: *State, tpe: *Type) {
    vector::push((@state).function_stack, tpe)
}

def pop_function(state: *State) -> *Type {
    return vector::pop((@state).function_stack) !*Type
}

export def is_function(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::FUNCTION
}

export def is_integer(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::WORD or 
        (@tpe).kind == TypeKind::INT_LITERAL or
        (@tpe).kind == TypeKind::BOOL
}

export def is_arithmetic(tpe: *Type) -> bool {
    if not tpe { return false }
    return is_integer(tpe) or 
        (@tpe).kind == TypeKind::FLOAT
}

export def is_float(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::FLOAT
}

// TODO Also allow arrays and strings
export def is_boolean(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::BOOL or
        (@tpe).kind == TypeKind::WORD or
        (@tpe).kind == TypeKind::FLOAT or
        (@tpe).kind == TypeKind::POINTER or
        (@tpe).kind == TypeKind::REFERENCE
}

export def is_pointer(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::POINTER
    // TODO What about references?
}

export def is_struct(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::STRUCT or
        (@tpe).kind == TypeKind::UNION
}

export def pointer(tpe: *Type) -> *Type {
    var t = allocate(Type)
    (@t).kind = TypeKind::POINTER
    (@t).tpe = tpe
    (@t).size = (size_of type *)
    (@t).align = (@t).size
    return t
}

def append_module(name: string, module: string) -> string {
    var buf = buffer::make_buffer()
    buffer::append_str(*buf, module)
    buffer::append_str(*buf, "::")
    buffer::append_str(*buf, name)
    return buffer::to_string(*buf)
}

export def make_type(kind: TypeKind, node: *parser::Node) -> *Type {
    assert((@node).kind == parser::NodeKind::IDENTIFIER)
    let name = parser::identifier_to_str(node)
    var t = allocate(Type)
    (@t).kind = kind
    (@t).type_name = append_module(name, (@node).loc.module)
    (@t).name = name

    return t
}

var counter = 0

def make_unique_name -> string {
    let s = util::int_to_str(counter)
    counter += 1
    return s
}

export def make_anonymous_type(kind: TypeKind, module: string) -> *Type {
    let name = make_unique_name()
    var t = allocate(Type)
    (@t).kind = kind
    (@t).type_name = append_module(name, module)
    (@t).name = name

    return t
}

export def copy(a: *Type) -> *Type {
    var t = allocate(Type)
    @t = @a
    return t
}

export def equals(a: *Type, b: *Type) -> bool {
    if not a or not b { return false }
    
    if a == b {
        return true
    }
    if (@a).kind != (@b).kind { return false }

    let kind = (@a).kind
    if kind == TypeKind::BOOL { return true }
    if kind == TypeKind::WORD or kind == TypeKind::FLOAT {
        return (@a).size == (@b).size
    }
    if kind == TypeKind::INT_LITERAL {
        return (@a).i == (@b).i and (@a).sign == (@b).sign
    }
    if kind == TypeKind::ENUM or
        kind == TypeKind::STRUCT or
        kind == TypeKind::UNION {

        return (@a).type_name == (@b).type_name        
    }
    if kind == TypeKind::ARRAY or
        kind == TypeKind::POINTER or
        kind == TypeKind::REFERENCE {
        
        return equals((@a).tpe, (@b).tpe)
    }
    if kind == TypeKind::STATIC_ARRAY {
        return (@a).length == (@b).length and equals((@a).tpe, (@b).tpe)
    }
    if kind == TypeKind::FUNCTION {
        if vector::length((@a).parameter_t) != vector::length((@b).parameter_t) or
            vector::length((@a).return_t) != vector::length((@b).return_t) {
            return false        
        }
        for var i in 0..vector::length((@a).parameter_t) {
            if not equals(vector::get((@a).parameter_t, i), vector::get((@b).parameter_t, i)) {
                return false
            }
        }
        for var i in 0..vector::length((@a).return_t) {
            if not equals(vector::get((@a).return_t, i), vector::get((@b).return_t, i)) {
                return false
            }
        }
        return true
    }

    assert(false)
}

// Returns true if b is assignable to a
def is_assignable(a: *Type, b: *Type) -> bool {
    if equals(a, b) { return true }
    if (@a).kind == TypeKind::WORD {
        if (@b).kind == TypeKind::WORD {
            return (@a).size >= (@b).size
        }
        if (@b).kind == TypeKind::INT_LITERAL {
            if (@a).unsig {
                var i: uint64 = (@b).i * (@b).sign
                switch (@a).size {
                    case 1: return i <= util::MAX_UINT8
                    case 2: return i <= util::MAX_UINT16
                    case 4: return i <= util::MAX_UINT32
                    case 8: return true
                    case: assert(false)
                }
            } else {
                if (@b).i > util::MAX_INT64 { return false }
                var i: int64 = (@b).i * (@b).sign
                switch (@a).size {
                    case 1: return i >= util::MIN_INT8  and i <= util::MAX_INT8
                    case 2: return i >= util::MIN_INT16 and i <= util::MAX_INT16
                    case 4: return i >= util::MIN_INT32 and i <= util::MAX_INT32
                    case 8: return true
                    case: assert(false)
                }
            }
        }
    }
    if (@a).kind == TypeKind::FLOAT {
        if (@b).kind == TypeKind::WORD or
            (@b).kind == TypeKind::FLOAT {
            return true
        }
    }
    if (@a).kind == TypeKind::ARRAY {
        if (@b).kind == TypeKind::STATIC_ARRAY {
            return equals((@a).tpe, (@b).tpe)
        }
    }
    if (@a).kind == TypeKind::POINTER and (@a).tpe == null {
        return (@b).kind == TypeKind::POINTER
    }
    if (@a).kind == TypeKind::REFERENCE and (@a).tpe == null {
        return (@b).kind == TypeKind::REFERENCE
    }
    return false
}

// Tries to convert type b to type a
// The return value is -1 if b can't be converted to a
// if the types are equal, 0 is returned.
// Otherwise a positive integer is returned.
def convert_type_score(a: *Type, b: *Type) -> int {
    if equals(a, b) {
        return 0
    }
    if ((@a).kind == TypeKind::WORD or (@a).kind == TypeKind::FLOAT) and 
        (@b).kind == TypeKind::INT_LITERAL {
        if is_assignable(a, b) { return 0 }
        else { return -1 }
    }
    if (@a).kind == TypeKind::WORD and (@b).kind == TypeKind::WORD and
        (@a).size >= (@b).size {
        
        // TODO if we are ever going to allow a 24 bit value this is going to fail
        return log2((@a).size) !int - log2((@b).size) !int
    }
    if (@a).kind == TypeKind::FLOAT and (@b).kind == TypeKind::FLOAT {
        // TODO This works because there are only two float sizes
        return 1
    }
    if (@a).kind == TypeKind::FLOAT and
        (@b).kind == TypeKind::WORD {
        
        return 10
    }
    if ((@a).kind == TypeKind::POINTER and (@b).kind == TypeKind::POINTER or
        (@a).kind == TypeKind::REFERENCE and (@b).kind == TypeKind::REFERENCE) and
        (@a).tpe == null {
        
        return 1
    }
    if (@a).kind == TypeKind::ARRAY and (@b).kind == TypeKind::STATIC_ARRAY and 
        equals((@a).tpe, (@b).tpe) {
        
        return 1
    }
    return -1
}

// Calculates a score for overload resultion, the result is 0 for an exact match
// and a positive integer if the argument types need to be converted.
// -1 is returned if the argument types don't match.
export def overload_score(a: *Type, param_b: *vector::Vector) -> int {
    assert(is_function(a))

    let param_a = (@a).parameter_t
    // TODO varargs and default arguments
    if vector::length(param_a) != vector::length(param_b) {
        return -1
    }

    var sum = 0
    for var i in 0..vector::length(param_b) {
        let right = vector::get(param_b, i) !*NamedParameter
        var left: *NamedParameter
        if length((@right).name) > 0 {
            for var i in 0..vector::length(param_a) {
                let param = vector::get(param_a, i) !*NamedParameter
                if (@right).name == (@param).name {
                    left = param
                    break
                }
            }
            if not left { return -1 }
        } else {
            left = vector::get(param_a, i) !*NamedParameter
        }
        let score = convert_type_score((@left).value, (@right).value)
        if score < 0 { return -1 }
        sum += score
    }

    return sum
}

export def type_to_str(tpe: *Type) -> string {
    var buf = buffer::make_buffer()

    switch ((@tpe).kind !int) {
        case TypeKind::WORD: 
            if (@tpe).unsig {
                buffer::append_char(*buf, 'u')
            }
            buffer::append_char(*buf, 'i')
            buffer::append_str(*buf, util::int_to_str((@tpe).size * 8))
        case TypeKind::FLOAT:
            buffer::append_char(*buf, 'f')
            buffer::append_str(*buf, util::int_to_str((@tpe).size * 8))
        case TypeKind::BOOL:
            buffer::append_char(*buf, 'b')
        case TypeKind::STRUCT:
            buffer::append_char(*buf, 'S')
            buffer::append_str(*buf, util::int_to_str(length((@tpe).type_name)))
            buffer::append_str(*buf, (@tpe).type_name)
        case TypeKind::UNION:
            buffer::append_char(*buf, 'U')
            buffer::append_str(*buf, util::int_to_str(length((@tpe).type_name)))
            buffer::append_str(*buf, (@tpe).type_name)
        case TypeKind::ENUM:
            buffer::append_char(*buf, 'E')
            buffer::append_str(*buf, util::int_to_str(length((@tpe).type_name)))
            buffer::append_str(*buf, (@tpe).type_name)
        case TypeKind::FUNCTION:
            buffer::append_char(*buf, 'F')
            for var i in 0..vector::length((@tpe).parameter_t) {
                buffer::append_str(*buf, type_to_str(vector::get((@tpe).parameter_t, i) !*Type))
            }
            buffer::append_char(*buf, '_')
            for var i in 0..vector::length((@tpe).return_t) {
                buffer::append_str(*buf, type_to_str(vector::get((@tpe).return_t, i) !*Type))
            }
            buffer::append_char(*buf, '$')
        case TypeKind::POINTER:
            buffer::append_char(*buf, 'P')
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
        case TypeKind::REFERENCE:
            buffer::append_char(*buf, 'R')
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
        case TypeKind::STATIC_ARRAY:
            buffer::append_char(*buf, 'a')
            buffer::append_str(*buf, util::int_to_str((@tpe).length))
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
        case TypeKind::ARRAY:
            buffer::append_char(*buf, 'A')
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
        case: assert(false)
    }

    return buffer::to_string(*buf)
}

export def mangle_function_name(name: string, parameter_t: *vector::Vector) -> string {
    var buf = buffer::make_buffer()
    buffer::append_str(*buf, "_F")
    buffer::append_str(*buf, util::int_to_str(length(name)))
    buffer::append_str(*buf, name)
    buffer::append_str(*buf, "__")

    for var i in 0..vector::length(parameter_t) {
        buffer::append_str(*buf, type_to_str((@(vector::get(parameter_t, i) !*NamedParameter)).value))
    }

    return buffer::to_string(*buf)
}

// TODO Move this into parser
export def last_ident_to_str(node: *parser::Node) -> string {
    assert((@node).kind == parser::NodeKind::IDENTIFIER)
    if vector::length((@node).value.body) > 1 {
        errorn(node, "Expected plain identifier without path\n")
    }
    return @(vector::get((@node).value.body, 0) !*string)
}

import scope
import builtins
import debug

export def typecheck(node: *parser::Node, scope: *scope::Scope, filename: string, module: string) 

import toolchain

def check_is_identifier_assignable(ident: *parser::Node, state: *State) -> bool {
    if (@ident).kind == parser::NodeKind::IDENTIFIER {
        let value = scope::get((@state).scope, ident)
        if value {
            if (@value).modifier != parser::VarDecl::VAR {
                errorn(ident, "Assignment to non var\n")
                return false
            }
        } else {
            errorn(ident, "Unknown variable \"")
            error(parser::identifier_to_str(ident), "\n")
            return false
        }
    }
    return true
}

def unbox_int_literal(tpe: *Type) -> *Type {
    if tpe and (@tpe).kind == TypeKind::INT_LITERAL {
        // TODO What about bigger literals
        return builtins::int_
    }
    return tpe
}

def type_lookup(node: *parser::Node, state: *State) -> *Type {
    if not node { return null }
    if (@node).kind == parser::NodeKind::IDENTIFIER {
        return scope::get_type((@state).scope, node)
    } else if (@node).kind == parser::NodeKind::PTR_T {
        let tpe = type_lookup((@node).value.t_parr.tpe, state)
        return pointer(tpe)
    } else if (@node).kind == parser::NodeKind::STRUCT_T {
        let tpe = make_anonymous_type(TypeKind::STRUCT, (@node).loc.module)
        (@tpe).packed = false
        
        let length = vector::length((@node).value.body)
        if length == 0 {
            errorn(node, "Empty struct not allowed\n")
            return null
        }

        let fields = allocate(StructMember, length)

        var offset = 0
        var align = 1
        for var i in 0..length {
            let field = vector::get((@node).value.body, i) !*parser::Node
            // TODO Allow anonymous structs
            assert((@field).kind == parser::NodeKind::ID_DECL_STRUCT)
            
            let name = last_ident_to_str((@field).value.id_decl_struct.ident)
            let tpe = type_lookup((@field).value.id_decl_struct.tpe, state)
            if not tpe { continue }
            
            offset = (ceil(offset / (@tpe).align !double) * (@tpe).align) !int
            align = util::lcm(align, (@tpe).align)

            fields[i] = { name, tpe, offset } !StructMember
            offset += (@tpe).size
        }
        offset = (ceil(offset / align !double) * align) !int

        (@tpe).size = offset
        (@tpe).align = align
        (@tpe).fields = fields

        return tpe
    } else if (@node).kind == parser::NodeKind::UNION_T {
        let tpe = make_anonymous_type(TypeKind::UNION, (@node).loc.module)

        let length = vector::length((@node).value.body)
        if length == 0 {
            errorn(node, "Empty union not allowed\n")
            return null
        }

        let fields = allocate(StructMember, length)

        var size = 0
        var align = 1
        for var i in 0..length {
            let field = vector::get((@node).value.body, i) !*parser::Node
            // TODO Allow anonymous structs
            assert((@field).kind == parser::NodeKind::ID_DECL_STRUCT)

            var name = last_ident_to_str((@field).value.id_decl_struct.ident)
            var tpe = type_lookup((@field).value.id_decl_struct.tpe, state)

            fields[i] = { name, tpe, 0 } !StructMember

            size = max((@tpe).size, size) !int
            align = max((@tpe).align, align) !int
        }

        (@tpe).size = size
        (@tpe).align = align
        (@tpe).fields = fields

        return tpe
    } else if (@node).kind == parser::NodeKind::ARRAY_T {
        let array_tpe = type_lookup((@node).value.t_parr.tpe, state)
        let tpe = allocate(Type)
        (@tpe).kind = TypeKind::ARRAY
        (@tpe).tpe = array_tpe
        (@tpe).size = size_of string
        (@tpe).align = size_of type *

        return tpe
    } else if (@node).kind == parser::NodeKind::ARRAY_STATIC_T {
        let array_tpe = type_lookup((@node).value.t_arrs.tpe, state)
        let tpe = allocate(Type)
        (@tpe).kind = TypeKind::STATIC_ARRAY
        (@tpe).tpe = array_tpe
        (@tpe).length = (@(@node).value.t_arrs.n).value.i
        (@tpe).size = (@tpe).length * (@array_tpe).size
        (@tpe).align = (@array_tpe).align

        return tpe
    }

    return null
}

// Returns the common type of two arithmetic types
// byte -> ubyte -> short -> ushort -> int -> uint -> long -> ulong
export def common_type(a: *Type, b: *Type) -> *Type {
    if not a or not b { return null }

    assert(is_arithmetic(a) and is_arithmetic(b))

    a = unbox_int_literal(a)
    b = unbox_int_literal(b)

    if (@a).kind == TypeKind::FLOAT and (@b).kind == TypeKind::WORD {
        return a
    }
    if (@a).kind == (@b).kind {
        if (@a).size == (@b).size {
            if (@b).unsig {
                return b
            } else {
                return a
            }
        } else if (@a).size > (@b).size {
            return a 
        } else {
            return b
        }
    }
}

def walk(node: *parser::Node, state: *State)

let int_literal = make_type(TypeKind::INT_LITERAL, parser::make_identifier(["int_literal"]))
(@int_literal).unsig = false
(@int_literal).size = size_of int
(@int_literal).align = (@int_literal).size

def walk_Null(node: *parser::Node, state: *State) {
    // TODO Null doesn't really have a type
    let tpe = allocate(Type)
    (@tpe).kind = TypeKind::POINTER
    (@tpe).tpe = null
    
    (@node).tpe = tpe
}

def walk_Integer(node: *parser::Node, state: *State) {
    var tpe = copy(int_literal)
    (@tpe).i = (@node).value.i
    (@tpe).sign = 1
    (@node).tpe = tpe
}

def walk_Boolean(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::bool_
}

def walk_Float(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::double_
}

def walk_String(node: *parser::Node, state: *State) {
    var tpe = allocate(Type)
    (@tpe).kind = TypeKind::STATIC_ARRAY
    (@tpe).tpe = builtins::char_
    (@tpe).length = (@node).value.str.size
    // Allocated size of the array
    (@tpe).size = (@tpe).length
    (@node).tpe = tpe
}

def walk_Char(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::char_
}

def walk_Identifier(node: *parser::Node, state: *State) {
    let value = scope::get((@state).scope, node)
    if not value {
        errorn(node, "Unknown identifier ")
        error(parser::identifier_to_str(node), "\n")
    } else {
        (@node).tpe = (@value).tpe
    }
}

def collapse_types(right: *vector::Vector, types: *vector::Vector, nodes: *vector::Vector, state: *State) { 
    for var i in 0..vector::length(right) {
        let value = vector::get(right, i) !*parser::Node
        walk(value, state)
        let tpe = (@value).tpe
        if tpe and (@tpe).kind == TypeKind::FUNCTION {
            for var j in 0..vector::length((@tpe).return_t) {
                let t = vector::get((@tpe).return_t, j) !*Type
                vector::push(types, t)
                vector::push(nodes, value)
            }
        } else {
            vector::push(types, tpe)
            vector::push(nodes, value)
        }
    }
}

def walk_Assign(node: *parser::Node, state: *State) {
    let left = (@node).value.assign.left
    let right = (@node).value.assign.right

    let types = vector::make()
    let nodes = vector::make()
    collapse_types(right, types, nodes, state)

    if vector::length(types) != vector::length(left) {
        errorn(node, "Unbalanced assignment\n")
        return
    }

    for var i in 0..vector::length(left) {
        let node = vector::get(left, i) !*parser::Node
        walk(node, state)
        if not check_is_identifier_assignable(node, state) {
            continue
        }
        var tpe = vector::get(types, i) !*Type
        let n = vector::get(nodes, i) !*parser::Node

        if (@n).kind == parser::NodeKind::NULL and is_pointer((@node).tpe) or
            (@n).kind == parser::NodeKind::STRUCT_LIT and is_struct((@node).tpe) {
            (@n).tpe = (@node).tpe
            tpe = (@node).tpe
        }

        if not tpe or not (@node).tpe { continue }

        if not is_assignable((@node).tpe, tpe) {
            errorn(node, "Incompatible types ")
            error(debug::type_to_str((@node).tpe), " and ", debug::type_to_str(tpe), "\n")
        }
    }
    (@node).tpe = vector::head(types) !*Type
}

def walk_VarDecl(node: *parser::Node, state: *State) {
    let share = (@node).value.var_decl.share
    let kw = (@node).value.var_decl.kw
    let left = (@node).value.var_decl.left
    let right = (@node).value.var_decl.right

    if current_function(state) {
        if share != parser::ShareMarker::NONE {
            errorn(node, "Can't share non top level variable\n")
        }
    }

    let types = vector::make()
    let nodes = vector::make()
    collapse_types(right, types, nodes, state)

    if (kw == parser::VarDecl::CONST or 
        kw == parser::VarDecl::LET) and 
        vector::length(types) != vector::length(left) {
        
        errorn(node, "Unbalanced assignment\n")
        return
    }

    if vector::length(types) > vector::length(left) {
        errorn(node, "Too many values to assign\n")
        return
    }

    for var i in 0..vector::length(left) {
        let node = vector::get(left, i) !*parser::Node
        if (@node).kind == parser::NodeKind::ID_DECL {
            var tpe_node = (@node).value.id_decl.tpe
            var tpe: *Type = null
            if tpe_node {
                tpe = type_lookup(tpe_node, state)

                if i < vector::length(types) {
                    var rhstpe = vector::get(types, i) !*Type
                    let n = vector::get(nodes, i) !*parser::Node

                    if (@n).kind == parser::NodeKind::NULL and is_pointer(tpe) or
                        (@n).kind == parser::NodeKind::STRUCT_LIT and is_struct(tpe) {
                        (@n).tpe = tpe
                        rhstpe = tpe
                    }

                    if not tpe or not rhstpe { continue }

                    if not is_assignable(tpe, rhstpe) {
                        errorn(node, "Incompatible types ")
                        error(debug::type_to_str(tpe), " and ", debug::type_to_str(rhstpe), "\n")
                    }
                } 
            } else {
                if i < vector::length(types) {
                    tpe = vector::get(types, i) !*Type
                    tpe = unbox_int_literal(tpe)
                } else {
                    errorn(node, "Need to specify a type\n")
                    continue
                }
            }

            let ident = (@node).value.id_decl.value

            assert((@ident).kind == parser::NodeKind::IDENTIFIER)

            (@ident).scope = (@state).scope
            (@ident).tpe = tpe
            // TODO Implement constants (set a value)
            scope::create_variable((@state).scope, ident, share, kw, tpe, null)

        } else if (@node).kind == parser::NodeKind::ID_ASSIGN {
            let n = (@node).value.expr
            walk(n, state)
            
            if not check_is_identifier_assignable(n, state) {
                continue
            }

            let tpe = (@(@node).value.expr).tpe

            if not tpe { continue }
            // TODO tpe might be null, check if you can actually assign to the expression
            // Write a seperate function to check, also see walk_Assign

            if i >= vector::length(types) {
                errorn(node, "Must assign a value\n")
                continue
            }

            var rhstpe = vector::get(types, i) !*Type
            let n2 = vector::get(nodes, i) !*parser::Node

            if (@n2).kind == parser::NodeKind::NULL and is_pointer(tpe) or
                (@n2).kind == parser::NodeKind::STRUCT_LIT and is_struct(tpe) {
                (@n2).tpe = tpe
                rhstpe = tpe
            }

            if not tpe or not rhstpe { continue }

            if not is_assignable(tpe, rhstpe) {
                errorn(node, "Incompatible types ")
                error(debug::type_to_str(tpe), " and ", debug::type_to_str(rhstpe), "\n")
            }
        } else { assert(false) }
    }
}

def walk_Not(node: *parser::Node, state: *State) {
    walk((@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not is_boolean(tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str(tpe), ", must be boolean type\n")
    }
    (@node).tpe = tpe
}

def walk_BNot(node: *parser::Node, state: *State) {
    walk((@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not is_integer(tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str(tpe), ", must be integer type\n")
    }
    (@node).tpe = tpe
}

def walk_UAdd(node: *parser::Node, state: *State) {
    walk((@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not is_arithmetic(tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str(tpe), ", must be arithmetic type\n")
    }
    (@node).tpe = tpe
}

def walk_USub(node: *parser::Node, state: *State) {
    walk((@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not is_arithmetic(tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str(tpe), ", must be arithmetic type\n")
    }
    /*if (@tpe).unsig {
        errorn(node, "Negation on unsigned type ")
        error(debug::type_to_str(tpe))
    }*/ // TODO Maybe give a warning on this?
    if (@tpe).kind == TypeKind::INT_LITERAL {
        (@tpe).sign = -(@tpe).sign
    }
    (@node).tpe = tpe
}

def walk_ArithmeticOp(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(left, state)
    walk(right, state)

    if not (@left).tpe or not (@right).tpe { return }
    (@node).tpe = common_type((@left).tpe, (@right).tpe)
}

def walk_BitwiseOp(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(left, state)
    walk(right, state)

    if not (@left).tpe or not (@right).tpe { return }
    if not is_integer((@left).tpe) or not is_integer((@right).tpe) {
        errorn(node, "Invalid operands of type ")
        error(debug::type_to_str((@left).tpe), " and ", debug::type_to_str((@right).tpe), " to bitwise operator")
    }

    (@node).tpe = common_type((@left).tpe, (@right).tpe)
}

def walk_BooleanOp(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(left, state)
    walk(right, state)

    if not (@left).tpe or not (@right).tpe { return }
    if not is_boolean((@left).tpe) or not is_boolean((@right).tpe) {
        errorn(node, "Invalid operands of type ")
        error(debug::type_to_str((@left).tpe), " and ", debug::type_to_str((@right).tpe), " to boolean operator")
    }

    (@node).tpe = builtins::bool_
}

def walk_AssignEqArithmetic(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(left, state)
    walk(right, state)
    if not check_is_identifier_assignable(left, state) {
        return
    }

    if not (@left).tpe or not (@right).tpe { return }
    if not is_arithmetic((@right).tpe) {
        errorn(right, "Incompatible type, expected arithmetic type, got ")
        error(debug::type_to_str((@right).tpe), "\n")
    }
    if not is_arithmetic((@left).tpe) {
        errorn(right, "Incompatible type, expected arithmetic type, got ")
        error(debug::type_to_str((@left).tpe), "\n")
    }

    (@node).tpe = (@left).tpe
}

def walk_AssignEqBitwise(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(left, state)
    walk(right, state)
    if not check_is_identifier_assignable(left, state) {
        return
    }

    if not is_integer((@right).tpe) {
        errorn(right, "Incompatible type, expected integer, got ")
        error(debug::type_to_str((@right).tpe), "\n")
    }
    if not is_integer((@left).tpe) {
        errorn(right, "Incompatible type, expected integer type, got ")
        error(debug::type_to_str((@left).tpe), "\n")
    }

    (@node).tpe = (@left).tpe
}

def walk_AssignEqPtr(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(left, state)
    walk(right, state)
    if not check_is_identifier_assignable(left, state) {
        return
    }

    if not is_integer((@right).tpe) {
        errorn(right, "Incompatible type, expected integer, got ")
        error(debug::type_to_str((@right).tpe), "\n")
    }
    if not is_pointer((@left).tpe) {
        errorn(right, "Incompatible type, expected pointer type, got ")
        error(debug::type_to_str((@left).tpe), "\n")
    }

    (@node).tpe = (@left).tpe
}

def walk_Cast(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(right, state)
    (@node).tpe = type_lookup(right, state)
    if (@left).kind == parser::NodeKind::STRUCT_LIT {
        (@left).tpe = (@node).tpe
    }
    walk(left, state)
}

def walk_Import(node: *parser::Node, state: *State) {
    let imports = (@node).value.body
    for var i in 0..vector::length(imports) {
        let imprt = vector::get(imports, i) !*parser::Node
        var name = (@imprt).value.import_module.name
        var alias = (@imprt).value.import_module.name
        if not name {
            alias = name
        }
        let sc = toolchain::compile_module(name)
        if not sc {
            errorn(name, "Module ")
            error(parser::identifier_to_str(name), " could not be found\n")
            return
        }
        let ns = scope::enter_namespace((@state).scope, alias)
        if not ns { return }
        let values = map::keys((@sc).fields)
        for var i in 0..values.size {
            let value = map::get((@sc).fields, values[i]) !*scope::Value
            if (@value).share !int & parser::ShareMarker::EXPORT {
                map::put((@ns).fields, values[i], value)
            }
        }
        if not (@(@state).scope).imports {
            (@(@state).scope).imports = vector::make()
        }
        vector::push((@(@state).scope).imports, ns)
    }
}

def walk_Def(node: *parser::Node, state: *State) {
    let share = (@node).value.def_.share
    let body = (@node).value.def_.body
    let name = (@node).value.def_.name
    let params = (@node).value.def_.params
    let returns = (@node).value.def_.returns
    let outer_scope = (@state).scope

    if current_function(state) {
        if share != parser::ShareMarker::NONE {
            errorn(node, "Can't share non top level function\n")
        }
    }

    var forward_declare = true
    if body {
        forward_declare = false
        (@state).scope = scope::enter_function_scope((@state).scope)
    }

    let parameter_t = vector::make()
    let return_t = vector::make()
    for var i in 0..vector::length(params) {
        let param = vector::get(params, i) !*parser::Node
        assert((@param).kind == parser::NodeKind::PARAMETER)
        let named = allocate(NamedParameter)
        let name = (@param).value.param.name
        let tpe = type_lookup((@param).value.param.tpe, state)
        (@named).name = last_ident_to_str(name)
        (@named).value = tpe

        if body {
            scope::create_variable((@state).scope, name, parser::ShareMarker::NONE, parser::VarDecl::VAR, tpe, null)
        }

        vector::push(parameter_t, named)
    }
    for var i in 0..vector::length(returns) {
        vector::push(return_t, type_lookup(vector::get(returns, i) !*parser::Node, state))
    }
    
    let tpe = make_type(TypeKind::FUNCTION, name)
    // TODO This isn't guaranteed by the C standard
    (@tpe).size = size_of type *
    (@tpe).align = (@tpe).size
    (@tpe).parameter_t = parameter_t
    (@tpe).return_t = return_t
    if current_function(state) {
        // This is so that we don't create overloaded functions
        // inside of a function
        // TODO what about forward declarations?
        scope::create_variable(outer_scope, name, share, parser::VarDecl::CONST, tpe, null)
    } else {
        scope::create_function(outer_scope, name, share, tpe, forward_declare)
    }
    

    if body {
        push_function(state, tpe)
        for var i in 0..vector::length(body) {
            walk(vector::get(body, i) !*parser::Node, state)
        }
        (@node).scope = (@state).scope
        (@state).scope = scope::exit_scope((@state).scope)
        pop_function(state)
    }

    (@node).tpe = tpe
}

def walk_TypeDecl(node: *parser::Node, state: *State) {
    let share = (@node).value.type_decl.share
    let left = (@node).value.type_decl.left
    let right = (@node).value.type_decl.right

    if vector::length(left) < vector::length(right) {
        errorn(node, "Too many values to assign\n")
        return
    }

    for var i in 0..vector::length(left) {
        let name = vector::get(left, i) !*parser::Node
        var value: *parser::Node = null
        if i < vector::length(right) {
            value = vector::get(right, i)
        }
        
        var tpe = make_type(TypeKind::STUB, name)
        if not scope::create_type((@state).scope, name, share, tpe) {
            continue
        }
        
        if value {
            tpe = copy(type_lookup(value, state))
            (@tpe).name = parser::identifier_to_str(name)
            if (@value).kind == parser::NodeKind::STRUCT_T or
                (@value).kind == parser::NodeKind::UNION_T {
                // Name anonymous struct or union
                (@tpe).type_name = append_module((@tpe).name, (@node).loc.module)
            }
            scope::create_type((@state).scope, name, share, tpe)
        }
        (@name).tpe = tpe
    }
}

def walk_Return(node: *parser::Node, state: *State) {
    let current_fun = current_function(state)
    let body = (@node).value.body
    if not current_fun {
        // TODO This is actually allowed, I just need to infer the types
        // and assign to some sort of internal variable
        errorn(node, "return outside of a function\n")
        return
    }
    
    let types = vector::make()
    let nodes = vector::make()
    collapse_types(body, types, nodes, state)
    let returns = (@current_fun).return_t

    if vector::length(types) != vector::length(returns) {
        // TODO Improve error message
        errorn(node, "Wrong number of arguments to return\n")
    }

    for var i in 0..vector::length(returns) {
        let argtpe = vector::get(returns, i) !*Type
        var rettpe = vector::get(types, i) !*Type
        let n = vector::get(nodes, i) !*parser::Node
        
        if (@n).kind == parser::NodeKind::NULL and is_pointer(argtpe) or
            (@n).kind == parser::NodeKind::STRUCT_LIT and is_struct(argtpe) {
            (@n).tpe = argtpe
            rettpe = argtpe
        }

        if not argtpe or not rettpe { continue }

        if not is_assignable(argtpe, rettpe) {
            // TODO This doesn't point to the actual value
            errorn(node, "Wrong type of return argument, got ")
            error(debug::type_to_str(rettpe), ", expected ", debug::type_to_str(argtpe), "\n")
        }
    }
    (@node).tpe = current_fun
}

def walk_FuncCall(node: *parser::Node, state: *State) {
    var arguments = vector::make()

    for var i in 0..vector::length((@node).value.func_call.args) {
        let n = vector::get((@node).value.func_call.args, i) !*parser::Node
        walk(n, state)
        let np = allocate(NamedParameter)
        (@np).name = ""
        (@np).value = (@n).tpe
        vector::push(arguments, np)
    }
    for var i in 0..vector::length((@node).value.func_call.kwargs) {
        let n = vector::get((@node).value.func_call.kwargs, i) !*parser::Node
        walk((@n).value.named_arg.value, state)
        let np = allocate(NamedParameter)
        (@np).name = last_ident_to_str((@n).value.named_arg.name)
        (@np).value = (@n).tpe
        vector::push(arguments, np)
    }
    // TODO What about function pointers and foo.bar(baz) == bar(foo, baz)
    let left = (@node).value.func_call.left
    let function = scope::get_function((@state).scope, left, arguments)

    if not function {
        errorn(left, "Function \"")
        error(parser::identifier_to_str(left), "\" not found\n")
    } else {
        (@node).tpe = (@function).tpe
    }    
}

def walk_If(node: *parser::Node, state: *State) {
    let cond = (@node).value.if_.cond
    walk(cond, state)
    let tpe = (@cond).tpe
    if not is_boolean(tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str(tpe), ", must be boolean type\n")
    }
    
    (@state).scope = scope::enter_scope((@state).scope)
    for var i in 0..vector::length((@node).value.if_.body) {
        let n = vector::get((@node).value.if_.body, i) !*parser::Node
        walk(n, state)
    }
    (@state).scope = scope::exit_scope((@state).scope)

    for var i in 0..vector::length((@node).value.if_.else_if) {
        let n = vector::get((@node).value.if_.else_if, i) !*parser::Node
        
        let cond = (@n).value.else_if.cond
        walk(cond, state)
        let tpe = (@cond).tpe
        
        if not is_boolean(tpe) {
            errorn(n, "Incompatible type ")
            error(debug::type_to_str(tpe), ", must be boolean type\n")
        }

        (@state).scope = scope::enter_scope((@state).scope)
        for var i in 0..vector::length((@n).value.else_if.body) {
            let n2 = vector::get((@n).value.else_if.body, i)
            walk(n2, state)
        }   
        (@state).scope = scope::exit_scope((@state).scope)
    }

    let else_ = (@node).value.if_.else_
    if else_ {
        (@state).scope = scope::enter_scope((@state).scope)
        for var i in 0..vector::length((@else_).value.body) {
            let n = vector::get((@else_).value.body, i) !*parser::Node
            walk(n, state)
        }
        (@state).scope = scope::exit_scope((@state).scope)
    }
}

def walk_Loop(node: *parser::Node, state: *State) {
    (@state).scope = scope::enter_scope((@state).scope)
    for var i in 0..vector::length((@node).value.body) {
        let n = vector::get((@node).value.body, i)
        walk(n, state)
    }
    (@state).scope = scope::exit_scope((@state).scope)
}

def walk_Deref(node: *parser::Node, state: *State) {
    walk((@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not is_pointer(tpe) {
        errorn(node, "Needs to be a pointer type, got ")
        error(debug::type_to_str(tpe), "\n")
        return
    }
    (@node).tpe = (@tpe).tpe
}

def walk_Ptr(node: *parser::Node, state: *State) {
    walk((@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    (@node).tpe = pointer(tpe)
}

def walk_MemberAccess(node: *parser::Node, state: *State) {
    walk((@node).value.bin_op.left, state)
    let right = (@node).value.bin_op.right
    let tpe = (@(@node).value.bin_op.left).tpe
    if (@tpe).kind == TypeKind::STRUCT or (@tpe).kind == TypeKind::UNION {
        let name = last_ident_to_str(right)

        var rtpe: *Type
        for var i in 0..(@tpe).fields.size {
            let member = (@tpe).fields[i]
            if member.name == name {
                rtpe = member.tpe
                break
            }
        }
        if not rtpe {
            errorn(node, "Unknown field \"")
            error(name, "\"\n")
            return
        }
        (@node).tpe = rtpe
    } else if (@tpe).kind == TypeKind::ENUM {
        // TODO
        assert(false)
    } else {
        // TODO obj.method() -> method(obj)
        errorn(node, "Expected aggregate type, got ")
        error(debug::type_to_str(tpe), "\n")
    }
}

def walk_ArraySubscript(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right

    walk(left, state)
    walk(right, state)

    let tpe = (@left).tpe
    if is_pointer(tpe) or (@tpe).kind == TypeKind::ARRAY or
        (@tpe).kind == TypeKind::STATIC_ARRAY {
        (@node).tpe = (@tpe).tpe
    } else {
        errorn(left, "Expected array or pointer type, got ")
        error(debug::type_to_str(tpe), "\n")
    }
    if not is_arithmetic((@right).tpe) {
        errorn(right, "Expected arithmetic type, got ")
        error(debug::type_to_str((@right).tpe), "\n")
    }
}

def walk_StructLit(node: *parser::Node, state: *State) {
    for var i in 0..vector::length((@node).value.struct_lit.args) {
        let n = vector::get((@node).value.struct_lit.args, i) !*parser::Node
        walk(n, state)
    }
    for var i in 0..vector::length((@node).value.struct_lit.kwargs) {
        let n = vector::get((@node).value.struct_lit.kwargs, i) !*parser::Node
        walk((@n).value.named_arg.value, state)
    }
}

// TODO We might want to allow assignments like
// let array: [double] = [1, 2, 3, 4] // And convert to double here
def walk_ArrayLit(node: *parser::Node, state: *State) {
    var tpe: *Type = null
    let len = vector::length((@node).value.body)
    for var i in 0..len {
        let n = vector::get((@node).value.body, i) !*parser::Node
        walk(n, state)
        let t = unbox_int_literal((@n).tpe)
        if not tpe { tpe = t }
        else {
            if not equals(tpe, t) {
                errorn(n, "Incompatible types, all array elements need to have the same type. Array type ")
                error(debug::type_to_str(tpe), ", got ", debug::type_to_str(t), "\n")
                // It might be confusing to get multiple errors here
                break
            }
        }
    }
    let ret_tpe = allocate(Type)
    (@ret_tpe).kind = TypeKind::STATIC_ARRAY
    (@ret_tpe).length = len
    (@ret_tpe).tpe = tpe

    (@node).tpe = ret_tpe
}

def walk_SizeOf(node: *parser::Node, state: *State) {
    let expr = (@node).value.expr
    // Need to special case here
    if (@expr).kind == parser::NodeKind::IDENTIFIER {
        let value = scope::get((@state).scope, expr)
        if not value {
            errorn(expr, "Unknown identifier \"")
            error(parser::identifier_to_str(expr), "\"\n")
            return
        }
        if (@value).modifier == parser::VarDecl::TYPE {
            (@expr).tpe = (@value).value !*Type
        } else {
            (@expr).tpe = (@value).tpe
        }
    } else {
        (@expr).tpe = type_lookup(expr, state)
        if not (@expr).tpe {
            walk(expr, state)
        }
    }

    (@node).tpe = builtins::size_t_
}

def walk_ComparisionOp(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    walk(left, state)
    walk(right, state)
    // TODO We can compare almost everything
    (@node).tpe = builtins::bool_
}

def walk_PAdd(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    walk(left, state)
    walk(right, state)
    if not is_pointer((@left).tpe) {
        errorn(left, "Must be pointer type, got ")
        error(debug::type_to_str((@left).tpe), "\n")
    }
    if not is_arithmetic((@right).tpe) {
        errorn(left, "Must be arithmetic type, got ")
        error(debug::type_to_str((@right).tpe), "\n")
    }
    // TODO should probably not set this to a garbage value
    (@node).tpe = (@left).tpe
}

def walk_PSub(node: *parser::Node, state: *State) {
    walk_PAdd(node, state)
}

def walk(node: *parser::Node, state: *State) {
    if not node { return }
    (@node).scope = (@state).scope

    switch (@node).kind !int {
        case parser::NodeKind::NULL:
            walk_Null(node, state)
        case parser::NodeKind::INTEGER:
            walk_Integer(node, state)
        case parser::NodeKind::BOOLEAN:
            walk_Boolean(node, state)
        case parser::NodeKind::STRING:
            walk_String(node, state)
        case parser::NodeKind::CHAR:
            walk_Char(node, state)
        case parser::NodeKind::FLOAT:
            walk_Float(node, state)
        case parser::NodeKind::IDENTIFIER:
            walk_Identifier(node, state)
        case parser::NodeKind::SIZE_OF:
            walk_SizeOf(node, state)
        case parser::NodeKind::LOOP:
            walk_Loop(node, state)
        case parser::NodeKind::IF:
            walk_If(node, state)
        case parser::NodeKind::DEF:
            walk_Def(node, state)
        case parser::NodeKind::IMPORT:
            walk_Import(node, state)
        case parser::NodeKind::CAST:
            walk_Cast(node, state)
        case parser::NodeKind::ASSIGN:
            walk_Assign(node, state)
        case parser::NodeKind::VAR_DECL:
            walk_VarDecl(node, state)
        case parser::NodeKind::UADD:
            walk_UAdd(node, state)
        case parser::NodeKind::USUB:
            walk_USub(node, state)
        case parser::NodeKind::BNOT:
            walk_BNot(node, state)
        case parser::NodeKind::NOT:
            walk_Not(node, state)
        case parser::NodeKind::ADD..parser::NodeKind::MOD:
            walk_ArithmeticOp(node, state)
        case parser::NodeKind::BAND..parser::NodeKind::SHR:
            walk_BitwiseOp(node, state)
        case parser::NodeKind::AND..parser::NodeKind::OR:
            walk_BooleanOp(node, state)
        case parser::NodeKind::EQ..parser::NodeKind::LEQ:
            walk_ComparisionOp(node, state)
        case parser::NodeKind::ADD_EQ..parser::NodeKind::MOD_EQ:
            walk_AssignEqArithmetic(node, state)
        case parser::NodeKind::AND_EQ..parser::NodeKind::SHR_EQ:
            walk_AssignEqBitwise(node, state)
        case parser::NodeKind::PADD_EQ..parser::NodeKind::PSUB_EQ:
            walk_AssignEqPtr(node, state)
        case parser::NodeKind::PADD:
            walk_PAdd(node, state)
        case parser::NodeKind::PSUB:
            walk_PSub(node, state)
        case parser::NodeKind::DEREF:
            walk_Deref(node, state)
        case parser::NodeKind::PTR:
            walk_Ptr(node, state)
        case parser::NodeKind::TYPE_DECL:
            walk_TypeDecl(node, state)
        case parser::NodeKind::RETURN:
            walk_Return(node, state)
        case parser::NodeKind::FUNC_CALL:
            walk_FuncCall(node, state)
        case parser::NodeKind::BREAK..parser::NodeKind::CONTINUE:
            // Noop
            null
        case parser::NodeKind::MEMBER_ACCESS:
            walk_MemberAccess(node, state)
        case parser::NodeKind::ARRAY_SUBSCRIPT:
            walk_ArraySubscript(node, state)
        case parser::NodeKind::STRUCT_LIT:
            walk_StructLit(node, state)
        case parser::NodeKind::ARRAY_LIT:
            walk_ArrayLit(node, state)
        case:
            error((@node).kind, "\n")
            assert(false)
    }
}

export def typecheck(node: *parser::Node, scope: *scope::Scope, filename: string, module: string) {
    assert((@node).kind == parser::NodeKind::PROGRAM)

    var state: State
    state.filename = filename
    state.module = module
    state.scope = scope
    state.function_stack = vector::make()

    for var i in 0..vector::length((@node).value.body) {
        walk(vector::get((@node).value.body, i) !*parser::Node, *state)
    }
    (@node).scope = state.scope
}

// TODO Make this function variadic
export def errorn(node: *parser::Node, msg: string) {
    if not node { assert(false) }
    let filename = (@node).loc.filename
    let line = (@node).loc.line
    let column = (@node).loc.column

    error("\n")
    error(filename, "@", line + 1, ":", column + 1, "\n")
    error((@node).loc.lines[line], "\n")
    for var i in 0..column {
        error(" ")
    }
    error("^\n")
    error(msg)

    toolchain::error_count += 1
}