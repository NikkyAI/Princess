import map
import vector
import parser
import buffer
import util

export type TypeKind = enum {
    WORD
    FLOAT
    BOOL
    STRUCT
    UNION
    ENUM
    FUNCTION
    POINTER
    REFERENCE
    STATIC_ARRAY
    ARRAY
    // Used for enums
    NAMESPACE
    // Forward declaration
    STUB
}

export type Type = struct {
    kind: TypeKind
    // Name of the type as used by the source code
    name: string
    // Size in bytes
    size: size_t
    align: size_t
    unsig: bool
    // Static array
    length: size_t
    // Type both used for array/pointer and enum
    tpe: *Type
    // Fields for both struct and enum
    fields: *map::Map
    // Function
    return_t: *vector::Vector
    parameter_t: *vector::Vector
}

export def type_to_str(tpe: *Type) -> string {
    var buf = buffer::make_buffer()

    switch ((@tpe).kind !int) {
        case TypeKind::WORD: 
            if (@tpe).unsig {
                buffer::append_char(*buf, 'u')
            }
            buffer::append_char(*buf, 'i')
            buffer::append_str(*buf, util::int_to_str((@tpe).size))
        case TypeKind::FLOAT:
            buffer::append_char(*buf, 'f')
            buffer::append_str(*buf, util::int_to_str((@tpe).size))
        case TypeKind::BOOL:
            buffer::append_char(*buf, 'b')
        case TypeKind::STRUCT:
            buffer::append_char(*buf, 'S')
            buffer::append_str(*buf, util::int_to_str(length((@tpe).name)))
            buffer::append_str(*buf, (@tpe).name)
        case TypeKind::UNION:
            buffer::append_char(*buf, 'U')
            buffer::append_str(*buf, util::int_to_str(length((@tpe).name)))
            buffer::append_str(*buf, (@tpe).name)
        case TypeKind::ENUM:
            buffer::append_char(*buf, 'E')
            buffer::append_str(*buf, util::int_to_str(length((@tpe).name)))
            buffer::append_str(*buf, (@tpe).name)
        case TypeKind::FUNCTION:
            buffer::append_char(*buf, 'F')
            for var i in 0..vector::length((@tpe).parameter_t) {
                buffer::append_str(*buf, type_to_str(vector::get((@tpe).parameter_t, i) !*Type))
            }
            buffer::append_char(*buf, '_')
            for var i in 0..vector::length((@tpe).return_t) {
                buffer::append_str(*buf, type_to_str(vector::get((@tpe).return_t, i) !*Type))
            }
            buffer::append_char(*buf, '$')
        case TypeKind::POINTER:
            buffer::append_char(*buf, 'P')
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
        case TypeKind::REFERENCE:
            buffer::append_char(*buf, 'R')
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
        case TypeKind::STATIC_ARRAY:
            buffer::append_char(*buf, 'a')
            buffer::append_str(*buf, util::int_to_str((@tpe).length))
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
        case TypeKind::ARRAY:
            buffer::append_char(*buf, 'A')
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
    }

    return buffer::to_string(*buf)
}

export type State = struct {
    filename: string
    node: *parser::Node
}

// TODO Make this function variadic
export def errorn(state: *State, msg: string) {
    let filename = (@state).filename
    let node = (@state).node
    let line = (@node).loc.line
    let column = (@node).loc.column

    error("\n")
    error(filename, "@", line + 1, ":", column + 1, "\n")
    error((@node).loc.lines[line], "\n")
    for var i in 0..column {
        error(" ")
    }
    error("^\n")
    error(msg)
}

import scope