// TODO Many of these function will error twice with misleading errors
// Every function needs to check for possible null types and null nodes
// and abort in those cases

import map
import vector
import parser
import buffer
import util

export type TypeKind = enum {
    TYPE
    WORD
    FLOAT
    BOOL
    STRUCT
    UNION
    ENUM
    FUNCTION
    TUPLE
    POINTER
    REFERENCE
    STATIC_ARRAY
    ARRAY
    RANGE
    RANGE_INC
    // Used for enums
    NAMESPACE
    // Auto cast, this type will convert to anything
    // AUTO_CAST // TODO Actually implement this
    // Forward declaration
    STUB
    // Null
    NULL
}

export type Type
export type State

export type StructMember = struct {
    name: string
    tpe: *Type
    offset: size_t
}

type compiler::State
type compiler::Value
type scope::Scope

export type Type = struct {
    kind: TypeKind
    // Name of the type as used by the source code
    // Might be the name of a typedef
    name: string
    // Unique name of the type
    type_name: string
    // Size in bytes
    size: size_t
    align: size_t
    unsig: bool
    // TODO Add kw (parser::VarDecl) for arrays and pointers
    // Static array
    length: size_t
    // Type both used for array/pointer and enum
    tpe: *Type
    packed: bool
    // Fields for struct, array of StructMember
    fields: [StructMember]
    // Function and Tuple
    return_t: *vector::Vector
    parameter_t: *vector::Vector
    // Macro for builtin functions
    macro: (*parser::Node, [compiler::Value], *compiler::State) -> compiler::Value
    // This calculates the return types for functions 
    // where the return types depend on the argument types
    proto: (*vector::Vector, *vector::Vector, *State) -> (*vector::Vector)
    //          args            kwargs                        return_t
}

export type NamedParameter = struct {
    // Might be empty for positional parameters
    name: string
    value: *Type
    varargs: bool
}

export type State = struct {
    filename: string
    module: string
    scope: *scope::Scope
    function_stack: *vector::Vector
}

export def errorn(node: *parser::Node, msg: string)
export def common_type(a: *Type, b: *Type) -> *Type
export def type_lookup(node: *parser::Node, state: *State) -> *Type
export def evaluate_constant(node: *parser::Node) -> *

def current_function(state: *State) -> *Type {
    let length = vector::length((@state).function_stack)
    if length == 0 {
        return null
    } else {
        return vector::get((@state).function_stack, length - 1) !*Type
    }
}

def push_function(state: *State, tpe: *Type) {
    vector::push((@state).function_stack, tpe)
}

def pop_function(state: *State) -> *Type {
    return vector::pop((@state).function_stack) !*Type
}

export def is_function(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::FUNCTION
}

export def is_function_pointer(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::POINTER and 
        is_function((@tpe).tpe)
}

export def is_integer(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::WORD or 
        (@tpe).kind == TypeKind::BOOL
}

export def is_arithmetic(tpe: *Type) -> bool {
    if not tpe { return false }
    return is_integer(tpe) or 
        (@tpe).kind == TypeKind::FLOAT
}

export def is_float(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::FLOAT
}

// TODO Also allow arrays and strings
export def is_boolean(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::BOOL or
        (@tpe).kind == TypeKind::WORD or
        (@tpe).kind == TypeKind::FLOAT or
        (@tpe).kind == TypeKind::POINTER or
        (@tpe).kind == TypeKind::REFERENCE
}

export def is_pointer(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::POINTER
    // TODO What about references?
}

export def is_struct(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::STRUCT or
        (@tpe).kind == TypeKind::UNION
}

export def is_enum(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::ENUM
}

export def is_type(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::TYPE
}

export def is_array(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::ARRAY or
        (@tpe).kind == TypeKind::STATIC_ARRAY
}

export def is_range(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::RANGE or
        (@tpe).kind == TypeKind::RANGE_INC
}

export def pointer(tpe: *Type) -> *Type {
    var t = allocate(Type)
    (@t).kind = TypeKind::POINTER
    (@t).tpe = tpe
    (@t).size = (size_of type *)
    (@t).align = (align_of type *)
    return t
}

export def array(tpe: *Type) -> *Type {
    var t = allocate(Type)
    (@t).kind = TypeKind::ARRAY
    (@t).tpe = tpe
    (@t).size = (size_of string)
    (@t).align = (align_of string)
}

def append_module(name: string, module: string) -> string {
    var buf = buffer::make_buffer()
    if length(module) > 0 {
        buffer::append_str(*buf, module)
        buffer::append_str(*buf, "::")
    }
    buffer::append_str(*buf, name)
    return buffer::to_string(*buf)
}

export def make_type(kind: TypeKind, node: *parser::Node) -> *Type {
    assert((@node).kind == parser::NodeKind::IDENTIFIER)
    let name = parser::identifier_to_str(node)
    var t = allocate(Type)
    (@t).kind = kind
    (@t).type_name = append_module(name, (@node).loc.module)
    (@t).name = name

    return t
}

export def make_static_array(array_tpe: *Type, size: size_t) -> *Type {
    let tpe = allocate(Type)
    (@tpe).kind = TypeKind::STATIC_ARRAY
    (@tpe).tpe = array_tpe
    (@tpe).length = size
    (@tpe).size = (@tpe).length * (@array_tpe).size
    (@tpe).align = (@array_tpe).align
    return tpe
}

var counter = 0

def make_unique_name -> string {
    let s = util::int_to_str(counter)
    counter += 1
    return s
}

export def make_anonymous_type(kind: TypeKind) -> *Type {
    var t = allocate(Type)
    (@t).kind = kind
    (@t).type_name = ""
    (@t).name = ""

    return t
}

export let type_ = make_anonymous_type(TypeKind::TYPE)

export def copy(a: *Type) -> *Type {
    if not a { return null }
    var t = allocate(Type)
    @t = @a
    return t
}

export def equals(a: *Type, b: *Type) -> bool {
    if a == b {
        return true
    }
    if not a or not b { return false }

    if (@a).kind != (@b).kind { return false }

    let kind = (@a).kind
    if kind == TypeKind::BOOL or kind == TypeKind::TYPE { return true }
    if kind == TypeKind::WORD {
        return (@a).size == (@b).size and (@a).unsig == (@b).unsig
    }
    if kind == TypeKind::FLOAT {
        return (@a).size == (@b).size
    }
    if kind == TypeKind::ENUM or
        kind == TypeKind::STRUCT or
        kind == TypeKind::UNION {

        return (@a).type_name == (@b).type_name        
    }
    if kind == TypeKind::ARRAY or
        kind == TypeKind::POINTER or
        kind == TypeKind::REFERENCE {
        
        return equals((@a).tpe, (@b).tpe)
    }
    if kind == TypeKind::STATIC_ARRAY {
        return (@a).length == (@b).length and equals((@a).tpe, (@b).tpe)
    }
    if kind == TypeKind::FUNCTION {
        if vector::length((@a).parameter_t) != vector::length((@b).parameter_t) or
            vector::length((@a).return_t) != vector::length((@b).return_t) {
            return false        
        }
        for var i in 0..vector::length((@a).parameter_t) {
            let param_a = vector::get((@a).parameter_t, i) !*NamedParameter
            let param_b = vector::get((@b).parameter_t, i) !*NamedParameter
            if not equals((@param_a).value, (@param_b).value) {
                return false
            }
        }
        for var i in 0..vector::length((@a).return_t) {
            if not equals(vector::get((@a).return_t, i) !*Type, vector::get((@b).return_t, i) !*Type) {
                return false
            }
        }
        return true
    }

    assert(false)
}

// Returns true if b is assignable to a
def is_assignable(a: *Type, b: *Type) -> bool {
    if equals(a, b) { return true }
    if (@a).kind == TypeKind::WORD {
        if (@b).kind == TypeKind::WORD {
            return (@a).size >= (@b).size
        }
        // TODO Move this to implicit conversion
        /*if (@b).kind == TypeKind::INT_LITERAL {
            if (@a).unsig {
                var i: uint64 = (@b).i * (@b).sign
                switch (@a).size {
                    case 1: return i <= util::MAX_UINT8
                    case 2: return i <= util::MAX_UINT16
                    case 4: return i <= util::MAX_UINT32
                    case 8: return true
                    case: assert(false)
                }
            } else {
                if (@b).i > util::MAX_INT64 { return false }
                var i: int64 = (@b).i * (@b).sign
                switch (@a).size {
                    case 1: return i >= util::MIN_INT8  and i <= util::MAX_INT8
                    case 2: return i >= util::MIN_INT16 and i <= util::MAX_INT16
                    case 4: return i >= util::MIN_INT32 and i <= util::MAX_INT32
                    case 8: return true
                    case: assert(false)
                }
            }
        }*/
    }
    if (@a).kind == TypeKind::FLOAT {
        if (@b).kind == TypeKind::WORD or
            (@b).kind == TypeKind::FLOAT {
            return true
        }
    }
    if (@a).kind == TypeKind::ARRAY {
        if (@b).kind == TypeKind::STATIC_ARRAY {
            return equals((@a).tpe, (@b).tpe)
        }
    }
    if ((@a).kind == TypeKind::POINTER or (@a).kind == TypeKind::REFERENCE) and
        (@b).kind == TypeKind::NULL {
        return true
    }
    if (@a).kind == TypeKind::POINTER and (@a).tpe == null {
        return (@b).kind == TypeKind::POINTER
    }
    if (@a).kind == TypeKind::REFERENCE and (@a).tpe == null {
        return (@b).kind == TypeKind::REFERENCE
    }
    return false
}

// Tries to convert type b to type a
// The return value is -1 if b can't be converted to a
// if the types are equal, 0 is returned.
// Otherwise a positive integer is returned.
def convert_type_score(a: *Type, b: *Type) -> int {
    if not a or not b { return 0 }
    if equals(a, b) {
        return 0
    }
    if ((@a).kind == TypeKind::POINTER or (@a).kind == TypeKind::REFERENCE) and (@b).kind == TypeKind::NULL {
        return 0
    }
    if (@a).kind == TypeKind::WORD and (@b).kind == TypeKind::WORD and
        (@a).size >= (@b).size {
        
        // TODO if we are ever going to allow a 24 bit value this is going to fail
        return log2((@a).size) !int - log2((@b).size) !int
    }
    if (@a).kind == TypeKind::FLOAT and (@b).kind == TypeKind::FLOAT {
        // TODO This works because there are only two float sizes
        return 1
    }
    if (@a).kind == TypeKind::FLOAT and
        (@b).kind == TypeKind::WORD {
        
        return 10
    }
    if ((@a).kind == TypeKind::POINTER and (@b).kind == TypeKind::POINTER or
        (@a).kind == TypeKind::REFERENCE and (@b).kind == TypeKind::REFERENCE) and
        (@a).tpe == null {
        
        return 1
    }
    if (@a).kind == TypeKind::ARRAY {
        if (@b).kind == TypeKind::STATIC_ARRAY and equals((@a).tpe, (@b).tpe) {
            return 1
        }
        if (@a).tpe == null and ((@b).kind == TypeKind::ARRAY or (@b).kind == TypeKind::STATIC_ARRAY) {
            return 1
        }
    }
    return -1
}

// Calculates a score for overload resultion, the result is 0 for an exact match
// and a positive integer if the argument types need to be converted.
// -1 is returned if the argument types don't match.
export def overload_score(a: *Type, param_b: *vector::Vector, positional: bool) -> int {
    assert(is_function(a))

    let param_a = (@a).parameter_t
    // TODO default arguments
    if vector::length(param_a) > vector::length(param_b) {
        if vector::length(param_a) == vector::length(param_b) + 1 {
            if not (@(vector::peek(param_a) !*NamedParameter)).varargs {
                return -1
            }
        } else {
            return -1
        }
    }

    var sum = 0
    for var i in 0..vector::length(param_b) {
        let right = vector::get(param_b, i) !*NamedParameter
        var left: *NamedParameter = null
        if length((@right).name) > 0 and not positional {
            for var i in 0..vector::length(param_a) {
                let param = vector::get(param_a, i) !*NamedParameter
                if (@right).name == (@param).name {
                    left = param
                    break
                }
            }
            if not left { return -1 }
        } else {
            if i < vector::length(param_a) {
                left = vector::get(param_a, i) !*NamedParameter
            } else if vector::length(param_a) > 0 {
                left = vector::peek(param_a) !*NamedParameter
                if not (@left).varargs {
                    return -1
                } 
            } else {
                return -1
            }
        }
        let score = convert_type_score((@left).value, (@right).value)
        if score < 0 { return -1 }
        sum += score
    }

    return sum
}

export def type_to_str(tpe: *Type) -> string {
    if not tpe { return "(null)" }

    var buf = buffer::make_buffer()
    
    switch ((@tpe).kind !int) {
        case TypeKind::WORD: 
            if (@tpe).unsig {
                buffer::append_char(*buf, 'u')
            }
            buffer::append_char(*buf, 'i')
            buffer::append_str(*buf, util::int_to_str((@tpe).size * 8))
        case TypeKind::FLOAT:
            buffer::append_char(*buf, 'f')
            buffer::append_str(*buf, util::int_to_str((@tpe).size * 8))
        case TypeKind::BOOL:
            buffer::append_char(*buf, 'b')
        case TypeKind::STRUCT:
            buffer::append_char(*buf, 'S')
            buffer::append_str(*buf, util::int_to_str(length((@tpe).type_name)))
            buffer::append_str(*buf, (@tpe).type_name)
        case TypeKind::UNION:
            buffer::append_char(*buf, 'U')
            buffer::append_str(*buf, util::int_to_str(length((@tpe).type_name)))
            buffer::append_str(*buf, (@tpe).type_name)
        case TypeKind::ENUM:
            buffer::append_char(*buf, 'E')
            buffer::append_str(*buf, util::int_to_str(length((@tpe).type_name)))
            buffer::append_str(*buf, (@tpe).type_name)
        case TypeKind::FUNCTION:
            buffer::append_char(*buf, 'F')
            for var i in 0..vector::length((@tpe).parameter_t) {
                let parameter = vector::get((@tpe).parameter_t, i) !*NamedParameter
                buffer::append_str(*buf, type_to_str((@parameter).value))
            }
            buffer::append_char(*buf, '_')
            for var i in 0..vector::length((@tpe).return_t) {
                buffer::append_str(*buf, type_to_str(vector::get((@tpe).return_t, i) !*Type))
            }
            buffer::append_char(*buf, '$')
        case TypeKind::POINTER:
            buffer::append_char(*buf, 'P')
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
        case TypeKind::REFERENCE:
            buffer::append_char(*buf, 'R')
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
        case TypeKind::STATIC_ARRAY:
            buffer::append_char(*buf, 'a')
            buffer::append_str(*buf, util::int_to_str((@tpe).length))
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
        case TypeKind::ARRAY:
            buffer::append_char(*buf, 'A')
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
        case: 
            error((@tpe).kind, "\n")
            assert(false)
    }

    return buffer::to_string(*buf)
}

export def mangle_function_name(name: string, parameter_t: *vector::Vector) -> string {
    var buf = buffer::make_buffer()
    buffer::append_str(*buf, "_F")
    buffer::append_str(*buf, util::int_to_str(length(name)))
    buffer::append_str(*buf, name)
    buffer::append_str(*buf, "__")

    for var i in 0..vector::length(parameter_t) {
        buffer::append_str(*buf, type_to_str((@(vector::get(parameter_t, i) !*NamedParameter)).value))
    }

    return buffer::to_string(*buf)
}

// TODO Move this into parser
export def last_ident_to_str(node: *parser::Node) -> string {
    if not node { return "" }
    assert((@node).kind == parser::NodeKind::IDENTIFIER)
    if vector::length((@node).value.body) > 1 {
        errorn(node, "Expected plain identifier without path\n")
    }
    return @(vector::get((@node).value.body, 0) !*string)
}

import scope
import builtins
import debug

type toolchain::Module

export def typecheck(module: *toolchain::Module) 

import toolchain

def check_is_identifier_assignable(ident: *parser::Node, state: *State) -> bool {
    if (@ident).kind == parser::NodeKind::IDENTIFIER {
        let value = scope::get((@state).scope, ident)
        if value {
            if (@value).modifier != parser::VarDecl::VAR {
                errorn(ident, "Assignment to non var\n")
                return false
            }
        } else {
            errorn(ident, "Unknown variable \"")
            error(parser::identifier_to_str(ident), "\n")
            return false
        }
    }
    return true
}

//TODO Move this into its own file, along with a more sophisticated execution engine...
export def evaluate_constant(node: *parser::Node) -> * {
    if (@node).kind == parser::NodeKind::INTEGER or (@node).kind == parser::NodeKind::CHAR {
        let i = allocate(uint64)
        @i = (@node).value.i
        return i
    } else if (@node).kind == parser::NodeKind::IDENTIFIER {
        let value = scope::get_const_value((@node).scope, node)
        return (@value).value
    }
    error((@node).kind, "\n")
    assert(false)
}

export def type_lookup(node: *parser::Node, state: *State) -> *Type {
    if not node { return null }
    if (@node).kind == parser::NodeKind::IDENTIFIER {
        return scope::get_type((@state).scope, node)
    } else if (@node).kind == parser::NodeKind::PTR_T {
        let tpe = type_lookup((@node).value.t_parr.tpe, state)
        return pointer(tpe)
    } else if (@node).kind == parser::NodeKind::STRUCT_T {
        let tpe = make_anonymous_type(TypeKind::STRUCT)
        (@tpe).packed = false
        
        let length = vector::length((@node).value.body)
        if length == 0 {
            errorn(node, "Empty struct not allowed\n")
            return null
        }

        let fields = allocate(StructMember, length)

        var offset = 0
        var align = 1
        for var i in 0..length {
            let field = vector::get((@node).value.body, i) !*parser::Node
            // TODO Allow anonymous structs
            assert((@field).kind == parser::NodeKind::ID_DECL_STRUCT)
            
            let name = last_ident_to_str((@field).value.id_decl_struct.ident)
            let tpe = type_lookup((@field).value.id_decl_struct.tpe, state)
            if not tpe {
                fields[i] = { "", null, 0 } !StructMember
                continue 
            }
            
            offset = (ceil(offset / (@tpe).align !double) * (@tpe).align) !int
            align = util::lcm(align, (@tpe).align !int)

            fields[i] = { name, tpe, offset } !StructMember
            offset += (@tpe).size
        }
        offset = (ceil(offset / align !double) * align) !int

        (@tpe).size = offset
        (@tpe).align = align
        (@tpe).fields = fields

        return tpe
    } else if (@node).kind == parser::NodeKind::UNION_T {
        let tpe = make_anonymous_type(TypeKind::UNION)

        let length = vector::length((@node).value.body)
        if length == 0 {
            errorn(node, "Empty union not allowed\n")
            return null
        }

        let fields = allocate(StructMember, length)

        var size = 0
        var align = 1
        for var i in 0..length {
            let field = vector::get((@node).value.body, i) !*parser::Node
            // TODO Allow anonymous structs
            assert((@field).kind == parser::NodeKind::ID_DECL_STRUCT)

            var name = last_ident_to_str((@field).value.id_decl_struct.ident)
            var tpe = type_lookup((@field).value.id_decl_struct.tpe, state)

            fields[i] = { name, tpe, 0 } !StructMember

            size = max((@tpe).size, size) !int
            align = max((@tpe).align, align) !int
        }

        (@tpe).size = size
        (@tpe).align = align
        (@tpe).fields = fields

        return tpe
    } else if (@node).kind == parser::NodeKind::ENUM_T {
        var enum_tpe = builtins::int_
        if (@node).value.t_enum.tpe {
            enum_tpe = type_lookup((@node).value.t_enum.tpe, state)
        }
        let tpe = make_anonymous_type(TypeKind::ENUM)
        (@tpe).tpe = enum_tpe
        (@tpe).size = (@enum_tpe).size
        (@tpe).align = (@enum_tpe).align

        return tpe
    } else if (@node).kind == parser::NodeKind::ARRAY_T {
        let array_tpe = type_lookup((@node).value.t_parr.tpe, state)
        let tpe = allocate(Type)
        (@tpe).kind = TypeKind::ARRAY
        (@tpe).tpe = array_tpe
        (@tpe).size = size_of string
        (@tpe).align = align_of string

        return tpe
    } else if (@node).kind == parser::NodeKind::ARRAY_STATIC_T {
        let array_tpe = type_lookup((@node).value.t_arrs.tpe, state)

        return make_static_array(array_tpe, (@(@node).value.t_arrs.n).value.i)
    } else if (@node).kind == parser::NodeKind::FUNCTION_T {
        let tpe = allocate(Type)
        (@tpe).kind = TypeKind::FUNCTION
        (@tpe).size = size_of type () -> ()
        (@tpe).align = align_of type () -> ()
        (@tpe).parameter_t = vector::make()
        for var i in 0..vector::length((@node).value.t_func.args) {
            let arg = vector::get((@node).value.t_func.args, i) !*parser::Node
            let np = allocate(NamedParameter)
            (@np).name = ""
            (@np).value = type_lookup(arg, state)
            vector::push((@tpe).parameter_t, np)
        }
        (@tpe).return_t = vector::make()
        for var i in 0..vector::length((@node).value.t_func.ret) {
            let arg = vector::get((@node).value.t_func.ret, i) !*parser::Node
            vector::push((@tpe).return_t, type_lookup(arg, state))
        }
        return pointer(tpe)
    }

    return null
}

// Returns the common type of two arithmetic types
// byte -> ubyte -> short -> ushort -> int -> uint -> long -> ulong
export def common_type(a: *Type, b: *Type) -> *Type {
    if not a or not b { return null }

    //TODO Should cause an error
    //assert(is_arithmetic(a) and is_arithmetic(b))

    if (@a).kind == TypeKind::FLOAT and (@b).kind == TypeKind::WORD {
        return a
    } else if (@a).kind == TypeKind::WORD and (@b).kind == TypeKind::FLOAT {
        return b
    }
    if (@a).kind == (@b).kind {
        if (@a).size == (@b).size {
            if (@b).unsig {
                return b
            } else {
                return a
            }
        } else if (@a).size > (@b).size {
            return a 
        } else {
            return b
        }
    }
    return null
}

def walk(node: *parser::Node, state: *State)

def walk_PtrT(node: *parser::Node, state: *State) {
    walk((@node).value.t_parr.tpe, state)
    (@node).tpe = type_
}

def walk_Null(node: *parser::Node, state: *State) {
    let tpe = allocate(Type)
    (@tpe).kind = TypeKind::NULL

    (@node).tpe = tpe
}

def walk_Integer(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::int_
}

def walk_Boolean(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::bool_
}

def walk_Float(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::double_
}

def walk_String(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::string_
}

def walk_Char(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::char_
}

def walk_Range(node: *parser::Node, state: *State) {
    walk((@node).value.bin_op.left, state)
    walk((@node).value.bin_op.right, state)

    var tpe: *Type = null
    tpe = allocate(Type)
    if (@node).kind == parser::NodeKind::RANGE_INC {
        (@tpe).kind = TypeKind::RANGE_INC
    } else {
        (@tpe).kind = TypeKind::RANGE
    }
    (@node).tpe = tpe
}

def walk_Identifier(node: *parser::Node, state: *State) {
    let value = scope::get((@state).scope, node)
    if not value {
        errorn(node, "Unknown identifier ")
        error(parser::identifier_to_str(node), "\n")
    } else {
        (@node).tpe = (@value).tpe
    }
}

def collapse_types(right: *vector::Vector, types: *vector::Vector, nodes: *vector::Vector, state: *State) { 
    for var i in 0..vector::length(right) {
        let value = vector::get(right, i) !*parser::Node
        if not value { continue }
        walk(value, state)
        let tpe = (@value).tpe
        if tpe and (@tpe).kind == TypeKind::TUPLE {
            for var j in 0..vector::length((@tpe).return_t) {
                let t = vector::get((@tpe).return_t, j) !*Type
                vector::push(types, t)
                vector::push(nodes, value)
            }
        } else {
            vector::push(types, tpe)
            vector::push(nodes, value)
        }
    }
}

def implicit_conversion(node: *parser::Node, tpe: *Type, rhstpe: *Type) -> *Type {
    // TODO For integers we need to check the boundaries
    // TODO What about stuff like --10? I mean its kinda useless but for completeness
    if (@node).kind == parser::NodeKind::NULL and is_pointer(tpe) or
        (@node).kind == parser::NodeKind::STRUCT_LIT and is_struct(tpe) or
        is_arithmetic(tpe) and ((@node).kind == parser::NodeKind::INTEGER or
        ((@node).kind == parser::NodeKind::USUB or (@node).kind == parser::NodeKind::UADD) and 
        (@(@node).value.expr).kind == parser::NodeKind::INTEGER) {

        (@node).tpe = tpe
        return tpe
    }
    return rhstpe
}

def walk_Assign(node: *parser::Node, state: *State) {
    let left = (@node).value.assign.left
    let right = (@node).value.assign.right

    let types = vector::make()
    let nodes = vector::make()
    collapse_types(right, types, nodes, state)

    if vector::length(types) != vector::length(left) {
        errorn(node, "Unbalanced assignment\n")
        return
    }

    for var i in 0..vector::length(left) {
        let node = vector::get(left, i) !*parser::Node
        walk(node, state)
        if not check_is_identifier_assignable(node, state) {
            continue
        }
        var tpe = vector::get(types, i) !*Type
        let n = vector::get(nodes, i) !*parser::Node

        tpe = implicit_conversion(n, (@node).tpe, tpe)

        if not tpe or not (@node).tpe { continue }

        if not is_assignable((@node).tpe, tpe) {
            errorn(node, "Incompatible types ")
            error(debug::type_to_str((@node).tpe), " and ", debug::type_to_str(tpe), "\n")
        }
    }
    (@node).tpe = vector::head(types) !*Type
}

// TODO We should declare all variables, always, to prevent multiple errors to occur
def walk_VarDecl(node: *parser::Node, state: *State) {
    let share = (@node).value.var_decl.share
    let kw = (@node).value.var_decl.kw
    let left = (@node).value.var_decl.left
    let right = (@node).value.var_decl.right

    if current_function(state) {
        if share != parser::ShareMarker::NONE {
            errorn(node, "Can't share non top level variable\n")
        }
    }

    let types = vector::make()
    let nodes = vector::make()
    collapse_types(right, types, nodes, state)

    if (kw == parser::VarDecl::CONST or 
        kw == parser::VarDecl::LET) and 
        vector::length(types) != vector::length(left) {
        
        errorn(node, "Unbalanced assignment\n")
        return
    }

    if vector::length(types) > vector::length(left) {
        errorn(node, "Too many values to assign\n")
        return
    }

    for var i in 0..vector::length(left) {
        let node = vector::get(left, i) !*parser::Node
        if (@node).kind == parser::NodeKind::ID_DECL {
            var tpe_node = (@node).value.id_decl.tpe
            var tpe: *Type = null
            if tpe_node {
                tpe = type_lookup(tpe_node, state)

                if i < vector::length(types) {
                    var rhstpe = vector::get(types, i) !*Type
                    let n = vector::get(nodes, i) !*parser::Node
                    
                    rhstpe = implicit_conversion(n, tpe, rhstpe)

                    if not tpe or not rhstpe { continue }

                    if not is_assignable(tpe, rhstpe) {
                        errorn(node, "Incompatible types ")
                        error(debug::type_to_str(tpe), " and ", debug::type_to_str(rhstpe), "\n")
                    }
                } 
            } else {
                if i < vector::length(types) {
                    tpe = vector::get(types, i) !*Type
                } else {
                    errorn(node, "Need to specify a type\n")
                    continue
                }
            }

            let ident = (@node).value.id_decl.value

            assert((@ident).kind == parser::NodeKind::IDENTIFIER)

            (@ident).scope = (@state).scope
            (@ident).tpe = tpe
            // TODO Implement constants (set a value)
            scope::create_variable((@state).scope, ident, share, kw, tpe, null)

        } else if (@node).kind == parser::NodeKind::ID_ASSIGN {
            let n = (@node).value.expr
            walk(n, state)
            
            if not check_is_identifier_assignable(n, state) {
                continue
            }

            let tpe = (@(@node).value.expr).tpe

            if not tpe { continue }
            // TODO tpe might be null, check if you can actually assign to the expression
            // Write a seperate function to check, also see walk_Assign

            if i >= vector::length(types) {
                errorn(node, "Must assign a value\n")
                continue
            }

            var rhstpe = vector::get(types, i) !*Type
            let n2 = vector::get(nodes, i) !*parser::Node

            rhstpe = implicit_conversion(n2, tpe, rhstpe)

            if not tpe or not rhstpe { continue }

            if not is_assignable(tpe, rhstpe) {
                errorn(node, "Incompatible types ")
                error(debug::type_to_str(tpe), " and ", debug::type_to_str(rhstpe), "\n")
            }
        } else { assert(false) }
    }
}

def walk_Not(node: *parser::Node, state: *State) {
    walk((@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not tpe { return }
    if not is_boolean(tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str(tpe), ", must be boolean type\n")
    }
    (@node).tpe = tpe
}

def walk_BNot(node: *parser::Node, state: *State) {
    walk((@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not tpe { return }
    if not is_integer(tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str(tpe), ", must be integer type\n")
    }
    (@node).tpe = tpe
}

def walk_UAdd(node: *parser::Node, state: *State) {
    walk((@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not tpe { return }
    if not is_arithmetic(tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str(tpe), ", must be arithmetic type\n")
    }
    (@node).tpe = tpe
}

def walk_USub(node: *parser::Node, state: *State) {
    walk((@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not tpe { return }
    if not is_arithmetic(tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str(tpe), ", must be arithmetic type\n")
    }
    /*if (@tpe).unsig {
        errorn(node, "Negation on unsigned type ")
        error(debug::type_to_str(tpe))
    }*/ // TODO Maybe give a warning on this?
    (@node).tpe = tpe
}

def walk_ArithmeticOp(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(left, state)
    walk(right, state)

    if not (@left).tpe or not (@right).tpe { return }
    (@node).tpe = common_type((@left).tpe, (@right).tpe)
}

def walk_BitwiseOp(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(left, state)
    walk(right, state)

    if not (@left).tpe or not (@right).tpe { return }
    if not is_integer((@left).tpe) or not is_integer((@right).tpe) {
        errorn(node, "Invalid operands of type ")
        error(debug::type_to_str((@left).tpe), " and ", debug::type_to_str((@right).tpe), " to bitwise operator")
    }

    (@node).tpe = common_type((@left).tpe, (@right).tpe)
}

def walk_BooleanOp(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(left, state)
    walk(right, state)

    if not (@left).tpe or not (@right).tpe { return }
    if not is_boolean((@left).tpe) or not is_boolean((@right).tpe) {
        errorn(node, "Invalid operands of type ")
        error(debug::type_to_str((@left).tpe), " and ", debug::type_to_str((@right).tpe), " to boolean operator")
    }

    (@node).tpe = builtins::bool_
}

// TODO implicit conversions here too
def walk_AssignEqArithmetic(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(left, state)
    walk(right, state)
    if not check_is_identifier_assignable(left, state) {
        return
    }

    if not (@left).tpe or not (@right).tpe { return }
    if not is_arithmetic((@right).tpe) {
        errorn(right, "Incompatible type, expected arithmetic type, got ")
        error(debug::type_to_str((@right).tpe), "\n")
    }
    if not is_arithmetic((@left).tpe) {
        errorn(right, "Incompatible type, expected arithmetic type, got ")
        error(debug::type_to_str((@left).tpe), "\n")
    }

    (@node).tpe = (@left).tpe
}

def walk_AssignEqBitwise(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(left, state)
    walk(right, state)
    if not check_is_identifier_assignable(left, state) {
        return
    }

    if not (@left).tpe or not (@right).tpe { return }
    if not is_integer((@right).tpe) {
        errorn(right, "Incompatible type, expected integer, got ")
        error(debug::type_to_str((@right).tpe), "\n")
    }
    if not is_integer((@left).tpe) {
        errorn(right, "Incompatible type, expected integer type, got ")
        error(debug::type_to_str((@left).tpe), "\n")
    }

    (@node).tpe = (@left).tpe
}

def walk_AssignEqPtr(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(left, state)
    walk(right, state)
    if not check_is_identifier_assignable(left, state) {
        return
    }

    if not (@left).tpe or not (@right).tpe { return }
    if not is_integer((@right).tpe) {
        errorn(right, "Incompatible type, expected integer, got ")
        error(debug::type_to_str((@right).tpe), "\n")
    }
    if not is_pointer((@left).tpe) {
        errorn(right, "Incompatible type, expected pointer type, got ")
        error(debug::type_to_str((@left).tpe), "\n")
    }

    (@node).tpe = (@left).tpe
}

def walk_Cast(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    //walk(right, state)
    let tpe = type_lookup(right, state)
    if not tpe { return }
    (@node).tpe = tpe

    if (@left).kind == parser::NodeKind::STRUCT_LIT {
        if (@tpe).kind != TypeKind::STRUCT and
            (@tpe).kind != TypeKind::UNION {
            errorn(left, "Invalid cast\n")
            return
        }
        (@left).tpe = (@node).tpe
    }
    if (@left).kind == parser::NodeKind::ARRAY_LIT {
        if (@tpe).kind != TypeKind::ARRAY and 
            (@tpe).kind != TypeKind::STATIC_ARRAY {
            errorn(left, "Invalid cast\n")
            return
        }
        (@left).tpe = (@node).tpe
    }
    walk(left, state)
}

def walk_Import(node: *parser::Node, state: *State) {
    if current_function(state) != null {
        errorn(node, "Can only import at top level\n")
        return
    }

    let imports = (@node).value.body
    for var i in 0..vector::length(imports) {
        let imprt = vector::get(imports, i) !*parser::Node
        var name = (@imprt).value.import_module.name
        var alias = (@imprt).value.import_module.alias
        if not alias {
            alias = name
        }
        let module = toolchain::compile_module(name)
        if not module {
            errorn(name, "Module ")
            error(parser::identifier_to_str(name), " could not be found\n")
            return
        }
        scope::insert_module((@state).scope, alias, module)
    }
}

def walk_Def(node: *parser::Node, state: *State) {
    let share = (@node).value.def_.share
    let body = (@node).value.def_.body
    let name = (@node).value.def_.name
    let params = (@node).value.def_.params
    let returns = (@node).value.def_.returns
    let outer_scope = (@state).scope

    if current_function(state) {
        if share != parser::ShareMarker::NONE {
            errorn(node, "Can't share non top level function\n")
        }
    }

    var forward_declare = true
    if body {
        forward_declare = false
        (@state).scope = scope::enter_function_scope((@state).scope)
    }

    let parameter_t = vector::make()
    let return_t = vector::make()
    for var i in 0..vector::length(params) {
        let param = vector::get(params, i) !*parser::Node
        assert((@param).kind == parser::NodeKind::PARAMETER)
        let named = allocate(NamedParameter)
        let name = (@param).value.param.name
        let tpe = type_lookup((@param).value.param.tpe, state)
        (@named).name = last_ident_to_str(name)
        (@named).value = tpe
        (@named).varargs = false

        if body {
            scope::create_variable((@state).scope, name, parser::ShareMarker::NONE, parser::VarDecl::VAR, tpe, null)
        }

        vector::push(parameter_t, named)
    }
    for var i in 0..vector::length(returns) {
        vector::push(return_t, type_lookup(vector::get(returns, i) !*parser::Node, state))
    }
    
    let tpe = make_type(TypeKind::FUNCTION, name)
    // TODO This isn't guaranteed by the C standard
    (@tpe).size = size_of type *
    (@tpe).align = align_of type *
    (@tpe).parameter_t = parameter_t
    (@tpe).return_t = return_t
    (@tpe).macro = null
    (@tpe).proto = null
    if current_function(state) {
        // This is so that we don't create overloaded functions
        // inside of a function
        // TODO what about forward declarations?
        scope::create_variable(outer_scope, name, share, parser::VarDecl::CONST, tpe, null)
    } else {
        scope::create_function(outer_scope, name, share, tpe, forward_declare)
    }
    
    if body {
        push_function(state, tpe)
        for var i in 0..vector::length(body) {
            walk(vector::get(body, i) !*parser::Node, state)
        }
        (@node).scope = (@state).scope
        (@state).scope = scope::exit_scope((@state).scope)
        pop_function(state)
    }

    (@node).tpe = tpe
}

def walk_TypeDecl(node: *parser::Node, state: *State) {
    let share = (@node).value.type_decl.share
    let left = (@node).value.type_decl.left
    let right = (@node).value.type_decl.right

    if vector::length(left) < vector::length(right) {
        errorn(node, "Too many values to assign\n")
        return
    }

    for var i in 0..vector::length(left) {
        let name = vector::get(left, i) !*parser::Node
        var value: *parser::Node = null
        if i < vector::length(right) {
            value = vector::get(right, i) !*parser::Node
        }
        
        var tpe = make_type(TypeKind::STUB, name)
        if vector::length((@name).value.body) > 1 {
            if value {
                errorn(name, "Can't create type in sub scope\n")
                continue
            }
            let scpe = toolchain::get_forward_declared_scope(name)
            let last = vector::peek((@name).value.body) !*string
            let n = parser::copy_node(name)
            (@n).value.body = vector::make()
            vector::push((@n).value.body, last)
            scope::create_type(scpe, n, share, tpe)
            tpe = scope::get_type(scpe, n)
        }

        if not scope::create_type((@state).scope, name, share, tpe) {
            continue
        }
        
        if value {
            tpe = copy(type_lookup(value, state))
            if not tpe { return }
            (@tpe).name = parser::identifier_to_str(name)
            if (@value).kind == parser::NodeKind::STRUCT_T or
                (@value).kind == parser::NodeKind::UNION_T or
                (@value).kind == parser::NodeKind::ENUM_T {
                // Name anonymous struct or union
                (@tpe).type_name = append_module((@tpe).name, (@node).loc.module)
            }
            if (@value).kind == parser::NodeKind::ENUM_T {
                // Create all the constants
                let scpe = scope::enter_scope((@state).scope)
                
                // TODO Do something about negative values (btw evaluate_constant can't handle them now)
                var last_value: uint64 = 0
                for var i in 0..vector::length((@value).value.t_enum.body) {
                    let iddecl = vector::get((@value).value.t_enum.body, i) !*parser::Node

                    var constant: *uint64 = null
                    if (@iddecl).value.id_decl_enum.value {
                        constant = evaluate_constant((@iddecl).value.id_decl_enum.value) !*uint64
                    } else {
                        constant = allocate(uint64)
                        @constant = last_value
                    }

                    scope::create_variable(scpe, (@iddecl).value.id_decl_enum.ident, 
                        share, parser::VarDecl::CONST, tpe, constant)

                    last_value = @constant + 1
                }

                scope::create_type_scope((@state).scope, name, share, tpe, scpe)
            } else {
                scope::create_type((@state).scope, name, share, tpe)
            }
        }
        (@name).tpe = tpe
    }
}

def walk_Return(node: *parser::Node, state: *State) {
    let current_fun = current_function(state)
    let body = (@node).value.body
    if not current_fun {
        // TODO This is actually allowed, I just need to infer the types
        // and assign to some sort of internal variable
        errorn(node, "return outside of a function\n")
        return
    }
    
    let types = vector::make()
    let nodes = vector::make()
    collapse_types(body, types, nodes, state)
    let returns = (@current_fun).return_t

    if vector::length(types) != vector::length(returns) {
        // TODO Improve error message
        errorn(node, "Wrong number of arguments to return\n")
    }

    for var i in 0..vector::length(returns) {
        let argtpe = vector::get(returns, i) !*Type
        var rettpe = vector::get(types, i) !*Type
        let n = vector::get(nodes, i) !*parser::Node
        
        rettpe = implicit_conversion(n, argtpe, rettpe)
        if not argtpe or not rettpe { continue }
        if not is_assignable(argtpe, rettpe) {
            // TODO This doesn't point to the actual value
            errorn(node, "Wrong type of return argument, got ")
            error(debug::type_to_str(rettpe), ", expected ", debug::type_to_str(argtpe), "\n")
        }
    }
    (@node).tpe = current_fun
}

def walk_Call(node: *parser::Node, state: *State) {
    var arguments = vector::make()

    for var i in 0..vector::length((@node).value.func_call.args) {
        let n = vector::get((@node).value.func_call.args, i) !*parser::Node
        walk(n, state)
        let np = allocate(NamedParameter)
        (@np).name = ""
        (@np).value = (@n).tpe
        (@np).varargs = false
        vector::push(arguments, np)
    }
    let parameter_map = map::make()
    for var i in 0..vector::length((@node).value.func_call.kwargs) {
        let n = vector::get((@node).value.func_call.kwargs, i) !*parser::Node
        walk((@n).value.named_arg.value, state)
        let name = last_ident_to_str((@n).value.named_arg.name)

        if map::contains(parameter_map, name) {
            // and we cannot have two things with the same name so just error here...
            errorn(n, "Cannot have the same parameter name multiple times in a function call. Parameter name was \"")
            error(name, "\".\n")
            break
        } else {
            map::put(parameter_map, name, map::sentinel)
            let np = allocate(NamedParameter)
            (@np).name = name
            (@np).value = (@(@n).value.named_arg.value).tpe
            (@np).varargs = false
            vector::push(arguments, np)
        }
    }
    // TODO What about function pointers and foo.bar(baz) == bar(foo, baz)

    var tpe: *Type = null
    
    let left = (@node).value.func_call.left

    walk(left, state)
    tpe = (@left).tpe
    if not is_function_pointer(tpe) {
        if (@left).kind == parser::NodeKind::IDENTIFIER {
            var function = scope::get_function((@state).scope, left, arguments)

            if not function {
                errorn(left, "Function \"")
                error(parser::identifier_to_str(left), "\" not found. Arguments were of type ")
                let len = vector::length(arguments)
                for var i in 0..len {
                    let arg = vector::get(arguments, i) !*NamedParameter
                    error(debug::type_to_str((@arg).value))
                    if i < len - 1 {
                        error(", ")
                    }
                }
                error("\n")
                return
            }

            tpe = (@function).tpe
        } else {
            errorn(left, "Can't call expression")
            return
        }
    }

    (@node).function = tpe
    if is_function_pointer(tpe) {
        tpe = (@tpe).tpe
    }
    
    let parameter_t = (@tpe).parameter_t

    // Implicit conversions
    for var i in 0..vector::length((@node).value.func_call.args) {
        let n = vector::get((@node).value.func_call.args, i) !*parser::Node
        var rhstpe: *Type
        if i < vector::length(parameter_t) {
            rhstpe = (@(vector::get(parameter_t, i) !*NamedParameter)).value
        } else {
            let np = vector::peek(parameter_t) !*NamedParameter
            assert((@np).varargs)
            rhstpe = (@np).value
        }
        
        implicit_conversion(n, rhstpe, null)
    }
    for var i in 0..vector::length((@node).value.func_call.kwargs) {
        let n = vector::get((@node).value.func_call.kwargs, i) !*parser::Node
        let name = last_ident_to_str((@n).value.named_arg.name)
        let arg = (@n).value.named_arg.value

        var rhstpe: *Type
        for var j in 0..vector::length(parameter_t) {
            let param = vector::get(parameter_t, j) !*NamedParameter
            if (@param).name == name {
                rhstpe = (@param).value
                break
            }
        }
        implicit_conversion(arg, rhstpe, null)
    }
    var return_t = (@tpe).return_t
    if (@tpe).proto {
        return_t = (@tpe).proto((@node).value.func_call.args, (@node).value.func_call.kwargs, state)
    }

    let len = vector::length(return_t) 
    if len > 1 {
        // TODO size and alignment! Same as a struct,
        // also refactor type_lookup and compiler (functions with multiple return types)
        // into a single function for calculating the size and alignmenet of a struct
        let return_tpe = allocate(Type)
        (@return_tpe).kind = TypeKind::TUPLE
        (@return_tpe).return_t = return_t
        (@node).tpe = return_tpe
    } else if len == 1 {
        (@node).tpe = vector::peek(return_t) !*Type
    } else {
        (@node).tpe = null
    }
}

def walk_Case(node: *parser::Node, state: *State) {
    for var i in 0..vector::length((@node).value.case_.expr) {
        let expr = vector::get((@node).value.case_.expr, i) !*parser::Node
        walk(expr, state)
        if not (is_arithmetic((@expr).tpe) or is_enum((@expr).tpe) or is_range((@expr).tpe)){
            errorn(expr, "Incompatible type, expected arithmetic type, range or enum, got ")
            error(debug::type_to_str((@expr).tpe), "\n")
            return
        }
    }
    for var i in 0..vector::length((@node).value.case_.body) {
        let expr = vector::get((@node).value.case_.body, i) !*parser::Node
        walk(expr, state)
    }
}

def walk_Switch(node: *parser::Node, state: *State) {
    let expr = (@node).value.switch_.expr
    walk(expr, state)
    if not (is_arithmetic((@expr).tpe) or is_enum((@expr).tpe) ){
        errorn(expr, "Incompatible type, expected arithmetic type or enum, got ")
        error(debug::type_to_str((@expr).tpe), "\n")
        return
    }

    for var i in 0..vector::length((@node).value.switch_.body) {
        walk(vector::get((@node).value.switch_.body, i) !*parser::Node, state)
    }
}

def walk_If(node: *parser::Node, state: *State) {
    let cond = (@node).value.if_.cond
    walk(cond, state)
    let tpe = (@cond).tpe
    if not tpe { return }
    if not is_boolean(tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str(tpe), ", must be boolean type\n")
    }
    
    (@state).scope = scope::enter_scope((@state).scope)
    for var i in 0..vector::length((@node).value.if_.body) {
        let n = vector::get((@node).value.if_.body, i) !*parser::Node
        walk(n, state)
    }
    (@state).scope = scope::exit_scope((@state).scope)

    for var i in 0..vector::length((@node).value.if_.else_if) {
        let n = vector::get((@node).value.if_.else_if, i) !*parser::Node
        
        let cond = (@n).value.else_if.cond
        walk(cond, state)
        let tpe = (@cond).tpe
        
        if not is_boolean(tpe) {
            errorn(n, "Incompatible type ")
            error(debug::type_to_str(tpe), ", must be boolean type\n")
        }

        (@state).scope = scope::enter_scope((@state).scope)
        for var i in 0..vector::length((@n).value.else_if.body) {
            let n2 = vector::get((@n).value.else_if.body, i) !*parser::Node
            walk(n2, state)
        }   
        (@state).scope = scope::exit_scope((@state).scope)
    }

    let else_ = (@node).value.if_.else_
    if else_ {
        (@state).scope = scope::enter_scope((@state).scope)
        for var i in 0..vector::length((@else_).value.body) {
            let n = vector::get((@else_).value.body, i) !*parser::Node
            walk(n, state)
        }
        (@state).scope = scope::exit_scope((@state).scope)
    }
}

def walk_Loop(node: *parser::Node, state: *State) {
    (@state).scope = scope::enter_scope((@state).scope)
    for var i in 0..vector::length((@node).value.body) {
        let n = vector::get((@node).value.body, i) !*parser::Node
        walk(n, state)
    }
    (@state).scope = scope::exit_scope((@state).scope)
}

def walk_While(node: *parser::Node, state: *State) {
    let expr = (@node).value.while_loop.expr
    walk(expr, state)
    if not is_boolean((@expr).tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str((@expr).tpe), ", must be boolean type\n")
    }

    (@state).scope = scope::enter_scope((@state).scope)
    for var i in 0..vector::length((@node).value.while_loop.body) {
        let n = vector::get((@node).value.while_loop.body, i) !*parser::Node
        walk(n, state)
    }
    (@state).scope = scope::exit_scope((@state).scope)
}

def walk_For(node: *parser::Node, state: *State) {
    let expr = (@node).value.for_loop.expr
    walk(expr, state)
    (@state).scope = scope::enter_scope((@state).scope)

    let iddecl = (@node).value.for_loop.iddecl
    var tpe = builtins::int_
    if is_array((@expr).tpe) {
        tpe = (@(@expr).tpe).tpe
    }
    if (@iddecl).kind == parser::NodeKind::FOR_ID_DECL {
        (@iddecl).tpe = tpe
        (@iddecl).scope = (@state).scope
        scope::create_variable(
            (@state).scope, 
            (@iddecl).value.for_id_decl.ident, 
            parser::ShareMarker::NONE, 
            (@iddecl).value.for_id_decl.kw, 
            tpe, null
        )
    
    } else {
        walk(iddecl, state)
        if not equals(tpe, (@iddecl).tpe) {
            errorn(iddecl, "Type didn't match, expected ")
            error(debug::type_to_str(tpe), ", got ", debug::type_to_str((@iddecl).tpe))
        }
    }

    for var i in 0..vector::length((@node).value.for_loop.body) {
        let n = vector::get((@node).value.for_loop.body, i) !*parser::Node
        walk(n, state)
    }
    (@state).scope = scope::exit_scope((@state).scope)
}

def walk_Deref(node: *parser::Node, state: *State) {
    walk((@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not tpe { return }
    if not is_pointer(tpe) {
        errorn(node, "Needs to be a pointer type, got ")
        error(debug::type_to_str(tpe), "\n")
        return
    }
    (@node).tpe = (@tpe).tpe
}

def walk_Ptr(node: *parser::Node, state: *State) {
    walk((@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    (@node).tpe = pointer(tpe)
}

def walk_MemberAccess(node: *parser::Node, state: *State) {
    walk((@node).value.bin_op.left, state)
    let right = (@node).value.bin_op.right
    let tpe = (@(@node).value.bin_op.left).tpe

    if not tpe { return }

    if (@tpe).kind == TypeKind::STRUCT or (@tpe).kind == TypeKind::UNION {
        let name = last_ident_to_str(right)

        var rtpe: *Type = null
        for var i in 0..(@tpe).fields.size {
            let member = (@tpe).fields[i]
            if member.name == name {
                rtpe = member.tpe
                break
            }
        }
        if not rtpe {
            errorn(node, "Unknown field \"")
            error(name, "\"\n")
            return
        }
        (@node).tpe = rtpe
    } else if (@tpe).kind == TypeKind::ARRAY or (@tpe).kind == TypeKind::STATIC_ARRAY {
        let name = last_ident_to_str(right)
        if name == "size" {
            (@node).tpe = builtins::size_t_
        } else if name == "value" {
            (@node).tpe = pointer((@tpe).tpe)
        } else {
            errorn(node, "Expected size or value\n")
        }
    // TODO Enums might have ordinal and some other information
    } else {
        // TODO obj.method() -> method(obj)
        errorn(node, "Expected aggregate type, got ")
        error(debug::type_to_str(tpe), "\n")
    }
}

def walk_ArraySubscript(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right

    walk(left, state)
    walk(right, state)

    let tpe = (@left).tpe
    if not tpe { return }
    if is_pointer(tpe) or (@tpe).kind == TypeKind::ARRAY or
        (@tpe).kind == TypeKind::STATIC_ARRAY {
        (@node).tpe = (@tpe).tpe
    } else {
        errorn(left, "Expected array or pointer type, got ")
        error(debug::type_to_str(tpe), "\n")
    }
    if not is_arithmetic((@right).tpe) {
        errorn(right, "Expected arithmetic type, got ")
        error(debug::type_to_str((@right).tpe), "\n")
    }
}

def walk_StructLit(node: *parser::Node, state: *State) {
    let tpe = (@node).tpe
    // This instructs compile to skip the struct literal completely
    (@node).tpe = null

    if not tpe {
        errorn(node, "Need to specify a type for struct literal\n")
        return
    }

    for var i in 0..vector::length((@node).value.struct_lit.args) {
        let n = vector::get((@node).value.struct_lit.args, i) !*parser::Node
        if i > (@tpe).fields.size {
            errorn(n, "Too many arguments to array literal\n")
            return
        }
        walk(n, state)
        
        var ntpe = (@tpe).fields[i].tpe
        ntpe = implicit_conversion(n, (@n).tpe, ntpe)

        if not ntpe or not (@n).tpe { continue }
        if not is_assignable(ntpe, (@n).tpe) {
            errorn(n, "Incompatible types ")
            error(debug::type_to_str((@n).tpe), " and ", debug::type_to_str(ntpe), "\n")
            return
        }
    }
    for var i in 0..vector::length((@node).value.struct_lit.kwargs) {
        let kwarg = vector::get((@node).value.struct_lit.kwargs, i) !*parser::Node
        let n = (@kwarg).value.named_arg.value
        walk(n, state)
        let name = last_ident_to_str((@kwarg).value.named_arg.name)

        var found = false
        for var j in 0..(@tpe).fields.size {
            let field = (@tpe).fields[j]
            if field.name == name {
                found = true

                var ntpe = field.tpe
                ntpe = implicit_conversion(n, (@n).tpe, ntpe)

                if not ntpe or not (@n).tpe { continue }
                if not is_assignable(ntpe, (@n).tpe) {
                    errorn(n, "Incompatible types ")
                    error(debug::type_to_str((@n).tpe), " and ", debug::type_to_str(ntpe), "\n")
                    return
                }
                break
            }
        }
        if not found {
            errorn(n, "Unknown field \"")
            error(name, "\"")
            return
        }
    }

    (@node).tpe = tpe
}

// TODO We might want to allow assignments like
// let array: [double] = [1, 2, 3, 4] // And convert to double here
def walk_ArrayLit(node: *parser::Node, state: *State) {
    var tpe: *Type = null
    if (@node).tpe {
        tpe = (@(@node).tpe).tpe
    }
    let len = vector::length((@node).value.body)
    for var i in 0..len {
        let n = vector::get((@node).value.body, i) !*parser::Node
        walk(n, state)
        let t = (@n).tpe
        if not tpe { tpe = t }
        else {
            if not equals(tpe, t) {
                errorn(n, "Incompatible types, all array elements need to have the same type. Array type ")
                error(debug::type_to_str(tpe), ", got ", debug::type_to_str(t), "\n")
                // It might be confusing to get multiple errors here
                break
            }
        }
    }
    
    if not (@node).tpe {
        let ret_tpe = allocate(Type)
        (@ret_tpe).kind = TypeKind::STATIC_ARRAY
        (@ret_tpe).length = len
        (@ret_tpe).tpe = tpe

        (@node).tpe = ret_tpe
    }
}

def walk_SizeOf(node: *parser::Node, state: *State) {
    let expr = (@node).value.expr
    // Need to special case here
    if (@expr).kind == parser::NodeKind::IDENTIFIER {
        let value = scope::get((@state).scope, expr)
        if not value {
            errorn(expr, "Unknown identifier \"")
            error(parser::identifier_to_str(expr), "\"\n")
            return
        }
        if (@value).modifier == parser::VarDecl::TYPE {
            (@expr).tpe = (@value).value !*Type
        } else {
            (@expr).tpe = (@value).tpe
        }
    } else {
        (@expr).tpe = type_lookup(expr, state)
        if not (@expr).tpe {
            walk(expr, state)
        }
    }

    (@node).tpe = builtins::size_t_
}

def walk_AlignOf(node: *parser::Node, state: *State) {
    let expr = (@node).value.expr
    // Need to special case here
    if (@expr).kind == parser::NodeKind::IDENTIFIER {
        let value = scope::get((@state).scope, expr)
        if not value {
            errorn(expr, "Unknown identifier \"")
            error(parser::identifier_to_str(expr), "\"\n")
            return
        }
        if (@value).modifier == parser::VarDecl::TYPE {
            (@expr).tpe = (@value).value !*Type
        } else {
            (@expr).tpe = (@value).tpe
        }
    } else {
        (@expr).tpe = type_lookup(expr, state)
        if not (@expr).tpe {
            walk(expr, state)
        }
    }

    (@node).tpe = builtins::size_t_
}

def walk_ComparisionOp(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    walk(left, state)
    walk(right, state)
    // TODO We can compare almost everything
    (@node).tpe = builtins::bool_
}

def walk_PAdd(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    walk(left, state)
    walk(right, state)
    if not is_pointer((@left).tpe) {
        errorn(left, "Must be pointer type, got ")
        error(debug::type_to_str((@left).tpe), "\n")
    }
    if not is_arithmetic((@right).tpe) {
        errorn(left, "Must be arithmetic type, got ")
        error(debug::type_to_str((@right).tpe), "\n")
    }
    // TODO should probably not set this to a garbage value
    (@node).tpe = (@left).tpe
}

def walk_PSub(node: *parser::Node, state: *State) {
    walk_PAdd(node, state)
}

def walk(node: *parser::Node, state: *State) {
    if not node { return }
    (@node).scope = (@state).scope

    switch (@node).kind !int {
        case parser::NodeKind::NULL:
            walk_Null(node, state)
        case parser::NodeKind::INTEGER:
            walk_Integer(node, state)
        case parser::NodeKind::BOOLEAN:
            walk_Boolean(node, state)
        case parser::NodeKind::STRING:
            walk_String(node, state)
        case parser::NodeKind::CHAR:
            walk_Char(node, state)
        case parser::NodeKind::FLOAT:
            walk_Float(node, state)
        case parser::NodeKind::RANGE..=parser::NodeKind::RANGE_INC:
            walk_Range(node, state)
        case parser::NodeKind::IDENTIFIER:
            walk_Identifier(node, state)
        case parser::NodeKind::SIZE_OF:
            walk_SizeOf(node, state)
        case parser::NodeKind::ALIGN_OF:
            walk_AlignOf(node, state)
        case parser::NodeKind::LOOP:
            walk_Loop(node, state)
        case parser::NodeKind::WHILE:
            walk_While(node, state)
        case parser::NodeKind::FOR:
            walk_For(node, state)
        case parser::NodeKind::IF:
            walk_If(node, state)
        case parser::NodeKind::SWITCH:
            walk_Switch(node, state)
        case parser::NodeKind::CASE:
            walk_Case(node, state)
        case parser::NodeKind::DEF:
            walk_Def(node, state)
        case parser::NodeKind::IMPORT:
            walk_Import(node, state)
        case parser::NodeKind::CAST:
            walk_Cast(node, state)
        case parser::NodeKind::ASSIGN:
            walk_Assign(node, state)
        case parser::NodeKind::VAR_DECL:
            walk_VarDecl(node, state)
        case parser::NodeKind::UADD:
            walk_UAdd(node, state)
        case parser::NodeKind::USUB:
            walk_USub(node, state)
        case parser::NodeKind::BNOT:
            walk_BNot(node, state)
        case parser::NodeKind::NOT:
            walk_Not(node, state)
        case parser::NodeKind::ADD..=parser::NodeKind::MOD:
            walk_ArithmeticOp(node, state)
        case parser::NodeKind::BAND..=parser::NodeKind::SHR:
            walk_BitwiseOp(node, state)
        case parser::NodeKind::AND..=parser::NodeKind::OR:
            walk_BooleanOp(node, state)
        case parser::NodeKind::EQ..=parser::NodeKind::LEQ:
            walk_ComparisionOp(node, state)
        case parser::NodeKind::ADD_EQ..=parser::NodeKind::MOD_EQ:
            walk_AssignEqArithmetic(node, state)
        case parser::NodeKind::AND_EQ..=parser::NodeKind::SHR_EQ:
            walk_AssignEqBitwise(node, state)
        case parser::NodeKind::PADD_EQ..=parser::NodeKind::PSUB_EQ:
            walk_AssignEqPtr(node, state)
        case parser::NodeKind::PADD:
            walk_PAdd(node, state)
        case parser::NodeKind::PSUB:
            walk_PSub(node, state)
        case parser::NodeKind::DEREF:
            walk_Deref(node, state)
        case parser::NodeKind::PTR:
            walk_Ptr(node, state)
        case parser::NodeKind::TYPE_DECL:
            walk_TypeDecl(node, state)
        case parser::NodeKind::RETURN:
            walk_Return(node, state)
        case parser::NodeKind::FUNC_CALL:
            walk_Call(node, state)
        case parser::NodeKind::BREAK..=parser::NodeKind::CONTINUE:
            // Noop
            null
        case parser::NodeKind::MEMBER_ACCESS:
            walk_MemberAccess(node, state)
        case parser::NodeKind::ARRAY_SUBSCRIPT:
            walk_ArraySubscript(node, state)
        case parser::NodeKind::STRUCT_LIT:
            walk_StructLit(node, state)
        case parser::NodeKind::ARRAY_LIT:
            walk_ArrayLit(node, state)
        case parser::NodeKind::PTR_T:
            walk_PtrT(node, state)
        case:
            error((@node).kind, "\n")
            assert(false)
    }
}

export def typecheck(module: *toolchain::Module) {
    let node = (@module).node
    assert((@node).kind == parser::NodeKind::PROGRAM)

    var state: State
    state.filename = (@module).filename
    state.module = (@module).module
    state.scope = (@module).scope
    state.function_stack = vector::make()

    for var i in 0..vector::length((@node).value.body) {
        walk(vector::get((@node).value.body, i) !*parser::Node, *state)
    }
    (@node).scope = state.scope
}

// TODO Make this function variadic
export def errorn(node: *parser::Node, msg: string) {
    if not node { assert(false) }
    let filename = (@node).loc.filename
    let line = (@node).loc.line
    let column = (@node).loc.column

    error("\n")
    error(filename, "@", line + 1, ":", column + 1, "\n")
    error((@node).loc.lines[line], "\n")
    for var i in 0..column {
        error(" ")
    }
    error("^\n")
    error(msg)

    toolchain::error_count += 1
}