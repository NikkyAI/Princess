import vector
import buffer
import map
import util
import parser
import typechecking
import compiler
import scope
import debug
import builtins

def param(name: string, tpe: *typechecking::Type) -> *typechecking::NamedParameter {
    let named = allocate(typechecking::NamedParameter)
    (@named).name = name
    (@named).value = tpe
    (@named).varargs = false
    return named
}

def varargs(name: string, tpe: *typechecking::Type) -> *typechecking::NamedParameter {
    let named = allocate(typechecking::NamedParameter)
    (@named).name = name
    (@named).value = tpe
    (@named).varargs = true
    return named
}

def make_function_type(
    name: string, 
    parameter_t: [*typechecking::NamedParameter],
    return_t: [*typechecking::Type],
    macro: (*parser::Node, [compiler::Value], *compiler::State) -> compiler::Value,
    proto: (*vector::Vector, *vector::Vector, *typechecking::State) -> (*vector::Vector)) -> *typechecking::Type {
    
    let pars = vector::make()
    for var i in 0..parameter_t.size {
        vector::push(pars, parameter_t[i])
    }
    let rets = vector::make()
    for var i in 0..return_t.size {
        vector::push(rets, return_t[i])
    }

    let tpe = allocate(typechecking::Type)
    (@tpe).kind = typechecking::TypeKind::FUNCTION
    (@tpe).name = name
    (@tpe).type_name = name
    (@tpe).parameter_t = pars
    (@tpe).return_t = rets
    (@tpe).macro = macro
    (@tpe).proto = proto

    return tpe
}

def create_function(
    name: string, 
    parameter_t: [*typechecking::NamedParameter],
    return_t: [*typechecking::Type],
    macro: (*parser::Node, [compiler::Value], *compiler::State) -> compiler::Value,
    proto: (*vector::Vector, *vector::Vector, *typechecking::State) -> (*vector::Vector)) {
    
    scope::create_function(
        builtins::builtins, 
        parser::make_identifier([name]), 
        parser::ShareMarker::EXPORT, 
        make_function_type(name, parameter_t, return_t, macro, proto),
        false
    )
}

def import_function(state: *compiler::State, function: string) {
    map::put((@(@state).module).imported, function, map::sentinel)
}

def charp_str(value: compiler::Value, state: *compiler::State) -> compiler::Value {
    let local = compiler::make_local_value(typechecking::pointer(builtins::char_), null, state)

    let index = allocate(int, 1)
    index[0] = 1

    let extract = allocate(compiler::Insn)
    (@extract).kind = compiler::InsnKind::EXTRACTVALUE
    (@extract).value.extract_value = {
        ret = local,
        value = value,
        index = index
    } !InsnExtractValue

    compiler::push_insn(extract, state)

    return local
}

def charp_static(global: *compiler::Value, state: *compiler::State) -> compiler::Value {
    let local = compiler::make_local_value(typechecking::pointer(builtins::char_), global, state)

    let index = allocate(compiler::Value, 2)
    index[0] = compiler::make_int_value(0)
    index[1] = compiler::make_int_value(0)

    let gep = allocate(compiler::Insn)
    (@gep).kind = compiler::InsnKind::GETELEMENTPTR
    (@gep).value.gep = {
        ret = local,
        tpe = (@(@global).tpe).tpe,
        value = @global,
        index = index
    } !InsnGetElementPtr

    compiler::push_insn(gep, state)

    return local
}

def charp(str: string, state: *compiler::State) -> compiler::Value {
    let tpe = allocate(typechecking::Type)
    (@tpe).kind = typechecking::TypeKind::STATIC_ARRAY
    (@tpe).tpe = builtins::char_
    (@tpe).length = str.size
    (@tpe).size = (@tpe).length * (size_of char)
    (@tpe).align = size_of char

    let value = allocate(compiler::Value)
    @value = {
        kind = compiler::ValueKind::STRING,
        s = str,
        tpe = tpe
    } !compiler::Value

    let global = compiler::make_global_value(tpe, "str", value, state)
    let globalp = allocate(compiler::Value)
    @globalp = global
    return charp_static(globalp, state)
}

def convert_to_charp(values: [compiler::Value], state: *compiler::State) {
    for var i in 0..values.size {
        values[i] = charp_str(values[i], state)
    }
}

def get_arg(args: *vector::Vector, kwargs: *vector::Vector, index: int, name: string) -> *parser::Node {
    if index < vector::length(args) {
        return vector::get(args, index) !*parser::Node
    }
    for var i in 0..vector::length(kwargs) {
        let kwarg = vector::get(kwargs, i) !*parser::Node
        let nname = typechecking::last_ident_to_str((@kwarg).value.named_arg.name)
        if nname == name {
            return (@kwarg).value.named_arg.value
        }
    }
    return null
}

def _assert(node: *parser::Node, argsv: [compiler::Value], state: *compiler::State) -> compiler::Value {
    import_function(state, "__assert_fail")
    let insn = argsv[0]
    if not insn.tpe { return compiler::NO_VALUE }

    let if_false = compiler::make_label(state)
    
    let br = allocate(compiler::Insn)
    (@br).kind = compiler::InsnKind::BR
    (@br).value.br = {
        cond = insn,
        if_false = if_false
    } !compiler::InsnBr
    compiler::push_insn(br, state)

    compiler::push_label(if_false, state)

    let args = allocate(compiler::Value, 4)
    // TODO I think assertions are supposed to only show the assertion and not the whole line
    args[0] = charp((@node).loc.lines[(@node).loc.line], state)
    args[1] = charp((@node).loc.filename, state)
    args[2] = { kind = compiler::ValueKind::INT, i = (@node).loc.line, tpe = builtins::int_ } !compiler::Value

    var current_function = "main"
    if (@state).current_function {
        current_function = (@(@state).current_function).unmangled
    }
    args[3] = charp(current_function, state)

    let call = allocate(compiler::Insn)
    (@call).kind = compiler::InsnKind::CALL
    (@call).value.call = {
        name = { kind = compiler::ValueKind::GLOBAL, name = "__assert_fail" } !compiler::Value,
        ret = compiler::NO_VALUE,
        args = args
    } !compiler::InsnCall
    
    compiler::push_insn(call, state)

    let unreachable = allocate(compiler::Insn)
    (@unreachable).kind = compiler::InsnKind::UNREACHABLE

    compiler::push_insn(unreachable, state)

    let if_true = compiler::make_label(state)
    compiler::push_label(if_true, state)
    (@br).value.br.if_true = if_true

    return compiler::NO_VALUE
}

create_function(
    "assert", 
    [param("assertion", builtins::bool_)],
    // TODO This is ugly...
    [] ![typechecking::Type], 
    *_assert,
    null
)

// TODO it would make more sense to accept [compiler::Value] here, lets see what we can do about that error message
def format_str(args: *vector::Vector) -> *string {
    let buf = buffer::make_buffer()
    for var i in 0..vector::length(args) {
        let arg = vector::get(args, i) !*parser::Node
        let tpe = (@arg).tpe
        if not tpe { return null }

        // TODO Typedefs of these types don't work
        // TODO Also do something about other types like structs and arrays
        if tpe == builtins::size_t_ { buffer::append_str(*buf, "%zu") 
        } else if tpe == builtins::char_ { buffer::append_str(*buf, "%c")
        } else if typechecking::equals(tpe, builtins::string_) or
            typechecking::equals(tpe, typechecking::pointer(builtins::char_)) or
            ((@tpe).kind == typechecking::TypeKind::STATIC_ARRAY and typechecking::equals((@tpe).tpe, builtins::char_)) { 
                buffer::append_str(*buf, "%s")
        } else if typechecking::is_pointer(tpe) { buffer::append_str(*buf, "%p") 
        } else if typechecking::equals(tpe, builtins::int8_) { buffer::append_str(*buf, "%hhd") 
        } else if typechecking::equals(tpe, builtins::uint8_) { buffer::append_str(*buf, "%hhu") 
        } else if typechecking::equals(tpe, builtins::int16_) { buffer::append_str(*buf, "%hd")
        } else if typechecking::equals(tpe, builtins::uint16_) { buffer::append_str(*buf, "%hu")
        } else if typechecking::equals(tpe, builtins::int32_) { buffer::append_str(*buf, "%d")
        } else if typechecking::equals(tpe, builtins::uint32_) { buffer::append_str(*buf, "%u")
        } else if typechecking::equals(tpe, builtins::int64_) { buffer::append_str(*buf, "%ld")
        } else if typechecking::equals(tpe, builtins::uint64_) { buffer::append_str(*buf, "%lu")
        } else if typechecking::equals(tpe, builtins::float32_) { buffer::append_str(*buf, "%f")
        } else if typechecking::equals(tpe, builtins::float64_) { buffer::append_str(*buf, "%f")
        } else {
            typechecking::errorn(arg, "Print type ")
            error(debug::type_to_str(tpe), " not supported\n")
            return null
        }
    }
    return util::copy_string(buffer::to_string(*buf))
}

def _print(node: *parser::Node, argsv: [compiler::Value], state: *compiler::State) -> compiler::Value {
    import_function(state, "printf")

    let fmt = format_str((@node).value.func_call.args)
    if not fmt { return compiler::NO_VALUE }

    let args = allocate(compiler::Value, argsv.size + 1)
    args[0] = charp(@fmt, state)

    for var i in 0..argsv.size {
        var value = argsv[i]
        if not value.tpe { return compiler::NO_VALUE }
        if ((@value.tpe).kind == typechecking::TypeKind::STATIC_ARRAY and 
            typechecking::equals((@value.tpe).tpe, builtins::char_)) {
            value = charp_static(value.addr, state)
        } else if typechecking::equals(value.tpe, builtins::string_) {
            value = charp_str(value, state)
        }
        args[i + 1] = value
    }

    let ret = compiler::make_local_value(builtins::int_, null, state)
    let call = allocate(compiler::Insn)

    let proto = allocate(typechecking::NamedParameter, 2)
    proto[0] = @param("", typechecking::pointer(builtins::char_))
    proto[1] = @varargs("", null)

    (@call).kind = compiler::InsnKind::CALL
    (@call).value.call = {
        name = { kind = compiler::ValueKind::GLOBAL, name = "printf" } !compiler::Value,
        ret = ret,
        args = args,
        proto = proto
    } !compiler::InsnCall

    compiler::push_insn(call, state)

    return ret
}

create_function(
    "print",
    [varargs("", null)],
    [builtins::int_],
    *_print,
    null
)

def _length(node: *parser::Node, argsv: [compiler::Value], state: *compiler::State) -> compiler::Value {
    let array = argsv[0]

    let len = compiler::make_local_value(builtins::size_t_, null, state)

    let index = allocate(int, 1)
    index[0] = 0
    let extract = allocate(compiler::Insn)
    (@extract).kind = compiler::InsnKind::EXTRACTVALUE
    (@extract).value.extract_value = {
        index = index,
        value = array,
        ret = len
    } !compiler::InsnExtractValue
    compiler::push_insn(extract, state)
    
    let ret = compiler::make_local_value(builtins::size_t_, null, state)
    let sub = allocate(compiler::Insn)
    (@sub).kind = compiler::InsnKind::SUB
    (@sub).value.arith = {
        ret = ret,
        left = len,
        right = {
            kind = compiler::ValueKind::INT,
            i = 1,
            tpe = builtins::size_t_
        } !compiler::Value
    } !InsnArithmetic
    compiler::push_insn(sub, state)

    return ret
}

create_function(
    "length",
    [param("str", typechecking::array(builtins::char_))],
    [builtins::size_t_],
    *_length,
    null
)

def _allocate_size(node: *parser::Node, argsv: [compiler::Value], state: *compiler::State) -> compiler::Value {
    import_function(state, "malloc")
    let arg = argsv[0]

    let args = allocate(compiler::Value, 1)
    args[0] = arg

    let ret = compiler::make_local_value(typechecking::pointer(null), null, state)
    let call = allocate(compiler::Insn)
    (@call).kind = compiler::InsnKind::CALL
    (@call).value.call = {
        name = { kind = compiler::ValueKind::GLOBAL, name = "malloc" } !compiler::Value,
        ret = ret,
        args = args
    } !compiler::InsnCall
    
    compiler::push_insn(call, state)
    
    return ret
}

create_function(
    "allocate",
    [param("size", builtins::size_t_)],
    [typechecking::pointer(null)],
    *_allocate_size,
    null
)

def _allocate_type(node: *parser::Node, argsv: [compiler::Value], state: *compiler::State) -> compiler::Value {
    import_function(state, "malloc")
    let tpe = argsv[0].value_tpe

    let args = allocate(compiler::Value, 1)
    args[0] = { kind = compiler::ValueKind::INT, i = (@tpe).size, tpe = builtins::size_t_ } !compiler::Value
    
    let call_ret = compiler::make_local_value(typechecking::pointer(null), null, state)
    let call = allocate(compiler::Insn)
    (@call).kind = compiler::InsnKind::CALL
    (@call).value.call = {
        name = { kind = compiler::ValueKind::GLOBAL, name = "malloc" } !compiler::Value,
        ret = call_ret,
        args = args
    } !compiler::InsnCall
    
    compiler::push_insn(call, state)

    let ret = compiler::make_local_value(typechecking::pointer(tpe), null, state)
    let bitcast = allocate(compiler::Insn)
    (@bitcast).kind = compiler::InsnKind::BITCAST
    (@bitcast).value.convert = {
        ret = ret,
        value = call_ret
    }

    compiler::push_insn(bitcast, state)

    return ret
}

def _allocate_type_proto(args: *vector::Vector, kwargs: *vector::Vector, state: *typechecking::State) -> *vector::Vector {
    let rets = vector::make()
    let arg = get_arg(args, kwargs, 0, "tpe")
    let tpe = typechecking::type_lookup(arg, state)
    vector::push(rets, typechecking::pointer(tpe))
    return rets
}

create_function(
    "allocate",
    [param("tpe", typechecking::type_)],
    [typechecking::pointer(null)],
    *_allocate_type,
    *_allocate_type_proto
)

def allocate_make_array(call_ret: compiler::Value, size: compiler::Value, tpe: *typechecking::Type, state: *compiler::State) -> compiler::Value {
    let bitcast_ret = compiler::make_local_value(typechecking::pointer(tpe), null, state)
    let bitcast = allocate(compiler::Insn)
    (@bitcast).kind = compiler::InsnKind::BITCAST
    (@bitcast).value.convert = {
        ret = bitcast_ret,
        value = call_ret
    } !compiler::InsnConvert

    compiler::push_insn(bitcast, state)

    let index1 = allocate(int, 1)
    index1[0] = 1
    let insert1_ret = compiler::make_local_value(typechecking::array(tpe), null, state)
    let insert1 = allocate(compiler::Insn)
    (@insert1).kind = compiler::InsnKind::INSERTVALUE
    (@insert1).value.insert_value = {
        ret = insert1_ret,
        value = { kind = compiler::ValueKind::LOCAL, undef = true, tpe = typechecking::array(tpe) } !compiler::Value,
        element = bitcast_ret,
        index = index1
    } !compiler::InsnInsertValue

    compiler::push_insn(insert1, state)

    let index2 = allocate(int, 1)
    index2[0] = 0
    let insert2_ret = compiler::make_local_value(typechecking::array(tpe), null, state)
    let insert2 = allocate(compiler::Insn)
    (@insert2).kind = compiler::InsnKind::INSERTVALUE
    (@insert2).value.insert_value = {
        ret = insert2_ret,
        value = insert1_ret,
        element = size,
        index = index2
    } !compiler::InsnInsertValue

    compiler::push_insn(insert2, state)

    return insert2_ret
}

def _allocate_array(node: *parser::Node, argsv: [compiler::Value], state: *compiler::State) -> compiler::Value {
    import_function(state, "malloc")
    let tpe = argsv[0].value_tpe
    let size = argsv[1]

    let sizev = compiler::make_local_value(builtins::size_t_, null, state)
    let mul = allocate(compiler::Insn)
    (@mul).kind = compiler::InsnKind::MUL
    (@mul).value.arith = {
        ret = sizev,
        left = size,
        right = { kind = compiler::ValueKind::INT, i = (@tpe).size, tpe = builtins::size_t_ } !compiler::Value
    } !compiler::InsnArithmetic

    compiler::push_insn(mul, state)

    let args = allocate(compiler::Value, 1)
    args[0] = sizev

    let call_ret = compiler::make_local_value(typechecking::pointer(null), null, state)
    let call = allocate(compiler::Insn)
    (@call).kind = compiler::InsnKind::CALL
    (@call).value.call = {
        name = { kind = compiler::ValueKind::GLOBAL, name = "malloc" } !compiler::Value,
        ret = call_ret,
        args = args
    } !compiler::InsnCall

    compiler::push_insn(call, state)

    return allocate_make_array(call_ret, size, tpe, state)
}

def _allocate_array_proto(args: *vector::Vector, kwargs: *vector::Vector, state: *typechecking::State) -> *vector::Vector {
    let rets = vector::make()
    let arg = get_arg(args, kwargs, 0, "tpe")
    let tpe = typechecking::type_lookup(arg, state)
    vector::push(rets, typechecking::array(tpe))
    return rets
}

create_function(
    "allocate",
    [param("tpe", typechecking::type_), param("size", builtins::size_t_)],
    [typechecking::array(null)],
    *_allocate_array,
    *_allocate_array_proto
)

def _reallocate(node: *parser::Node, argsv: [compiler::Value], state: *compiler::State) -> compiler::Value {
    import_function(state, "realloc")
    
    let call_ret = compiler::make_local_value(argsv[0].tpe, null, state)
    let call = allocate(compiler::Insn)
    (@call).kind = compiler::InsnKind::CALL
    (@call).value.call = {
        name = { kind = compiler::ValueKind::GLOBAL, name = "realloc" } !compiler::Value,
        ret = call_ret,
        args = argsv
    } !compiler::InsnCall

    compiler::push_insn(call, state)

    return call_ret
}

def _reallocate_proto(args: *vector::Vector, kwargs: *vector::Vector, state: *typechecking::State) -> *vector::Vector {
    let rets = vector::make()
    let arg = get_arg(args, kwargs, 0, "ptr")
    vector::push(rets, (@arg).tpe)
    return rets
}

//TODO Add an array version of this
create_function(
    "reallocate",
    [param("ptr", typechecking::pointer(null)), param("size", builtins::size_t_)],
    [typechecking::pointer(null)],
    *_reallocate,
    *_reallocate_proto
)

def _free_array(node: *parser::Node, argsv: [compiler::Value], state: *compiler::State) -> compiler::Value {
    import_function(state, "free")
    let arg = argsv[0]

    let ret_extract = compiler::make_local_value(typechecking::pointer((@arg.tpe).tpe), null, state)
    let index = allocate(int, 1)
    index[0] = 1
    let extract = allocate(compiler::Insn)
    (@extract).kind = compiler::InsnKind::EXTRACTVALUE
    (@extract).value.extract_value = {
        ret = ret_extract,
        value = arg,
        index = index
    } !compiler::InsnExtractValue

    compiler::push_insn(extract, state)
    
    let args = allocate(compiler::Value, 1)
    args[0] = ret_extract

    let call = allocate(compiler::Insn)
    (@call).kind = compiler::InsnKind::CALL
    (@call).value.call = {
        name = { kind = compiler::ValueKind::GLOBAL, name = "free" } !compiler::Value,
        ret = compiler::NO_VALUE,
        args = args
    } !compiler::InsnCall

    compiler::push_insn(call, state)

    return compiler::NO_VALUE
}

create_function(
    "free",
    [param("value", typechecking::array(null))],
    [] ![typechecking::Type],
    *_free_array,
    null
)

def _free_pointer(node: *parser::Node, argsv: [compiler::Value], state: *compiler::State) -> compiler::Value {
    import_function(state, "free")
    let arg = argsv[0]

    let args = allocate(compiler::Value, 1)
    args[0] = arg

    let call = allocate(compiler::Insn)
    (@call).kind = compiler::InsnKind::CALL
    (@call).value.call = {
        name = { kind = compiler::ValueKind::GLOBAL, name = "free" } !compiler::Value,
        ret = compiler::NO_VALUE,
        args = args
    } !compiler::InsnCall

    compiler::push_insn(call, state)

    return compiler::NO_VALUE
}

create_function(
    "free",
    [param("value", typechecking::pointer(null))],
    [] ![typechecking::Type],
    *_free_pointer,
    null
)

def _open(node: *parser::Node, argsv: [compiler::Value], state: *compiler::State) -> compiler::Value {
    import_function(state, "fopen")
    convert_to_charp(argsv, state)

    let call_ret = compiler::make_local_value(builtins::File_, null, state)
    let call = allocate(compiler::Insn)
    (@call).kind = compiler::InsnKind::CALL
    (@call).value.call = {
        name = { kind = compiler::ValueKind::GLOBAL, name = "fopen" } !compiler::Value,
        ret = call_ret,
        args = argsv
    } !compiler::InsnCall

    compiler::push_insn(call, state)

    return call_ret
}

create_function(
    "open",
    [param("file", builtins::string_), param("mode", builtins::string_)],
    [builtins::File_],
    *_open,
    null
)

def _close(node: *parser::Node, argsv: [compiler::Value], state: *compiler::State) -> compiler::Value {
    import_function(state, "fclose")

    let call_ret = compiler::make_local_value(builtins::int_, null, state)
    let call = allocate(compiler::Insn)
    (@call).kind = compiler::InsnKind::CALL
    (@call).value.call = {
        name = { kind = compiler::ValueKind::GLOBAL, name = "fclose" } !compiler::Value,
        ret = call_ret,
        args = argsv
    } !compiler::InsnCall

    compiler::push_insn(call, state)

    return call_ret
}

create_function(
    "close",
    [param("fp", builtins::File_)],
    [builtins::int_],
    *_close,
    null
)