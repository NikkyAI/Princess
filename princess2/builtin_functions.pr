import vector
import map
import builtins
import parser
import typechecking
import compiler
import scope

def make_function_type(
    name: string, 
    parameter_t: [typechecking::NamedParameter],
    return_t: [typechecking::Type],
    macro: (*parser::Node, *compiler::State) -> ()) -> *typechecking::Type {
    
    let pars = vector::make()
    for var i in 0..parameter_t.size {
        vector::push(pars, *parameter_t[i])
    }
    let rets = vector::make()
    for var i in 0..return_t.size {
        vector::push(rets, *return_t[i])
    }

    let tpe = allocate(typechecking::Type)
    (@tpe).kind = typechecking::TypeKind::FUNCTION
    (@tpe).name = name
    (@tpe).type_name = name
    (@tpe).parameter_t = pars
    (@tpe).return_t = rets
    (@tpe).macro = macro

    return tpe
}

def create_function(
    name: string, 
    parameter_t: [typechecking::NamedParameter],
    return_t: [typechecking::Type],
    macro: (*parser::Node, *compiler::State) -> ()) {
    
    scope::create_function(
        builtins::builtins, 
        parser::make_identifier([name]), 
        parser::ShareMarker::EXPORT, 
        make_function_type(name, parameter_t, return_t, macro),
        false
    )
}

def import_function(state: *compiler::State, function: string) {
    map::put((@(@state).module).imported, function, map::sentinel)
}

def _assert(node: *parser::Node, state: *compiler::State) {
    import_function(state, "__assert_fail")
    let insn = compiler::walk_expression(vector::peek((@node).value.func_call.args), state)

    let if_false = compiler::make_label(state)
    let if_true = compiler::make_label(state)

    let br = allocate(compiler::Insn)
    (@br).kind = compiler::InsnKind::BR
    (@br).value.br = {
        cond = insn,
        if_true = if_true,
        if_false = if_false
    } !compiler::InsnBr
    compiler::push_insn(br, state)

    compiler::push_label(if_false, state)

    let args = allocate(compiler::Value, 4)
    // TODO I think assertions are supposed to only show the assertion and not the whole line
    args[0] = { kind = compiler::ValueKind::STRING, s = (@node).loc.lines[(@node).loc.line], tpe = builtins::string_ } !compiler::Value
    args[1] = { kind = compiler::ValueKind::STRING, s = (@node).loc.filename, tpe = builtins::string_ } !compiler::Value
    args[2] = { kind = compiler::ValueKind::INT, i = (@node).loc.line, tpe = builtins::int_ } !compiler::Value

    var current_function = "main"
    if (@state).current_function {
        current_function = (@(@state).current_function).name
    }
    args[3] = { kind = compiler::ValueKind::STRING, s = current_function, tpe = builtins::string_} !compiler::Value

    let call = allocate(compiler::Insn)
    (@call).kind = compiler::InsnKind::CALL
    (@call).value.call = {
        name = { kind = compiler::ValueKind::GLOBAL, name = "__assert_fail" } !compiler::Value,
        ret = compiler::NO_VALUE,
        args = args
    } !compiler::InsnCall
    
    compiler::push_insn(call, state)    
    compiler::push_label(if_true, state)

}

create_function(
    "assert", 
    [{"assertion", builtins::bool_} !typechecking::NamedParameter], 
    [] ![typechecking::Type], 
    *_assert
)