import vector
import map
import builtins
import parser
import typechecking
import compiler
import scope

def param(name: string, tpe: *typechecking::Type) -> *typechecking::NamedParameter {
    let named = allocate(typechecking::NamedParameter)
    (@named).name = name
    (@named).value = tpe
    return named
}

def make_function_type(
    name: string, 
    parameter_t: [*typechecking::NamedParameter],
    return_t: [*typechecking::Type],
    macro: (*parser::Node, *compiler::State) -> compiler::Value) -> *typechecking::Type {
    
    let pars = vector::make()
    for var i in 0..parameter_t.size {
        vector::push(pars, parameter_t[i])
    }
    let rets = vector::make()
    for var i in 0..return_t.size {
        vector::push(rets, return_t[i])
    }

    let tpe = allocate(typechecking::Type)
    (@tpe).kind = typechecking::TypeKind::FUNCTION
    (@tpe).name = name
    (@tpe).type_name = name
    (@tpe).parameter_t = pars
    (@tpe).return_t = rets
    (@tpe).macro = macro

    return tpe
}

def create_function(
    name: string, 
    parameter_t: [typechecking::NamedParameter],
    return_t: [typechecking::Type],
    macro: (*parser::Node, *compiler::State) -> compiler::Value) {
    
    scope::create_function(
        builtins::builtins, 
        parser::make_identifier([name]), 
        parser::ShareMarker::EXPORT, 
        make_function_type(name, parameter_t, return_t, macro),
        false
    )
}

def import_function(state: *compiler::State, function: string) {
    map::put((@(@state).module).imported, function, map::sentinel)
}

def create_charp(str: string, state: *compiler::State) -> compiler::Value {
    let tpe = allocate(typechecking::Type)
    (@tpe).kind = typechecking::TypeKind::STATIC_ARRAY
    (@tpe).tpe = builtins::char_
    (@tpe).length = str.size
    (@tpe).size = (@tpe).length * (size_of char)
    (@tpe).align = size_of char

    let value = allocate(compiler::Value)
    @value = {
        kind = compiler::ValueKind::STRING,
        s = str,
        tpe = tpe
    } !compiler::Value

    let global = compiler::make_global_value(tpe, "str", value, state)
    let globalp = allocate(compiler::Value)
    @globalp = global
    let local = compiler::make_local_value(typechecking::pointer(builtins::char_), globalp, state)

    let index = allocate(compiler::Value, 2)
    index[0] = compiler::make_int_value(0)
    index[1] = compiler::make_int_value(0)

    let gep = allocate(compiler::Insn)
    (@gep).kind = compiler::InsnKind::GETELEMENTPTR
    (@gep).value.gep = {
        ret = local,
        tpe = tpe,
        value = global,
        index = index
    } !InsnGetElementPtr

    compiler::push_insn(gep, state)

    return local
}

def _assert(node: *parser::Node, state: *compiler::State) -> compiler::Value {
    import_function(state, "__assert_fail")
    let insn = compiler::walk_expression(vector::peek((@node).value.func_call.args), state)

    let if_false = compiler::make_label(state)
    
    let br = allocate(compiler::Insn)
    (@br).kind = compiler::InsnKind::BR
    (@br).value.br = {
        cond = insn,
        if_false = if_false
    } !compiler::InsnBr
    compiler::push_insn(br, state)

    compiler::push_label(if_false, state)

    let args = allocate(compiler::Value, 4)
    // TODO I think assertions are supposed to only show the assertion and not the whole line
    args[0] = create_charp((@node).loc.lines[(@node).loc.line], state)
    args[1] = create_charp((@node).loc.filename, state)
    args[2] = { kind = compiler::ValueKind::INT, i = (@node).loc.line, tpe = builtins::int_ } !compiler::Value

    var current_function = "main"
    if (@state).current_function {
        current_function = (@(@state).current_function).unmangled
    }
    args[3] = create_charp(current_function, state)

    let call = allocate(compiler::Insn)
    (@call).kind = compiler::InsnKind::CALL
    (@call).value.call = {
        name = { kind = compiler::ValueKind::GLOBAL, name = "__assert_fail" } !compiler::Value,
        ret = compiler::NO_VALUE,
        args = args
    } !compiler::InsnCall
    
    compiler::push_insn(call, state)

    let unreachable = allocate(compiler::Insn)
    (@unreachable).kind = compiler::InsnKind::UNREACHABLE

    compiler::push_insn(unreachable, state)

    let if_true = compiler::make_label(state)
    compiler::push_label(if_true, state)
    (@br).value.br.if_true = if_true

    return compiler::NO_VALUE
}

create_function(
    "assert", 
    [param("assertion", builtins::bool_)],
    // TODO This is ugly...
    [] ![typechecking::Type], 
    *_assert
)