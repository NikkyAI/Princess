import lexer

export type NodeKind = enum {
    PROGRAM
}

export type Node

export type NodeBinaryOp = struct {
    left: *Node
    right: *Node
}

export type NodeUnaryOp = struct {
    right: *Node
}

export type NodeValue = struct #union {
    bin_op: NodeBinaryOp
    un_op: NodeUnaryOp 
}

export type Node = struct {
    kind: NodeKind

    line: int
    column: int

    value: NodeValue
}

type ParseState = struct {
    lines: [string]
    tokens: **lexer::TokenList
}

def skip_whitespace(list: **lexer::TokenList) {
    var tt = (@@list).value.tpe
    while tt == lexer::TokenType::WHITESPACE or tt == lexer::TokenType::COMMENT {
        @list = (@@list).next
        tt = (@@list).value.tpe
    }
}

def pop(state: *ParseState) -> lexer::Token {
    let list = (@state).tokens
    skip_whitespace(list)
    let token = (@@list).value
    @list = (@@list).next
    return token
}

def peek(state: *ParseState) -> lexer::Token {
    let list = (@state).tokens
    skip_whitespace(list)
    return (@@list).value
}

def parse_expression(parse_state: *ParseState) -> *Node {

}

def parse_vardecl(parse_state: *ParseState) -> *Node {

}

def parse_typedecl(parse_state: *ParseState) -> *Node {

}

def parse_if_stmt(parse_state: *ParseState) -> *Node {

}

def parse_t_term(parse_state: *ParseState) {
    let token = peek(parse_state)
    if token.tpe == lexer::TokenType::SEMICOLON or token.tpe == lexer::TokenType::NEW_LINE {
        pop(parse_state)
    } else if token.tpe != lexer::TokenType::EOF and token.tpe != lexer::TokenType::C_BRACE {
        error("Missing statement separator\n")
    }
}

def parse_statement(parse_state: *ParseState) -> *Node {
    let lh = peek(parse_state)
    var node: *Node
    if lh.tpe == lexer::TokenType::K_VAR {
        node = parse_vardecl(list, parse_state)
    } else if lh.tpe == lexer::TokenType::K_TYPE {
        node = parse_typedecl(list, parse_state)
    } else if lh.tpe == lexer::TokenType::K_IF {
        node = parse_if_stmt(list, parse_state)
    } else {
        node = parse_expression(list, parse_state)
    }
    parse_t_term(list, parse_state)
    return node
}

export def parse(list: *lexer::TokenList, lines: [string]) -> *Node {
    var parse_state: ParseState
    parse_state.lines = lines
    parse_state.tokens = *list
    
    while list != null {
        let node = parse_statement(*parse_state)
    }
}