// This file handles all global state related to compiling
// TODO Sorry for the mess of imports, but right now there's no better way

import vector
import util
import buffer
import map

// Contains the scopes for already compiled modules 
export let modules = map::make()
export var include_path: [string]

export var error_count = 0

type scope::Scope
type parser::Node

export type Module = struct {
    filename: string
    scope: *scope::Scope
}

export def compile_file(filename: string, module: string)
export def compile_module(module: *parser::Node) -> *Module
export def find_module_file(module: *parser::Node) -> string

import lexer
import parser
import typechecking
import scope
import compiler
import codegen
import debug
import builtins

export def find_module_file(module: *parser::Node) -> string {
    assert((@module).kind == parser::NodeKind::IDENTIFIER)
    let ident = (@module).value.body
    let path = zero_allocate(char, PATH_MAX)

    let len = vector::length(ident)
    for var i in 0..len {
        var str = @(vector::get(ident, i) !*string)
        concat(path, str)
        if i < len - 1 {
            concat(path, "/")
        }
    }
    for var i in 0..include_path.size {
        let module_path = zero_allocate(char, PATH_MAX)
        concat(module_path, include_path[i])
        concat(module_path, "/", path, ".pr")
        module_path.size = strlen(module_path) + 1
        
        if util::exists(module_path) {
            return module_path
        }
    }
    return ""
}

export def compile_file(filename: string, module: string) {
    let fh = open(filename, "rb")
    if not fh {
        error("File \"", filename, "\" doesn't exist\n")
    } else {
        let buf = util::read_all(fh)
        close(fh)
        let lines = util::split_lines(buf)

        let tokens = lexer::lex(buf)
        free(buf)
        let node = parser::parse(tokens, lines, filename, module)
        //debug::print_node(node)
        let sc = scope::enter_function_scope(builtins::builtins)
        map::put(modules, filename, sc)
        typechecking::typecheck(node, sc, filename, module)       
        let result = compiler::compile(node, filename, module)

        if error_count == 0 {
            codegen::gen(result, filename, module)
        }
    }
}

// name is an identifier
export def compile_module(name: *parser::Node) -> *Module {
    let filename = find_module_file(name)
    let modulename = parser::identifier_to_str(name)
    if length(filename) == 0 {
        return null
    }
    var sc = map::get(modules, filename) !*scope::Scope
    if not sc {
        compile_file(filename, modulename)
        sc = map::get(modules, filename)
    }

    let module = allocate(Module)
    (@module).filename = filename
    (@module).scope = sc
    return module
}