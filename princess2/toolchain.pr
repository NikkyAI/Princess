// This file handles all global state related to compiling
// TODO Sorry for the mess of imports, but right now there's no better way

import vector
import util
import buffer
import map

// Contains the scopes for already compiled modules 
// map of Module
export let modules = map::make()
export var include_path: [string]
export var outfolder = "."
export var error_count = 0
export var outfile = "a.out"

type scope::Scope
type parser::Node
type compiler::Result

export type Module = struct {
    filename: string
    llfile: string
    module: string
    node: *parser::Node
    scope: *scope::Scope
    result: *compiler::Result
    imported: *map::Map
}

export def compile_file(filename: string, module: string)
export def compile_module(module: *parser::Node) -> *Module
export def find_module_file(module: *parser::Node) -> string

import lexer
import parser
import typechecking
import scope
import codegen
import debug
import builtins
import compiler

export def find_module_file(module: *parser::Node) -> string {
    assert((@module).kind == parser::NodeKind::IDENTIFIER)
    let ident = (@module).value.body
    let path = zero_allocate(char, PATH_MAX)

    let len = vector::length(ident)
    for var i in 0..len {
        var str = @(vector::get(ident, i) !*string)
        concat(path, str)
        if i < len - 1 {
            concat(path, "/")
        }
    }
    for var i in 0..include_path.size {
        let module_path = zero_allocate(char, PATH_MAX)
        concat(module_path, include_path[i])
        concat(module_path, "/", path, ".pr")
        module_path.size = strlen(module_path) + 1
        
        if util::exists(module_path) {
            return module_path
        }
    }
    return ""
}

export def compile_file(filename: string, mod: string) {
    let fh = open(filename, "rb")
    if not fh {
        error("File \"", filename, "\" doesn't exist\n")
    } else {
        let buf = util::read_all(fh)
        close(fh)
        let lines = util::split_lines(buf)

        let tokens = lexer::lex(buf)
        free(buf)
        let node = parser::parse(tokens, lines, filename, mod)
        //debug::print_node(node)
        let sc = scope::enter_function_scope(builtins::builtins)
        let module = allocate(Module)
        (@module).filename = filename
        (@module).module = mod
        (@module).node = node
        (@module).scope = sc
        (@module).imported = map::make()

        map::put(modules, filename, module)
        typechecking::typecheck(module)       
        let result = compiler::compile(module)
        (@module).result = result
    }
}

// name is an identifier
export def compile_module(name: *parser::Node) -> *Module {
    let filename = find_module_file(name)
    let modulename = parser::identifier_to_str(name)
    if length(filename) == 0 {
        return null
    }
    var module = map::get(modules, filename) !*Module
    if not module {
        compile_file(filename, modulename)
        module = map::get(modules, filename)
    }

    return module
}

export def compile_main_file(filename: string) {
    compile_file(filename, "main")

    if error_count == 0 {
        let compile_header = buffer::make_buffer()
        buffer::append_str(*compile_header, "clang-12 -S -emit-llvm -o ")
        buffer::append_str(*compile_header, outfolder)
        buffer::append_str(*compile_header, "/princess.ll -x c ../princess.h")
        system(buffer::to_string(*compile_header))

        let link_command = buffer::make_buffer()
        buffer::append_str(*link_command, "llvm-link-12 -S -o ")
        buffer::append_str(*link_command, outfolder)
        buffer::append_str(*link_command, "/out.ll ")
        buffer::append_str(*link_command, outfolder)
        buffer::append_str(*link_command, "/princess.ll ")

        let filenames = map::keys(modules)
        for var i in 0..filenames.size {
            let filename = filenames[i]
            let module = map::get(modules, filename) !*Module
            codegen::gen(module)

            buffer::append_str(*link_command, (@module).llfile)
            buffer::append_char(*link_command, ' ')
        }
        system(buffer::to_string(*link_command))

        let compile_command = buffer::make_buffer()
        buffer::append_str(*compile_command, "clang-12 --output ")
        buffer::append_str(*compile_command, outfile)
        buffer::append_char(*compile_command, ' ')
        buffer::append_str(*compile_command, outfolder)
        buffer::append_str(*compile_command, "/out.ll")

        system(buffer::to_string(*compile_command))
    }
}