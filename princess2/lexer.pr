import buffer
import util

export type TokenType = enum {
    COLON
    COMMA
    SEMICOLON
    ARROW
    NEW_LINE
    O_PAREN
    C_PAREN
    O_BRACE
    C_BRACE
    O_SQUARE
    C_SQUARE
    OP_DEREF
    OP_PTR
    OP_ASSIGN
    OP_ADD
    OP_SUB
    OP_MUL
    OP_DIV
    OP_MOD
    OP_BOR
    OP_BAND
    OP_BXOR
    OP_BNOT
    OP_SHL
    OP_SHR
    OP_INC
    OP_DEC
    OP_EQ
    OP_NEQ
    OP_LEQ
    OP_GEQ
    OP_LE
    OP_GT
    OP_INC_EQ
    OP_DEC_EQ
    OP_ADD_EQ
    OP_SUB_EQ
    OP_MUL_EQ
    OP_DIV_EQ
    OP_MOD_EQ
    OP_OR_EQ
    OP_AND_EQ
    OP_XOR_EQ
    OP_SHL_EQ
    OP_SHR_EQ
    K_TYPE
    K_ENUM
    K_STRUCT
    K_IF
    K_ELSE
    K_NOT
    K_AND
    K_OR
    K_VAR
    K_LET
    K_CONST
    K_WHILE
    K_TRUE
    K_FALSE
    K_NULL
    K_SWITCH
    K_FOR
    K_LOOP
    K_CONTINUE
    K_BREAK
    K_RETURN
    K_UNSIGNED
    K_LABEL
    K_GO_TO
    K_CASE
    K_SIZE_OF
    K_DEF
    K_EXPORT
    K_IMPORT
    K_AS
    K_FROM
    INTEGER
    FLOAT
    STRING
    CHAR
    IDENTIFIER
    ERROR
}

export type Token = struct {
    tpe: TokenType
    line: int
    column: int
    value: *
}

export type TokenList = struct {
    value: Token
    next: *TokenList
}

type Keyword = struct {
    token_type: TokenType
    str: string
}

let keywords = [
    {TokenType::K_TYPE, "type"} !Keyword,
    {TokenType::K_ENUM, "enum"} !Keyword,
    {TokenType::K_STRUCT, "struct"} !Keyword,
    {TokenType::K_IF, "if"} !Keyword,
    {TokenType::K_NOT, "not"} !Keyword,
    {TokenType::K_AND, "and"} !Keyword,
    {TokenType::K_OR, "or"} !Keyword,
    {TokenType::K_VAR, "var"} !Keyword,
    {TokenType::K_LET, "let"} !Keyword,
    {TokenType::K_CONST, "const"} !Keyword,
    {TokenType::K_WHILE, "while"} !Keyword,
    {TokenType::K_TRUE, "true"} !Keyword,
    {TokenType::K_FALSE, "false"} !Keyword,
    {TokenType::K_NULL, "null"} !Keyword,
    {TokenType::K_SWITCH, "switch"} !Keyword,
    {TokenType::K_FOR, "for"} !Keyword,
    {TokenType::K_LOOP, "loop"} !Keyword,
    {TokenType::K_BREAK, "break"} !Keyword,
    {TokenType::K_RETURN, "return"} !Keyword,
    {TokenType::K_UNSIGNED, "unsigned"} !Keyword,
    {TokenType::K_LABEL, "label"} !Keyword,
    {TokenType::K_GO_TO, "go_to"} !Keyword,
    {TokenType::K_CASE, "case"} !Keyword,
    {TokenType::K_SIZE_OF, "size_of"} !Keyword,
    {TokenType::K_DEF, "def"} !Keyword,
    {TokenType::K_EXPORT, "export"} !Keyword,
    {TokenType::K_IMPORT, "import"} !Keyword,
    {TokenType::K_AS, "as"} !Keyword,
    {TokenType::K_FROM, "from"} !Keyword
]

def error_token(s: string, line: int, column: int) -> Token {
    let res = util::copy_string(s)
    return {
        TokenType::ERROR, line, column, res
    } !Token
}

def valid_hex_char(a: char) -> bool {
    return a >= '0' and a <= '9' or a >= 'a' and a <= 'f' or a >= 'A' and a <= 'F'
}

def parse_hex_char(a: char) -> int {
    if a >= '0' and a <= '9' {
        return a - '0'
    } else if a >= 'a' and a <= 'f' {
        return a - 'a' + 10
    } else if a >= 'A' and a <= 'F' {
        return a - 'A' + 10
    }
    return -1
}

def parse_simple_escape_sequence(escape_char: char) -> int {
    if escape_char == 'a' {
        return '\a'
    } else if escape_char == 'b' {
        return '\b'
    } else if escape_char == 'f' {
        return '\f'
    } else if escape_char == 'n' {
        return '\n'
    } else if escape_char == 'r' {
        return '\r'
    } else if escape_char == 't' {
        return '\t'
    } else if escape_char == 'v' {
        return '\v'
    } else if escape_char == '0' {
        return '\0'
    } else if escape_char == '\'' {
        return '\''
    } else if escape_char == '"' {
        return '"'
    } else {
        return -1
    }
}

def parse_string(s: string, i: *int, line: *int, column: *int) -> Token {
    let start_line = @line
    let start_column = @column

    if @i + 1 >= length(s) {
        return error_token("Unexpected end of string", start_line, start_column)
    }
    @i += 1

    var buf = buffer::make_buffer()
    var end_of_string = false
    for var j in @i:length(s):1 {
        @i = j
        let c = s[j]
        if c == '\\' {
            if j + 1 >= length(s) {
                return error_token("Unexpected end of string", start_line, start_column)
            } else {
                @i += 1
                let escape_char = s[j + 1]
                let c = parse_simple_escape_sequence(escape_char)
                if c >= 0 {
                    buffer::append_char(*buf, c !char)
                } else if escape_char == 'x' or escape_char == 'u' or escape_char == 'U' {
                    var count: int
                    if escape_char == 'x' {
                        count = 1
                    } else if escape_char == 'u' {
                        count = 2
                    } else {
                        count = 4
                    }

                    for var v in 0:count:1 {
                        if j + 3 + v >= length(s) {
                            return error_token("Unexpected end of string", start_line, start_column)
                        }
                        @i += 2
                        let e1 = s[j + 2 + v]
                        let e2 = s[j + 3 + v]
                        if not valid_hex_char(e1) or not valid_hex_char(e2) {
                            return error_token("Invalid escape sequence", start_line, start_column)
                        }
                        let esc_char = parse_hex_char(e1) * 0xF + parse_hex_char(e2)
                        buffer::append_char(*buf, esc_char !char)
                    }
                } else {
                    return error_token("Invalid escape sequence", start_line, start_column)
                }
            }
        } else if c == '\n' {
            @line += 1
            @column = 0
            buffer::append_char(*buf, c)
        } else if c == '"' {
            @column += 1
            end_of_string = true
            break
        } else {
            buffer::append_char(*buf, c)
            @column += 1
        }
    }

    if not end_of_string {
        return error_token("Unexpected end of file while parsing string literal", start_line, start_column)
    } else {
        @i += 1
        let str = buffer::to_string(*buf)
        let tok = {
            TokenType::STRING, start_line, start_column, util::copy_string(str)
        } !Token
        free(str)
        return tok
    }
}

def parse_char(s: string, i: *int, line: *int, column: *int) -> Token {
    let start_line = @line
    let start_column = @column

    if @i + 1 >= length(s) {
        return error_token("Unexpected end of character", start_line, start_column)
    }
    @i += 1

    var result: char
    let c = s[@i]
    if c == '\\' {
        if @i + 1 >= length(s) {
            return error_token("Unexpected end of character", start_line, start_column)
        } else {
            @i += 1
            let escape_char = s[@i]
            let c = parse_simple_escape_sequence(escape_char)
            if c >= 0 {
                result = c !char
            } else if escape_char == 'x' {
                if @i + 3 >= length(s) {
                    return error_token("Unexpected end of string", start_line, start_column)
                }
                @i += 2
                let e1 = s[@i - 1]
                let e2 = s[@i]
                if not valid_hex_char(e1) or not valid_hex_char(e2) {
                    return error_token("Invalid escape sequence", start_line, start_column)
                }
                let esc_char = parse_hex_char(e1) * 0xF + parse_hex_char(e2)
                result = esc_char !char
            } else {
                return error_token("Invalid escape sequence", start_line, start_column)
            }
        }
    } else if c == '\n' {
        return error_token("Unexpected new line", start_line, start_column) 
    } else {
        result = c
    }
    
    if @i + 1 < length(s) {
        if s[@i + 1] == '\'' {
            @i += 2
            @column += 2
            var tok = {
                TokenType::CHAR, start_line, start_column, allocate(char)
            } !Token
            @(tok.value !*char) = result
            return tok
        }
    }
    return error_token("Unexpected end of file while parsing character", start_line, start_column)
}

def parse_number(s: string, i: *int, line: *int, column: *int) -> Token {

}

export def lex(s: string) -> *TokenList {
    var line = 0
    var column = 0

    var token_list = allocate(TokenList)
    var head = token_list

    for var i in 0:length(s):1 {
        let c = s[i]
        var token: Token
        if c == ' ' or c == '\t' {
            continue
        } else if c == '"' {
            column += 1
            token = parse_string(s, *i, *line, *column)
        } else if c == '\'' {
            column += 1
            token = parse_char(s, *i, *line, *column)
        } else if c >= '0' and c <= '9' {
            token = parse_number(s, *i, *line, *column)
        } else if c == '\n' {
            token = {
                TokenType::NEW_LINE, line, column, null
            } !Token
            line += 1
            column = -1
        }
        column += 1
        (@token_list).value = token
        (@token_list).next = allocate(TokenList)
        token_list = (@token_list).next
    }

    return head
}