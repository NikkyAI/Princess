export type TokenType = enum {
    COLON
    COMMA
    SEMICOLON
    ARROW
    O_PAREN
    C_PAREN
    O_BRACE
    C_BRACE
    O_SQUARE
    C_SQUARE
    OP_DEREF
    OP_PTR
    OP_ASSIGN
    OP_ADD
    OP_SUB
    OP_MUL
    OP_DIV
    OP_MOD
    OP_BOR
    OP_BAND
    OP_BXOR
    OP_BNOT
    OP_SHL
    OP_SHR
    OP_INC
    OP_DEC
    OP_EQ
    OP_NEQ
    OP_LEQ
    OP_GEQ
    OP_LE
    OP_GT
    OP_INC_EQ
    OP_DEC_EQ
    OP_ADD_EQ
    OP_SUB_EQ
    OP_MUL_EQ
    OP_DIV_EQ
    OP_MOD_EQ
    OP_OR_EQ
    OP_AND_EQ
    OP_XOR_EQ
    OP_SHL_EQ
    OP_SHR_EQ
    K_TYPE
    K_ENUM
    K_STRUCT
    K_IF
    K_ELSE
    K_NOT
    K_AND
    K_OR
    K_VAR
    K_LET
    K_CONST
    K_WHILE
    K_TRUE
    K_FALSE
    K_NULL
    K_SWITCH
    K_FOR
    K_LOOP
    K_CONTINUE
    K_BREAK
    K_RETURN
    K_UNSIGNED
    K_LABEL
    K_GO_TO
    K_CASE
    K_SIZE_OF
    K_DEF
    K_EXPORT
    K_IMPORT
    K_AS
    K_FROM
    INTEGER
    FLOAT
    STRING
    IDENTIFIER
}

export type Token = struct {
    tpe: TokenType
    value: *
}

export type TokenList = struct {
    value: Token
    next: *TokenList
}

type Keyword = struct {
    token: Token
    str: string
}

let keywords = [
    {{TokenType::K_TYPE, null} !Token, "type"} !Keyword,
    {{TokenType::K_ENUM, null} !Token, "enum"} !Keyword,
    {{TokenType::K_STRUCT, null} !Token, "struct"} !Keyword,
    {{TokenType::K_IF, null} !Token, "if"} !Keyword,
    {{TokenType::K_NOT, null} !Token, "not"} !Keyword,
    {{TokenType::K_AND, null} !Token, "and"} !Keyword,
    {{TokenType::K_OR, null} !Token, "or"} !Keyword,
    {{TokenType::K_VAR, null} !Token, "var"} !Keyword,
    {{TokenType::K_LET, null} !Token, "let"} !Keyword,
    {{TokenType::K_CONST, null} !Token, "const"} !Keyword,
    {{TokenType::K_WHILE, null} !Token, "while"} !Keyword,
    {{TokenType::K_TRUE, null} !Token, "true"} !Keyword,
    {{TokenType::K_FALSE, null} !Token, "false"} !Keyword,
    {{TokenType::K_NULL, null} !Token, "null"} !Keyword,
    {{TokenType::K_SWITCH, null} !Token, "switch"} !Keyword,
    {{TokenType::K_FOR, null} !Token, "for"} !Keyword,
    {{TokenType::K_LOOP, null} !Token, "loop"} !Keyword,
    {{TokenType::K_BREAK, null} !Token, "break"} !Keyword,
    {{TokenType::K_RETURN, null} !Token, "return"} !Keyword,
    {{TokenType::K_UNSIGNED, null} !Token, "unsigned"} !Keyword,
    {{TokenType::K_LABEL, null} !Token, "label"} !Keyword,
    {{TokenType::K_GO_TO, null} !Token, "go_to"} !Keyword,
    {{TokenType::K_CASE, null} !Token, "case"} !Keyword,
    {{TokenType::K_SIZE_OF, null} !Token, "size_of"} !Keyword,
    {{TokenType::K_DEF, null} !Token, "def"} !Keyword,
    {{TokenType::K_EXPORT, null} !Token, "export"} !Keyword,
    {{TokenType::K_IMPORT, null} !Token, "import"} !Keyword,
    {{TokenType::K_AS, null} !Token, "as"} !Keyword,
    {{TokenType::K_FROM, null} !Token, "from"} !Keyword
]

def parse_string(s: string, i: int) -> Token {
    var j = i
    loop {
        let c = s[j]
        
        j += 1
    }
}

def parse_char(s: string, i: int) -> Token {
    
}

export def lex(s: string) -> TokenList {
    for var i in 0:length(s):1 {
        let c = s[i]
        var token: Token
        if c == ' ' or c == '\t' {
            continue
        } else if c == '"' {
            token = parse_string(s, i)
        } else if c == '\'' {
            token = parse_char(s, i)
        } else if c >= '0' and c <= '9' {
            
        }
    }
}