import buffer
import util

export type TokenType = enum {
    COLON
    COMMA
    SEMICOLON
    ARROW
    NEW_LINE
    O_PAREN
    C_PAREN
    O_BRACE
    C_BRACE
    O_SQUARE
    C_SQUARE
    OP_DEREF
    OP_PTR
    OP_ASSIGN
    OP_ADD
    OP_SUB
    OP_MUL
    OP_DIV
    OP_MOD
    OP_BOR
    OP_BAND
    OP_BXOR
    OP_BNOT
    OP_SHL
    OP_SHR
    OP_INC
    OP_DEC
    OP_EQ
    OP_NEQ
    OP_LEQ
    OP_GEQ
    OP_LE
    OP_GT
    OP_INC_EQ
    OP_DEC_EQ
    OP_ADD_EQ
    OP_SUB_EQ
    OP_MUL_EQ
    OP_DIV_EQ
    OP_MOD_EQ
    OP_OR_EQ
    OP_AND_EQ
    OP_XOR_EQ
    OP_SHL_EQ
    OP_SHR_EQ
    K_TYPE
    K_ENUM
    K_STRUCT
    K_IF
    K_ELSE
    K_NOT
    K_AND
    K_OR
    K_VAR
    K_LET
    K_CONST
    K_WHILE
    K_TRUE
    K_FALSE
    K_NULL
    K_SWITCH
    K_FOR
    K_LOOP
    K_CONTINUE
    K_BREAK
    K_RETURN
    K_UNSIGNED
    K_LABEL
    K_GO_TO
    K_CASE
    K_SIZE_OF
    K_DEF
    K_EXPORT
    K_IMPORT
    K_AS
    K_FROM
    INTEGER
    FLOAT
    STRING
    CHAR
    IDENTIFIER
    ERROR
}

export type Token = struct {
    tpe: TokenType
    line: int
    column: int
    value: *
}

export type TokenList = struct {
    value: Token
    next: *TokenList
}

type Keyword = struct {
    token_type: TokenType
    str: string
}

let keywords = [
    {TokenType::K_TYPE, "type"} !Keyword,
    {TokenType::K_ENUM, "enum"} !Keyword,
    {TokenType::K_STRUCT, "struct"} !Keyword,
    {TokenType::K_IF, "if"} !Keyword,
    {TokenType::K_NOT, "not"} !Keyword,
    {TokenType::K_AND, "and"} !Keyword,
    {TokenType::K_OR, "or"} !Keyword,
    {TokenType::K_VAR, "var"} !Keyword,
    {TokenType::K_LET, "let"} !Keyword,
    {TokenType::K_CONST, "const"} !Keyword,
    {TokenType::K_WHILE, "while"} !Keyword,
    {TokenType::K_TRUE, "true"} !Keyword,
    {TokenType::K_FALSE, "false"} !Keyword,
    {TokenType::K_NULL, "null"} !Keyword,
    {TokenType::K_SWITCH, "switch"} !Keyword,
    {TokenType::K_FOR, "for"} !Keyword,
    {TokenType::K_LOOP, "loop"} !Keyword,
    {TokenType::K_BREAK, "break"} !Keyword,
    {TokenType::K_RETURN, "return"} !Keyword,
    {TokenType::K_UNSIGNED, "unsigned"} !Keyword,
    {TokenType::K_LABEL, "label"} !Keyword,
    {TokenType::K_GO_TO, "go_to"} !Keyword,
    {TokenType::K_CASE, "case"} !Keyword,
    {TokenType::K_SIZE_OF, "size_of"} !Keyword,
    {TokenType::K_DEF, "def"} !Keyword,
    {TokenType::K_EXPORT, "export"} !Keyword,
    {TokenType::K_IMPORT, "import"} !Keyword,
    {TokenType::K_AS, "as"} !Keyword,
    {TokenType::K_FROM, "from"} !Keyword
]

def error_token(s: string, line: int, column: int) -> Token {
    let res = util::copy_string(s)
    return {
        TokenType::ERROR, line, column, res
    } !Token
}

def valid_hex_char(a: char) -> bool {
    return a >= '0' and a <= '9' or a >= 'a' and a <= 'f' or a >= 'A' and a <= 'F'
}

def parse_hex_char(a: char) -> int {
    if a >= '0' and a <= '9' {
        return a - '0'
    } else if a >= 'a' and a <= 'f' {
        return a - 'a' + 10
    } else if a >= 'A' and a <= 'F' {
        return a - 'A' + 10
    }
    return -1
}

def parse_simple_escape_sequence(escape_char: char) -> int {
    switch escape_char {
        case 'a': return '\a'
        case 'b': return '\b'
        case 'f': return '\f'
        case 'n': return '\n'
        case 'r': return '\r'
        case 't': return '\t'
        case 'v': return '\v'
        case '0': return '\0'
        case '"': return '"'
        case '\'': return '\''
        case '\\': return '\\'
    }
    return -1
}

def next_char(s: string, i: *int, line: *int, column: *int) -> char {
    @i += 1
    if @i >= length(s) {
        return 0x1A !char
    } else {
        let c = s[@i]
        if c == '\n' {
            @line += 1
            @column = 0
        }
        return c
    }
}

def parse_string(s: string, i: *int, line: *int, column: *int) -> Token {
    let start_line = @line
    let start_column = @column

    var buf = buffer::make_buffer()
    var end_of_string = false
    while @i < length(s) {
        let c = next_char(s, i, line, column)
        if c == '\\' {
            let escape_char = next_char(s, i, line, column)
            let c = parse_simple_escape_sequence(escape_char)
            if c >= 0 {
                buffer::append_char(*buf, c !char)
            } else if escape_char == 'x' or escape_char == 'u' or escape_char == 'U' {

                var count: int
                if escape_char == 'x' {
                    count = 1
                } else if escape_char == 'u' {
                    count = 2
                } else {
                    count = 4
                }

                var code_point: long = 0
                for var v in 0:count:1 {
                    let e1 = next_char(s, i, line, column)
                    let e2 = next_char(s, i, line, column)

                    if not valid_hex_char(e1) or not valid_hex_char(e2) {
                        return error_token("Invalid escape sequence", start_line, start_column)
                    }
                    let esc_char = parse_hex_char(e1) << 4 | parse_hex_char(e2)
                    code_point = code_point << 8 | esc_char
                }
                if count == 1 {
                    buffer::append_char(*buf, code_point !char)
                } else {
                    if code_point <= 0x007F {
                        buffer::append_char(*buf, code_point !char)
                    } else if code_point <= 0x07FF {
                        buffer::append_char(*buf, ((code_point >> 6) | 0b11000000) !char)
                        buffer::append_char(*buf, (code_point & 0b00111111 | 0b10000000) !char)
                    } else if code_point <= 0xFFFF {
                        buffer::append_char(*buf, ((code_point >> 12) | 0b11100000) !char)
                        buffer::append_char(*buf, ((code_point >> 6 & 0b00111111) | 0b10000000) !char)
                        buffer::append_char(*buf, (code_point & 0b00111111 | 0b10000000) !char)
                    } else if code_point <= 0x10FFFF {
                        buffer::append_char(*buf, ((code_point >> 18) | 0b11110000) !char)
                        buffer::append_char(*buf, ((code_point >> 12 & 0b00111111) | 0b10000000) !char)
                        buffer::append_char(*buf, ((code_point >> 6 & 0b00111111) | 0b10000000) !char)
                        buffer::append_char(*buf, (code_point & 0b00111111 | 0b10000000) !char)
                    } else {
                        return error_token("Invalid unicode sequence", start_line, start_column)
                    }
                }
            } else {
                return error_token("Invalid escape sequence", start_line, start_column)
            }
        } else if c == '"' {
            end_of_string = true
            break
        } else {
            buffer::append_char(*buf, c)
        }
    }

    if not end_of_string {
        return error_token("Unexpected end of file while parsing string literal", start_line, start_column)
    } else {
        next_char(s, i, line, column)
        let str = buffer::to_string(*buf)
        let tok = {
            TokenType::STRING, start_line, start_column, util::copy_string(str)
        } !Token
        free(str)
        return tok
    }
}

def parse_char(s: string, i: *int, line: *int, column: *int) -> Token {
    let start_line = @line
    let start_column = @column

    var result: char
    let c = next_char(s, i, line, column)
    if c == '\\' {
        let escape_char = next_char(s, i, line, column)
        let c = parse_simple_escape_sequence(escape_char)
        if c >= 0 {
            result = c !char
        } else if escape_char == 'x' {            
            let e1 = next_char(s, i, line, column)
            let e2 = next_char(s, i, line, column)
            if not valid_hex_char(e1) or not valid_hex_char(e2) {
                return error_token("Invalid escape sequence", start_line, start_column)
            }
            let esc_char = parse_hex_char(e1) << 4 | parse_hex_char(e2)
            result = esc_char !char
        } else {
            return error_token("Invalid escape sequence", start_line, start_column)
        }
    } else if c == '\n' {
        return error_token("Unexpected new line", start_line, start_column) 
    } else {
        result = c
    }
    
    if next_char(s, i, line, column) == '\'' {
        next_char(s, i, line, column)
        var tok = {
            TokenType::CHAR, start_line, start_column, allocate(char)
        } !Token
        @(tok.value !*char) = result
        return tok
    }

    return error_token("Unexpected end of file while parsing character", start_line, start_column)
}

def parse_number(s: string, i: *int, line: *int, column: *int) -> Token {

}

export def lex(s: string) -> *TokenList {
    var line = 0
    var column = 0

    var token_list = allocate(TokenList)
    var head = token_list

    for var i in 0:length(s):1 {
        let c = s[i]
        var token: Token
        if c == ' ' or c == '\t' {
            continue
        } else if c == '"' {
            token = parse_string(s, *i, *line, *column)
        } else if c == '\'' {
            token = parse_char(s, *i, *line, *column)
        } else if c >= '0' and c <= '9' {
            token = parse_number(s, *i, *line, *column)
        } else if c == '\n' {
            token = {
                TokenType::NEW_LINE, line, column, null
            } !Token
            line += 1
            column = -1
        }
        column += 1
        (@token_list).value = token
        (@token_list).next = allocate(TokenList)
        token_list = (@token_list).next
    }

    return head
}