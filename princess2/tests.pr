import lexer
import buffer
import util
import parser
import vector
import debug

def next_value(list: **lexer::TokenList, tpe: lexer::TokenType) -> lexer::Token {
    let value = (@@list).value
    if value.tpe == lexer::TokenType::ERROR {
        error("Error: ", value.value.str, "\n")
        exit(-1)
    }
    assert(value.tpe == tpe)
    @list = (@@list).next
    return value
}

def next_char(list: **lexer::TokenList) -> char {
    return next_value(list, lexer::TokenType::CHAR).value.ch
}

def next_long(list: **lexer::TokenList) -> uint64 {
    return next_value(list, lexer::TokenType::INTEGER).value.i
}

def next_double(list: **lexer::TokenList) -> double {
    return next_value(list, lexer::TokenType::FLOAT).value.f
}

def next_string(list: **lexer::TokenList) -> string {
    return next_value(list, lexer::TokenType::STRING).value.str
}

def next_identifier(list: **lexer::TokenList) -> string {
    return next_value(list, lexer::TokenType::IDENTIFIER).value.str
}

def next_comment(list: **lexer::TokenList) -> string {
    return next_value(list, lexer::TokenType::COMMENT).value.str
}

def next_pragma(list: **lexer::TokenList) -> string {
    return next_value(list, lexer::TokenType::PRAGMA).value.str
}

def next_error(list: **lexer::TokenList) -> string {
    let value = (@@list).value
    if value.tpe != lexer::TokenType::ERROR {
        error("Error: Invalid token type: ", value.tpe, "\n")
        exit(-1)
    }
    let s = value.value.str
    @list = (@@list).next
    return s
}

def test_float_literal {
    print(">Test float literal... ")

    var str = "10.5"
    var result = lexer::lex(str)
    assert(next_double(*result) == 10.5)

    str = ".5"
    result = lexer::lex(str)
    assert(next_double(*result) == .5)

    str = "10."
    result = lexer::lex(str)
    assert(next_double(*result) == 10.)

    str = "10E10"
    result = lexer::lex(str)
    assert(next_double(*result) == 10E10) 

    str = "10.e10"
    result = lexer::lex(str)
    assert(next_double(*result) == 10.e10) 

    /*str = "10E-4"
    result = lexer::lex(str)
    assert(next_double(*result) == 10E-4)*/ // TODO This doesnt work

    str = "10E+10"
    result = lexer::lex(str)
    assert(next_double(*result) == 10E+10) 
    
    print("OK\n")
}

def test_int_literal {
    print(">Test int literal... ")

    var str = "156"
    var result = lexer::lex(str)
    assert(next_long(*result) == 156)

    str = "0b100100"
    result = lexer::lex(str)
    assert(next_long(*result) == 0b100100)

    str = "0xDEADBABE"
    result = lexer::lex(str)
    assert(next_long(*result) == 0xDEADBABE)

    str = "0o172"
    result = lexer::lex(str)
    assert(next_long(*result) == 0o172)

    print("OK\n")
}

def test_char_literal {
    print(">Test char literal... ")

    var str = "'A'"
    var result = lexer::lex(str)
    assert(next_char(*result) == 'A')

    str = "'A' 'B'"
    result = lexer::lex(str)
    assert(next_char(*result) == 'A')
    next_value(*result, lexer::TokenType::WHITESPACE)
    assert(next_char(*result) == 'B')

    str = "'\\a'"
    result = lexer::lex(str)
    assert(next_char(*result) == '\a')

    str = "'\\xFF'"
    result = lexer::lex(str)
    assert(next_char(*result) == '\xFF')

    print("OK\n")
}

def test_char_literal_error {
    print(">Test char literal error... ")

    var str = "'A"
    var result = lexer::lex(str)
    assert(next_error(*result) == "Unexpected end of file while parsing character\n")

    str = "'\\d'"
    result = lexer::lex(str)
    assert(next_error(*result) == "Invalid escape sequence\n")

    str = "'\\x"
    result = lexer::lex(str)
    assert(next_error(*result) == "Invalid escape sequence\n")

    //TODO Test more corner cases

    print("OK\n")
}

def test_string_literal {
    print(">Test string literal... ")

    var str = "\"this is a test\""
    var result = lexer::lex(str)
    assert(next_string(*result) == "this is a test")

    str = "\"test\" \"more\""
    result = lexer::lex(str)
    assert(next_string(*result) == "test")
    next_value(*result, lexer::TokenType::WHITESPACE)
    assert(next_string(*result) == "more")

    str = "\"\\a\\b\\f\\n\\r\\t\\v\\'\\\"\\\\\""
    result = lexer::lex(str)
    assert(next_string(*result) == "\a\b\f\n\r\t\v\'\"\\")

    str = "\"\\xFF\""
    result = lexer::lex(str)
    assert(next_string(*result) == "\xFF")

    str = "\"\\u01FF\""
    result = lexer::lex(str)
    assert(next_string(*result) == "\u01FF")

    str = "\"\\u88AA\""
    result = lexer::lex(str)
    assert(next_string(*result) == "\u88AA")

    str = "\"\\U0010FFFF\""
    result = lexer::lex(str)
    assert(next_string(*result) == "\U0010FFFF")

    str = "\"\n\n\""
    result = lexer::lex(str)
    assert(next_string(*result) == "\n\n")

    print("OK\n")
}

def test_string_literal_error {
    print(">Test string literal error... ")

    var str = "\"this is a test"
    var result = lexer::lex(str)
    assert(next_error(*result) == "Unexpected end of file while parsing string literal\n")

    str = "\"test \\d \""
    result = lexer::lex(str)
    assert(next_error(*result) == "Invalid escape sequence\n")

    str = "\"\\UGHRR\""
    result = lexer::lex(str)
    assert(next_error(*result) == "Invalid escape sequence\n")

    str = "\"\\UFF0000FF\""
    result = lexer::lex(str)
    assert(next_error(*result) == "Invalid unicode sequence\n")

    print("OK\n")
}

def test_identifier {
    print(">Test identifier... ")

    var str = "foo_bar"
    var result = lexer::lex(str)
    assert(next_identifier(*result) == "foo_bar")

    str = "foo bar"
    result = lexer::lex(str)
    assert(next_identifier(*result) == "foo")
    next_value(*result, lexer::TokenType::WHITESPACE)
    assert(next_identifier(*result) == "bar")

    str = "def foo"
    result = lexer::lex(str)
    next_value(*result, lexer::TokenType::K_DEF)
    next_value(*result, lexer::TokenType::WHITESPACE)
    assert(next_identifier(*result) == "foo")

    print("OK\n")
}

def test_pragma {
    print(">Test pragma... ")

    var str = "#union"
    var result = lexer::lex(str)
    assert(next_pragma(*result) == "#union")

    str = "##compiler_dep"
    result = lexer::lex(str)
    assert(next_pragma(*result) == "##compiler_dep")

    print("OK\n")
}

def test_comment {
    print(">Test comment... ")

    var str = "//This is a test"
    var result = lexer::lex(str)
    assert(next_comment(*result) == "//This is a test")

    str = "//This
           //Test
    "
    result = lexer::lex(str)
    assert(next_comment(*result) == "//This")
    next_value(*result, lexer::TokenType::NEW_LINE)
    next_value(*result, lexer::TokenType::WHITESPACE)
    assert(next_comment(*result) == "//Test")

    str = "/*This*/"
    result = lexer::lex(str)
    assert(next_comment(*result) == "/*This*/")

    str = "/*Nested/*Comment*/*/"
    result = lexer::lex(str)
    assert(next_comment(*result) == "/*Nested/*Comment*/*/")

    print("OK\n")
}

def test_symbols {
    print(">Test symbols... ")

    var str = "foo+bar"
    var result = lexer::lex(str)
    assert(next_identifier(*result) == "foo")
    next_value(*result, lexer::TokenType::OP_ADD)
    assert(next_identifier(*result) == "bar")

    str = "1..2"
    result = lexer::lex(str)
    assert(next_long(*result) == 1)
    next_value(*result, lexer::TokenType::OP_RANGE)
    assert(next_long(*result) == 2)

    // TODO add more tests

    print("OK\n")
}

def test_complex {
    print(">Test complex example... ")

    var str = "
        type T = struct {
            a: int
            b: string
        }

        def main(a: int, b: unsigned word) -> T {
            print(\"A: \", a, \" B: \", b)
            var t: T = {
                a = 0, b = \"Test string\"
            } !T
        }
    "
    var result = lexer::lex(str)
    //lexer::print_token_list(result)

    print("OK\n")
}

def test_lexer {
    print("Running tests on Lexer...\n")
    test_string_literal()
    test_string_literal_error()
    test_char_literal()
    test_char_literal_error()
    test_int_literal()
    test_float_literal()
    test_identifier()
    test_pragma()
    test_comment()
    test_symbols()
    test_complex()
}

def test_buffer {
    print("Running tests on Buffer...\n")
    var str = "this is a test"
    var buf = buffer::make_buffer()
    buffer::append_str(*buf, str)
    var res = buffer::to_string(*buf)
    assert(res == str)
    buffer::append_char(*buf, 't')
    res = buffer::to_string(*buf)
    assert(res == "this is a testt")
}

def test_vector {
    print("Running tests on Vector...\n")
    var vec = vector::make()
    let i1 = allocate(int); @i1 = 0
    vector::push(vec, i1)
    let i2 = allocate(int); @i2 = 1
    vector::push(vec, i2)
    let i3 = allocate(int); @i3 = 2
    vector::push(vec, i3)

    assert(@(vector::get(vec, 0) !*int) == 0)
    assert(@(vector::get(vec, 1) !*int) == 1)
    assert(@(vector::get(vec, 2) !*int) == 2)

    let i4 = allocate(int); @i4 = 3
    vector::set(vec, 0, i4)

    assert(@(vector::get(vec, 0) !*int) == 3)
}

def test_split_lines {
    print(">Test split lines... ")

    var str = "this\nis\na\ntest"
    var res = util::split_lines(str)

    assert(res.size == 4)
    assert(res[0] == "this")
    assert(res[1] == "is")
    assert(res[2] == "a")
    assert(res[3] == "test")

    str = "this is a test"
    res = util::split_lines(str)

    assert(res.size == 1)
    assert(res[0] == "this is a test")

    str = "this\r\nis\r\na\r\ntest"
    res = util::split_lines(str)
    
    assert(res.size == 4)
    assert(res[0] == "this")
    assert(res[1] == "is")
    assert(res[2] == "a")
    assert(res[3] == "test")

    print("OK\n")
}

def test_util {
    print("Running tests on Util...\n")
    test_split_lines()
}

export var print_ast = false

def parse(s: string) -> *parser::Node {
    let tokens = lexer::lex(s)
    let lines = util::split_lines(s)
    let node = parser::parse(tokens, lines)
    
    if print_ast {
        print("\n")
        print(s)
        print("\n")
        debug::print_node(node)
    }
    
    return node
}

def test_operators {
    print(">Test operators... ")
    var str = "1 + 2"
    var res = parse(str)
    assert((@res).kind == parser::NodeKind::PROGRAM)
    var val = @(vector::get((@res).value.body, 0) !*parser::Node)
    assert(val.kind == parser::NodeKind::ADD)
    var left = @val.value.bin_op.left
    var right = @val.value.bin_op.right
    assert(left.kind == parser::NodeKind::INTEGER)
    assert(right.kind == parser::NodeKind::INTEGER)
    assert(left.value.i == 1)
    assert(right.value.i == 2)

    str = "1 + 2 * 3 - 5"
    res = parse(str)

    str = "1 << 5 + 0xFF >> 1"
    res = parse(str)

    str = "0 and 2 or 5"
    res = parse(str)

    str = "a == 5 and b != 6 or c <= 10 and d >= 5"
    res = parse(str)

    str = "10 > a > 5"
    res = parse(str)

    str = "not true"
    res = parse(str)

    str = "not not true"
    res = parse(str)

    str = "*foo and @bar and ~foo"
    res = parse(str)

    str = "+foo and -foo"
    res = parse(str)

    str = "5 !int"
    res = parse(str)

    str = "5 * 5 !int"
    res = parse(str)

    str = "foo[1 + 5][1]"
    res = parse(str)

    str = "foo.bar.baz"
    res = parse(str)

    str = "a..b"
    res = parse(str)
    
    str = "a..=b..c"
    res = parse(str)

    print("OK\n")
}

def test_vardecl {
    print(">Test vardecl... ")

    var str = "var foo = 5"
    var res = parse(str)

    str = "const foo = 5"
    res = parse(str)

    str = "var foo, bar = 1, 2"
    res = parse(str)

    str = "let foo, (bar) = 1, 2"
    res = parse(str)

    str = "export var foo"
    res = parse(str)

    str = "export import var bar"
    res = parse(str)

    str = "var foo: int, bar: int"
    res = parse(str)

    str = "export let foo: int = 5"
    res = parse(str)
    
    print("OK\n")
}

def test_typedecl {
    print(">Test typedecl... ")

    var str = "type A"
    var res = parse(str)

    str = "type A, B"
    res = parse(str)

    str = "type A = Foo"
    res = parse(str)

    str = "type A = unsigned word(16)"
    res = parse(str)

    str = "type A, B = int, float"
    res = parse(str)

    print("OK\n")
}

def test_simple_types {
    print(">Test simple types... ")

    var str = "(type int)"
    var res = parse(str)

    str = "(type word(16))"
    res = parse(str)

    str = "(type unsigned word(32))"
    res = parse(str)

    print("OK\n")
}

def test_function_types {
    print(">Test function types... ")

    var str = "(type T -> F)"
    var res = parse(str)

    str = "(type ->)"
    res = parse(str)

    str = "(type (->))"
    res = parse(str)

    str = "(type A -> B -> C)"
    res = parse(str)

    str = "(type () -> ())"
    res = parse(str)

    str = "(type (A, B) -> (C, D))"
    res = parse(str)

    print("OK\n")
}

def test_pointer_types {
    print(">Test pointer types... ")

    var str = "(type *A)"
    var res = parse(str)

    str = "(type **A)"
    res = parse(str)

    str = "(type &A)"
    res = parse(str)

    str = "(type &&**A)"
    res = parse(str)

    str = "(type *)"
    res = parse(str)

    str = "(type &*)"
    res = parse(str)

    str = "(type *let A)"
    res = parse(str)

    str = "(type *var A)"
    res = parse(str)

    str = "(type &let A)"
    res = parse(str)

    str = "(type &var A)"
    res = parse(str)

    print("OK\n")
}

def test_array_types {
    print(">Test array types... ")

    var str = "(type [T])"
    var res = parse(str)

    str = "(type [5; T])"
    res = parse(str)

    str = "(type [?; T])"
    res = parse(str)

    str = "(type [let T])"
    res = parse(str)

    str = "(type [5; var T])"
    res = parse(str)

    str = "(type [5; [T]])"
    res = parse(str)

    str = "(type [5; var [let T]])"
    res = parse(str)

    print("OK\n")
}

def test_func_call {
    print(">Test function call... ")

    var str = "really::long::path::foo()"
    var res = parse(str)

    str = "foo(bar, baz)"
    res = parse(str)

    str = "foo(bar, baz = 20)"
    res = parse(str)

    str = "foo(0)(1)"
    res = parse(str)

    print("OK\n")
}

def test_assign_op {
    print(">Test assign op... ")

    var str = "a = b"
    var res = parse(str)

    str = "a, b = c, d"
    res = parse(str)

    str = "a, b = c, d = e, f"
    res = parse(str)

    str = "a += 2"
    res = parse(str)

    str = "a *= 2 %= 3"
    res = parse(str)

    str = "a ++= 2 = b += 2"
    res = parse(str)

    print("OK\n")
}

def test_statements {
    print(">Test statements... ")

    var str = "
        var foo = 20
        foo += 10
        print(foo)
    "
    var res = parse(str)

    str = "
        if foo == null {
            print(\"Hello World\")
        }
        end
    "
    res = parse(str)

    str = "
        if true {
            // Do something
        } else {
            // Do something else
        }
        end
    "
    res = parse(str)

    str = "
        if true {
            print(0)
        } else if false {
            print(0)
            print(1)
        } else if true {
            // Do more
        } else {
            // Or else...!
        }
        end
    "
    res = parse(str)

    str = "
        if true {
            print(0)
        } else if false {
            print(1)
        }
        end
    "
    res = parse(str)

    str = "
        if must {
            if go {
                if deeper {

                }
            }
        }
        end
    "
    res = parse(str)

    str = "
        if false
        {
            // on new line
        }
        else
        {
            // Very ugly
        }
        end
    "
    res = parse(str)

    str = "
        loop {
            nop()
            break
            continue
        }
        end
    "
    res = parse(str)

    str = "
        for var i in 0..10 {
            nop()
        }
        end
    "
    res = parse(str)

    str = "
        var i = 0
        for i in 0..10 {
            nop()
        }
        end
    "
    res = parse(str)

    str = "
        while true {
            nop()
        }
        end
    "
    res = parse(str)

    str = "return"
    res = parse(str)

    str = "
        return 1, 2, 3
    "
    res = parse(str)

    str = "
        return 1,
            2
    "
    res = parse(str)

    print("OK\n")
}

def test_struct {
    print(">Test struct... ")

    var str = "
        type T = struct {
            a: int
        }
    "
    var res = parse(str)

    str = "
        type T = struct {
            a: int
            b: struct {
                a: int
            }
        }
    "
    res = parse(str)

    str = "
        type T = struct #union {
            a: int
            b: long
        }
    "
    res = parse(str)

    str = "
        type T = struct {
            a: int
            struct #union {
                a: int
                b: long
            }
        }
    "
    res = parse(str)

    print("OK\n")
}

def test_import {
    print(">Test import... ")

    var str = "import module"
    var res = parse(str)

    str = "import module as mod"
    res = parse(str)

    str = "import a as foo, bar"
    res = parse(str)

    str = "
        import 
            Module as mod,
            foo,
            bar as baz
    "
    res = parse(str)

    print("OK\n")
}

def test_enum {
    print(">Test enum... ")

    var str = "
        type T = enum {
            FOO
            BAR
            BAZ
        }
    "
    var res = parse(str)

    str = "
        type T = enum {
            FOO = 10
            BAR
        }
    "
    res = parse(str)

    str = "
        type T = enum: long {
            FOO; BAR
        }
    "
    res = parse(str)

    print("OK\n")
}

def test_switch_stmt {
    print(">Test switch statement... ")

    var str = "
        switch value {}
    "
    var res = parse(str)

    str = "
        switch value {
            case 1: one
            case 2: two
            case: default
        }
    "
    res = parse(str)

    str = "
        switch value {
            case 1:
                print(foo)
                print(bar)
            case 2:
                print(bar)
                print(foo)
        }
    "
    res = parse(str)

    print("OK\n")
}

def test_parser {
    print("Running tests on Parser...\n")
    test_operators()
    test_simple_types()
    test_function_types()
    test_pointer_types()
    test_array_types()
    test_vardecl()
    test_typedecl()
    test_func_call()
    test_assign_op()
    test_statements()
    test_struct()
    test_import()
    test_enum()
    test_switch_stmt()
}

export def run_test_suite {
    test_buffer()
    test_lexer()
    test_util()
    test_vector()
    test_parser()
}