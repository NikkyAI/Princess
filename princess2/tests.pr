import lexer
import buffer
import util
import parser
import vector

def next_value(list: **lexer::TokenList, tpe: lexer::TokenType) -> lexer::Token {
    let value = (@@list).value
    if value.tpe == lexer::TokenType::ERROR {
        error("Error: ", value.value.str, "\n")
        exit(-1)
    }
    assert(value.tpe == tpe)
    @list = (@@list).next
    return value
}

def next_char(list: **lexer::TokenList) -> char {
    return next_value(list, lexer::TokenType::CHAR).value.ch
}

def next_long(list: **lexer::TokenList) -> uint64 {
    return next_value(list, lexer::TokenType::INTEGER).value.i
}

def next_double(list: **lexer::TokenList) -> double {
    return next_value(list, lexer::TokenType::FLOAT).value.f
}

def next_string(list: **lexer::TokenList) -> string {
    return next_value(list, lexer::TokenType::STRING).value.str
}

def next_identifier(list: **lexer::TokenList) -> string {
    return next_value(list, lexer::TokenType::IDENTIFIER).value.str
}

def next_comment(list: **lexer::TokenList) -> string {
    return next_value(list, lexer::TokenType::COMMENT).value.str
}

def next_pragma(list: **lexer::TokenList) -> string {
    return next_value(list, lexer::TokenType::PRAGMA).value.str
}

def next_error(list: **lexer::TokenList) -> string {
    let value = (@@list).value
    if value.tpe != lexer::TokenType::ERROR {
        error("Error: Invalid token type: ", value.tpe, "\n")
        exit(-1)
    }
    let s = value.value.str
    @list = (@@list).next
    return s
}

def test_float_literal {
    print(">Test float literal... ")

    var str = "10.5"
    var result = lexer::lex(str)
    assert(next_double(*result) == 10.5)

    str = ".5"
    result = lexer::lex(str)
    assert(next_double(*result) == .5)

    str = "10."
    result = lexer::lex(str)
    assert(next_double(*result) == 10.)

    str = "10E10"
    result = lexer::lex(str)
    assert(next_double(*result) == 10E10) 

    str = "10.e10"
    result = lexer::lex(str)
    assert(next_double(*result) == 10.e10) 

    /*str = "10E-4"
    result = lexer::lex(str)
    assert(next_double(*result) == 10E-4)*/ // TODO This doesnt work

    str = "10E+10"
    result = lexer::lex(str)
    assert(next_double(*result) == 10E+10) 
    
    print("OK\n")
}

def test_int_literal {
    print(">Test int literal... ")

    var str = "156"
    var result = lexer::lex(str)
    assert(next_long(*result) == 156)

    str = "0b100100"
    result = lexer::lex(str)
    assert(next_long(*result) == 0b100100)

    str = "0xDEADBABE"
    result = lexer::lex(str)
    assert(next_long(*result) == 0xDEADBABE)

    str = "0o172"
    result = lexer::lex(str)
    assert(next_long(*result) == 0o172)

    print("OK\n")
}

def test_char_literal {
    print(">Test char literal... ")

    var str = "'A'"
    var result = lexer::lex(str)
    assert(next_char(*result) == 'A')

    str = "'A' 'B'"
    result = lexer::lex(str)
    assert(next_char(*result) == 'A')
    next_value(*result, lexer::TokenType::WHITESPACE)
    assert(next_char(*result) == 'B')

    str = "'\\a'"
    result = lexer::lex(str)
    assert(next_char(*result) == '\a')

    str = "'\\xFF'"
    result = lexer::lex(str)
    assert(next_char(*result) == '\xFF')

    print("OK\n")
}

def test_char_literal_error {
    print(">Test char literal error... ")

    var str = "'A"
    var result = lexer::lex(str)
    assert(next_error(*result) == "Unexpected end of file while parsing character")

    str = "'\\d'"
    result = lexer::lex(str)
    assert(next_error(*result) == "Invalid escape sequence")

    str = "'\\x"
    result = lexer::lex(str)
    assert(next_error(*result) == "Invalid escape sequence")

    //TODO Test more corner cases

    print("OK\n")
}

def test_string_literal {
    print(">Test string literal... ")

    var str = "\"this is a test\""
    var result = lexer::lex(str)
    assert(next_string(*result) == "this is a test")

    str = "\"test\" \"more\""
    result = lexer::lex(str)
    assert(next_string(*result) == "test")
    next_value(*result, lexer::TokenType::WHITESPACE)
    assert(next_string(*result) == "more")

    str = "\"\\a\\b\\f\\n\\r\\t\\v\\'\\\"\\\\\""
    result = lexer::lex(str)
    assert(next_string(*result) == "\a\b\f\n\r\t\v\'\"\\")

    str = "\"\\xFF\""
    result = lexer::lex(str)
    assert(next_string(*result) == "\xFF")

    str = "\"\\u01FF\""
    result = lexer::lex(str)
    assert(next_string(*result) == "\u01FF")

    str = "\"\\u88AA\""
    result = lexer::lex(str)
    assert(next_string(*result) == "\u88AA")

    str = "\"\\U0010FFFF\""
    result = lexer::lex(str)
    assert(next_string(*result) == "\U0010FFFF")

    str = "\"\n\n\""
    result = lexer::lex(str)
    assert(next_string(*result) == "\n\n")

    print("OK\n")
}

def test_string_literal_error {
    print(">Test string literal error... ")

    var str = "\"this is a test"
    var result = lexer::lex(str)
    assert(next_error(*result) == "Unexpected end of file while parsing string literal")

    str = "\"test \\d \""
    result = lexer::lex(str)
    assert(next_error(*result) == "Invalid escape sequence")

    str = "\"\\UGHRR\""
    result = lexer::lex(str)
    assert(next_error(*result) == "Invalid escape sequence")

    str = "\"\\UFF0000FF\""
    result = lexer::lex(str)
    assert(next_error(*result) == "Invalid unicode sequence")

    print("OK\n")
}

def test_identifier {
    print(">Test identifier... ")

    var str = "foo_bar"
    var result = lexer::lex(str)
    assert(next_identifier(*result) == "foo_bar")

    str = "foo bar"
    result = lexer::lex(str)
    assert(next_identifier(*result) == "foo")
    next_value(*result, lexer::TokenType::WHITESPACE)
    assert(next_identifier(*result) == "bar")

    str = "def foo"
    result = lexer::lex(str)
    next_value(*result, lexer::TokenType::K_DEF)
    next_value(*result, lexer::TokenType::WHITESPACE)
    assert(next_identifier(*result) == "foo")

    print("OK\n")
}

def test_pragma {
    print(">Test pragma... ")

    var str = "#union"
    var result = lexer::lex(str)
    assert(next_pragma(*result) == "#union")

    str = "##compiler_dep"
    result = lexer::lex(str)
    assert(next_pragma(*result) == "##compiler_dep")

    print("OK\n")
}

def test_comment {
    print(">Test comment... ")

    var str = "//This is a test"
    var result = lexer::lex(str)
    assert(next_comment(*result) == "//This is a test")

    str = "//This
           //Test
    "
    result = lexer::lex(str)
    assert(next_comment(*result) == "//This")
    next_value(*result, lexer::TokenType::NEW_LINE)
    next_value(*result, lexer::TokenType::WHITESPACE)
    assert(next_comment(*result) == "//Test")

    str = "/*This*/"
    result = lexer::lex(str)
    assert(next_comment(*result) == "/*This*/")

    str = "/*Nested/*Comment*/*/"
    result = lexer::lex(str)
    assert(next_comment(*result) == "/*Nested/*Comment*/*/")

    print("OK\n")
}

def test_symbols {
    print(">Test symbols... ")

    var str = "foo + bar"
    var result = lexer::lex(str)
    assert(next_identifier(*result) == "foo")
    next_value(*result, lexer::TokenType::WHITESPACE)
    next_value(*result, lexer::TokenType::OP_ADD)
    next_value(*result, lexer::TokenType::WHITESPACE)
    assert(next_identifier(*result) == "bar")

    // TODO add more tests

    print("OK\n")
}

def test_complex {
    print(">Test complex example... ")

    var str = "
        type T = struct {
            a: int
            b: string
        }

        def main(a: int, b: unsigned word) -> T {
            print(\"A: \", a, \" B: \", b)
            var t: T = {
                a = 0, b = \"Test string\"
            } !T
        }
    "
    var result = lexer::lex(str)
    //lexer::print_token_list(result)

    print("OK\n")
}

def test_lexer {
    print("Running tests on Lexer...\n")
    test_string_literal()
    test_string_literal_error()
    test_char_literal()
    test_char_literal_error()
    test_int_literal()
    test_float_literal()
    test_identifier()
    test_pragma()
    test_comment()
    test_symbols()
    test_complex()
}

def test_buffer {
    print("Running tests on Buffer...\n")
    var str = "this is a test"
    var buf = buffer::make_buffer()
    buffer::append_str(*buf, str)
    var res = buffer::to_string(*buf)
    assert(res == str)
    buffer::append_char(*buf, 't')
    res = buffer::to_string(*buf)
    assert(res == "this is a testt")
}

def test_vector {
    print("Running tests on Vector...\n")
    var vec = vector::make()
    let i1 = allocate(int); @i1 = 0
    vector::push(vec, i1)
    let i2 = allocate(int); @i2 = 1
    vector::push(vec, i2)
    let i3 = allocate(int); @i3 = 2
    vector::push(vec, i3)

    assert(@(vector::get(vec, 0) !*int) == 0)
    assert(@(vector::get(vec, 1) !*int) == 1)
    assert(@(vector::get(vec, 2) !*int) == 2)

    let i4 = allocate(int); @i4 = 3
    vector::set(vec, 0, i4)

    assert(@(vector::get(vec, 0) !*int) == 3)
}

def test_split_lines {
    print(">Test split lines... ")

    var str = "this\nis\na\ntest"
    var res = util::split_lines(str)

    assert(res.size == 4)
    assert(res[0] == "this")
    assert(res[1] == "is")
    assert(res[2] == "a")
    assert(res[3] == "test")

    str = "this is a test"
    res = util::split_lines(str)

    assert(res.size == 1)
    assert(res[0] == "this is a test")

    str = "this\r\nis\r\na\r\ntest"
    res = util::split_lines(str)
    
    assert(res.size == 4)
    assert(res[0] == "this")
    assert(res[1] == "is")
    assert(res[2] == "a")
    assert(res[3] == "test")

    print("OK\n")
}

def test_util {
    print("Running tests on Util...\n")
    test_split_lines()
}

def parse(s: string) -> *parser::Node {
    let tokens = lexer::lex(s)
    let lines = util::split_lines(s)
    return parser::parse(tokens, lines)
}

def test_operators {
    print(">Test operators... ")
    var str = "1 + 2"
    var res = parse(str)
    assert((@res).kind == parser::NodeKind::PROGRAM)
    var val = @(vector::get((@res).value.body, 0) !*parser::Node)
    assert(val.kind == parser::NodeKind::ADD)
    var left = @val.value.bin_op.left
    var right = @val.value.bin_op.right
    assert(left.kind == parser::NodeKind::INTEGER)
    assert(right.kind == parser::NodeKind::INTEGER)
    assert(left.value.i == 1)
    assert(right.value.i == 2)

    str = "1 + 2 * 3 - 5"
    res = parse(str)

    str = "1 << 5 + 0xFF >> 1"
    res = parse(str)

    print("OK\n")
}

def test_vardecl {
    print(">Test vardecl... ")

    var str = "var foo = 5"
    var res = parse(str)

    /*str = "const foo = 5"
    res = parse(str)

    str = "var foo, bar = 1, 2"
    res = parse(str)

    str = "let foo, (bar) = 1, 2"
    res = parse(str)*/
    
    print("OK\n")
}

def test_types {
    print(">Test types... ")

    var str = "type int"
    var res = parse(str)

    str = "(type word(16))"
    res = parse(str)

    str = "(type T -> F)"
    res = parse(str)

    str = "(type ->)"
    res = parse(str)

    str = "(type (->))"
    res = parse(str)

    str = "(type A -> B -> C)"
    res = parse(str)

    str = "(type () -> ())"
    res = parse(str)

    str = "(type (A, B) -> (C, D))"
    res = parse(str)

    print("OK\n")
}

def test_parser {
    print("Running tests on Parser...\n")
    test_operators()
    test_types()
    test_vardecl()
}

export def run_test_suite {
    test_buffer()
    test_lexer()
    test_util()
    test_vector()
    test_parser()
}