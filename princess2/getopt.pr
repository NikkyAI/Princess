// TODO This needs to be tested
// TODO It would also be nice to create a version that doesn't
// leak memory for the standard library

import map
import vector
import util

export let ARGS_ANY  = -1

export type Type = enum {
    STRING; BOOL
}

export type Option = struct {
    tpe: Type
    shortop: string
    longop: string
    nargs: int
    repeat: bool
}

def get_name(option: Option) -> string {
    if length(option.longop) > 0 {
        return option.longop
    } else {
        return option.shortop
    }
}

def print_help(options: [Option]) {
    // TODO Implement this
}

// TODO give better error messages
// Right now its okay to pass arguments to an option that doesn't accept any
export def parse(args: [string], options: [Option]) -> *map::Map {
    let m = map::make()
    // Filename is the first argument
    var last_option = 0
    for var i in 1..args.size {
        let arg = args[i]
        var found = false
        var is_option = false 

        for var j in 0..options.size {
            let option = options[j]
            let passed_args = vector::make()

            if starts_with(arg, "--") {
                if length(option.longop) > 0 and starts_with(option.longop, "--") and starts_with(arg, option.longop) {
                    found = true
                    if length(arg) > length(option.longop) {
                        if arg[length(option.longop)] == '=' {
                            if option.nargs == 1 and option.tpe == Type::STRING {
                                let value = util::copy_string(arg)
                                (@value).value ++ length(option.longop)
                                (@value).size = strlen((@value)) + 1
                                vector::push(passed_args, value)
                            } else {
                                error("Invalid arguments to option ", get_name(option), "\n")
                                return null
                            }
                        } else {
                            found = false
                        }
                    } else {
                        for var k in 0..option.nargs {
                            var l = i + 1
                            if l < args.size {
                                vector::push(passed_args, util::copy_string(args[l]))
                                i += 1
                            }
                        }
                    }
                }
                last_option = i
            } else if starts_with(arg, "-") { 
                if length(option.shortop) > 0 and arg == option.shortop {
                    found = true
                    for var k in 0..option.nargs {
                        var l = i + 1
                        if l < args.size {
                            vector::push(passed_args, util::copy_string(args[l]))
                            i += 1
                        }
                    }
                }
                last_option = i
            }

            if found {
                if option.nargs == 0 and vector::length(passed_args) > 0 {
                    error("Too many arguments to option ", get_name(option), "\n")
                    return null
                } else if option.nargs != ARGS_ANY and option.nargs != vector::length(passed_args) {
                    error("Invalid number of options passed to argument ", get_name(option), "\n")
                    return null
                }
                
                var v = map::get(m, get_name(option))
                if v and not option.repeat {
                    error("Option ", get_name(option), " was repeated!\n")
                    return null
                }

                var element: *
                if option.tpe == Type::BOOL {
                    let e = allocate(bool)
                    (@e) = true
                    element = e
                } else if option.nargs == 1 {
                    element = vector::peek(passed_args)
                } else {
                    element = passed_args
                }

                if option.repeat {
                    if not v { 
                        v = vector::make()
                    }
                    vector::push(v, element) 
                    map::put(m, get_name(option), v)
                } else {
                    map::put(m, get_name(option), element)
                }

                break
            }
        }
        if not found and last_option == i {
            error("Unknown argument ", arg, "\n")
            return null
        }
    }
    
    var j = last_option + 1
    for var i in 0..options.size {
        let opt = options[i]
        if length(opt.longop) > 0 and not starts_with(opt.longop, "--") {
            let passed_args = vector::make()
            
            var n = opt.nargs
            if n == ARGS_ANY {
                n = args.size - j
            }

            for var i in 0..n {
                if j < args.size {
                    vector::push(passed_args, util::copy_string(args[j]))
                    j += 1
                } else {
                    error("Not enough arguments to ", get_name(opt), " required ", opt.nargs, ", got ", i, "\n")
                    return null
                }
            }
            if opt.nargs == 1 {
                map::put(m, get_name(opt), vector::peek(passed_args))
            } else {
                map::put(m, get_name(opt), passed_args)
            }
        }
    }

    for var i in 0..options.size {
        let opt = options[i]
        if opt.tpe == Type::BOOL and not map::contains(m, get_name(opt)) {
            map::put(m, get_name(opt), zero_allocate(bool))
        }
    }

    return m
}