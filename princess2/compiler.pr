import buffer
import parser
import vector
import map
import scope
import typechecking
import util
import builtins
import debug

export type Label = struct {
    name: string
}

export type ValueKind = enum {
    LOCAL; GLOBAL;
    BOOL; INT; FLOAT; STRING
    ARRAY; STRUCT; NULL
}

export type Value = struct {
    kind: ValueKind
    name: string
    sign: int
    i: uint64
    f: double
    s: string
    // Used for both struct and array
    values: [Value]
    tpe: *typechecking::Type
}

let NO_VALUE = { kind = ValueKind::NULL, tpe = null } !Value

export type InsnKind = enum {
    ADD; SUB; MUL; SREM; UREM; SDIV; UDIV
    FADD; FSUB; FMUL; FREM; FDIV
    RET; LOAD; STORE; ALLOCA
    CALL; BR_UNC; BR
}

export type InsnStore = struct {
    value: Value
    loc: Value
}

export type InsnLoad = struct {
    value: Value
    loc: Value
}

export type InsnReturn = struct {
    value: Value
}

export type InsnArithmetic = struct {
    ret: Value
    left: Value
    right: Value
}

export type InsnAlloca = struct {
    ret: Value
}

export type InsnCall = struct {
    name: Value
    ret: Value
    args: [Value]
}

export type InsnBrUnc = struct {
    label_: Label
}

export type InsnBr = struct {
    cond: Value
    if_true: Label
    if_false: Label
}

export type InsnValue = struct #union {
    arith: InsnArithmetic
    ret: InsnReturn
    store: InsnStore
    load: InsnLoad
    alloca: InsnAlloca
    call: InsnCall
    br_unc: InsnBrUnc
    br: InsnBr
}

export type Insn = struct {
    kind: InsnKind
    value: InsnValue
}

// Block for CFG
export type Block = struct {
    label_: string
    // Vector of Insn
    insn: *vector::Vector
    next: *Block
}

export type Function = struct {
    name: string
    // Vector of typechecking::NamedParameter
    args: *vector::Vector
    ret: *typechecking::Type
    multiple_returns: bool
    forward_declare: bool
    // First node
    block: *Block
}

export type Structure = struct {
    name: string
    packed: bool
    // Vector of typechecking::Type
    values: *vector::Vector
}

export type Global = struct {
    name: string
    tpe: *typechecking::Type
}

export type Result = struct {
    functions: *map::Map
    structures: *map::Map
    globals: *map::Map
}

type State = struct {
    label_counter: int
    counter: int
    filename: string
    module: string
    // TODO Make this a stack for nested functions
    current_function: *Function
    current_block: *Block
    result: Result
}

def make_label(state: *State) -> Label {
    let s = util::int_to_str((@state).label_counter)
    (@state).label_counter += 1
    return { name = s } !Label
}

def make_unique_name(state: *State) -> string {
    let s = util::int_to_str((@state).counter)
    (@state).counter += 1
    return s
}

def push_label(label_: Label, state: *State) {
    let block = allocate(Block)
    // TODO Might want to use the actual label here
    (@block).label_ = label_.name
    (@block).insn = vector::make()
    (@(@state).current_block).next = block
    (@state).current_block = block
}

def push_insn(insn: *Insn, state: *State) {
    vector::push((@(@state).current_block).insn, insn)
}

def walk_expression(node: *parser::Node, state: *State) -> Value
def walk(node: *parser::Node, state: *State)

def walk_Boolean(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    let value = {
        kind = ValueKind::BOOL,
        i = (@node).value.i,
        tpe = tpe
    } !Value
    return value
}

def walk_Integer(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    let value = {
        kind = ValueKind::INT,
        i = (@tpe).i,
        sign = (@tpe).sign,
        tpe = tpe
    } !Value
    return value
}

def walk_Float(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    let value = {
        kind = ValueKind::FLOAT,
        f = (@node).value.f,
        tpe = tpe
    } !Value
    return value
}

def walk_Add(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe

    var insn_kind = InsnKind::ADD
    if typechecking::is_float(tpe) {
        insn_kind = InsnKind::FADD
    }

    // TODO Type conversions
    let left = walk_expression((@node).value.bin_op.left, state)
    let right = walk_expression((@node).value.bin_op.right, state)

    let value = { 
        kind = ValueKind::LOCAL, 
        name = make_unique_name(state),
        tpe = tpe 
    } !Value
    
    let insn = allocate(Insn)
    (@insn).kind = insn_kind
    (@insn).value.arith = {
        left = left,
        right = right,
        ret = value
    } !InsnArithmetic

    push_insn(insn, state)

    return value
}

def walk_Call(node: *parser::Node, state: *State) -> Value {
    if not (@node).tpe { return NO_VALUE }
    var name = (@(@node).tpe).type_name
    let parameter_t = (@(@node).tpe).parameter_t
    name = typechecking::mangle_function_name(name, parameter_t)
    let function = map::get((@state).result.functions, name) !*Function

    if not function { return NO_VALUE }
    
    let name_v = {
        kind = ValueKind::GLOBAL,
        name = name,
        tpe = null
    } !Value

    var value = NO_VALUE
    if (@function).ret {
        value = {
            kind = ValueKind::LOCAL,
            name = make_unique_name(state),
            tpe = (@function).ret
        } !Value
    }

    let args = allocate(Value, vector::length(parameter_t))
    for var i in 0..vector::length((@node).value.func_call.args) {
        let n = vector::get((@node).value.func_call.args, i) !*parser::Node
        args[i] = walk_expression(n, state)
    }
    for var i in 0..vector::length((@node).value.func_call.kwargs) {
        let n = vector::get((@node).value.func_call.args, i) !*parser::Node
        assert((@n).kind == parser::NodeKind::NAMED_ARG)
        // Find named parameter
        let name = typechecking::last_ident_to_str((@n).value.named_arg.name)
        let value = (@n).value.named_arg.value
        for var j in 0..vector::length(parameter_t) {
            let p = vector::get(parameter_t, j) !*typechecking::NamedParameter
            if (@p).name == name {
                args[j] = walk_expression(value, state)
            }
        }
    }

    let insn = allocate(Insn)
    (@insn).kind = InsnKind::CALL
    (@insn).value.call = {
        name = name_v,
        ret = value,
        args = args
    } !InsnCall

    push_insn(insn, state)

    return value
}

def walk_Identifier(node: *parser::Node, state: *State) -> Value {
    let value = {
        kind = ValueKind::LOCAL,
        name = make_unique_name(state),
        tpe = (@node).tpe
    } !Value

    let val = scope::get((@node).scope, node)
    if not val { return NO_VALUE }
    let name = (@val).assembly_name
    
    let insn = allocate(Insn)
    (@insn).kind = InsnKind::LOAD
    (@insn).value.load = {
        value = value,
        loc = {
            kind = ValueKind::LOCAL,
            name = name,
            tpe = typechecking::pointer((@node).tpe)
        } !Value
    }

    push_insn(insn, state)
    return value
}

def walk_Assign(node: *parser::Node, state: *State) -> Value {
    // TODO Make this possible: a, b = c, d = e, f
    // Right now we can only return one value
}

def walk_expression(node: *parser::Node, state: *State) -> Value {
    switch (@node).kind !int {
        case parser::NodeKind::IDENTIFIER:
            return walk_Identifier(node, state)
        case parser::NodeKind::INTEGER:
            return walk_Integer(node, state)
        case parser::NodeKind::FLOAT:
            return walk_Float(node, state)
        case parser::NodeKind::BOOLEAN:
            return walk_Boolean(node, state)
        case parser::NodeKind::ADD:
            return walk_Add(node, state)
        case parser::NodeKind::FUNC_CALL:
            return walk_Call(node, state)
        case parser::NodeKind::ASSIGN:
            return walk_Assign(node, state)
        case:
            error((@node).kind, "\n")
            assert(false)
    }
}

def walk_If(node: *parser::Node, state: *State) {

    // TODO Type conversions
    let cond = walk_expression((@node).value.if_.cond, state)
    let entry_label = make_label(state)
    var entry = allocate(Insn)
    (@entry).kind = InsnKind::BR
    (@entry).value.br = {
        cond = cond,
        if_true = entry_label
    }

    let exit = allocate(Insn)
    (@exit).kind = InsnKind::BR_UNC

    push_insn(entry, state)
    push_label(entry_label, state)
    for var i in 0..vector::length((@node).value.if_.body) {
        let stmt = vector::get((@node).value.if_.body, i) !*parser::Node
        walk(stmt, state)
    }
    push_insn(exit, state)

    for var i in 0..vector::length((@node).value.if_.else_if) {
        let else_if = vector::get((@node).value.if_.else_if, i) !*parser::Node
        let cond = walk_expression((@else_if).value.else_if.cond, state)

        let br_label = make_label(state)
        (@entry).value.br.if_false = br_label
        push_label(br_label, state)

        entry = allocate(Insn)
        (@entry).kind = InsnKind::BR
        (@entry).value.br = {
            cond = cond
        }
        push_insn(entry, state)
        let entry_label = make_label(state)
        (@entry).value.br.if_true = entry_label

        push_label(entry_label, state)
        for var i in 0..vector::length((@else_if).value.else_if.body) {
            let stmt = vector::get((@else_if).value.else_if.body, i)
            walk(stmt, state)
        }
        push_insn(exit, state)
    }

    let else_ = (@node).value.if_.else_
    if else_ {
        let entry_label = make_label(state)
        (@entry).value.br.if_false = entry_label
        push_label(entry_label, state)
        
        for var i in 0..vector::length((@else_).value.body) {
            let stmt = vector::get((@else_).value.body, i) !*parser::Node
            walk(stmt, state)
        }
        push_insn(exit, state)
    }

    let exit_label = make_label(state)
    if not else_ {
        (@entry).value.br.if_false = exit_label
    }
    (@exit).value.br_unc.label_ = exit_label
    push_label(exit_label, state)
}

def walk_Return(node: *parser::Node, state: *State) {
    let current_function = (@state).current_function

    var value: Value
    if (@current_function).multiple_returns {
        let ret_args = allocate(Value, vector::length((@node).value.body))
        for var i in 0..ret_args.size {
            ret_args[i] = walk_expression(vector::get((@node).value.body, i) !*parser::Node, state)
        }
        value = {
            kind = ValueKind::STRUCT,
            values = ret_args,
            tpe = (@current_function).ret
        } !Value
    } else {
        let arg = vector::peek((@node).value.body)
        value = walk_expression(arg, state)
    }

    let ret = allocate(Insn)
    (@ret).kind = InsnKind::RET
    (@ret).value.ret.value = value

    push_insn(ret, state)
}

def walk_VarDecl(node: *parser::Node, state: *State) {
    
}

def walk(node: *parser::Node, state: *State) {
    switch (@node).kind !int {
        case parser::NodeKind::VAR_DECL:
            walk_VarDecl(node, state)
        case parser::NodeKind::RETURN:
            walk_Return(node, state)
        case parser::NodeKind::IF:
            walk_If(node, state)
        case: walk_expression(node, state)
    }
}

def create_function(tpe: *typechecking::Type, body: *vector::Vector, scpe: *scope::Scope, state: *State) {
    let function = allocate(Function)
    (@function).name = typechecking::mangle_function_name((@tpe).type_name, (@tpe).parameter_t)
    (@function).multiple_returns = false
    (@function).forward_declare = true
    if body {
        (@function).forward_declare = false
    }

    if vector::length((@tpe).return_t) > 1 {
        // Create anonymous struct as return type
        // TODO Might want to use an inline struct type for return values
        let ret_tpe = typechecking::make_anonymous_type(typechecking::TypeKind::STRUCT, (@state).module)
        let length = vector::length((@tpe).return_t)
        let fields = allocate(typechecking::StructMember, length)

        // TODO Somehow refactor this with typechecking::type_lookup
        var offset = 0
        var align = 1
        for var i in 0..length {
            let tpe = vector::get((@tpe).return_t, i) !*typechecking::Type
            let name = util::int_to_str(i)

            offset = (ceil(offset / (@tpe).align !double) * (@tpe).align) !int
            align = util::lcm(align, (@tpe).align)

            fields[i] = { name, tpe, offset } !StructMember
            offset += (@tpe).size
        }
        offset = (ceil(offset / align !double) * align) !int

        (@ret_tpe).size = offset
        (@ret_tpe).align = align
        (@ret_tpe).fields = fields

        (@function).ret = ret_tpe
        (@function).multiple_returns = true

        // Store return type in structures
        map::put((@state).result.structures, (@ret_tpe).type_name, ret_tpe)
    } else if vector::length((@tpe).return_t) == 1 {
        (@function).ret = vector::get((@tpe).return_t, 0) !*typechecking::Type
    } else {
        (@function).ret = null
    }

    (@function).args = (@tpe).parameter_t

    if body {
        (@state).current_function = function
        (@state).counter = 0
        (@state).label_counter = 0
        
        let block = allocate(Block)
        (@block).label_ = "start"
        (@block).insn = vector::make()
        (@block).next = null

        (@function).block = block
        (@state).current_block = block

        // Create function arguments
        for var i in 0..vector::length((@tpe).parameter_t) {
            let np = vector::get((@tpe).parameter_t, i) !*typechecking::NamedParameter
            /*let vars = map::keys((@scpe).fields)
            for var i in 0..vars.size {
                let v = vars[i]
                print(v, "\n")
            }*/
            let name = (@scope::get(scpe, parser::make_identifier([(@np).name]))).assembly_name
            let buf = buffer::make_buffer()
            buffer::append_str(*buf, name)
            buffer::append_str(*buf, ".value")
            // Rename to name.value
            (@np).name = buffer::to_string(*buf)
            // Insert alloca and store instructions

            let alloca = allocate(Insn)
            (@alloca).kind = InsnKind::ALLOCA
            (@alloca).value.alloca = {
                ret = {
                    kind = ValueKind::LOCAL,
                    name = name,
                    tpe = (@np).value
                } !Value
            } !InsnAlloca

            push_insn(alloca, state)

            let store = allocate(Insn)
            (@store).kind = InsnKind::STORE
            (@store).value.store = {
                value = {
                    kind = ValueKind::LOCAL,
                    name = (@np).name,
                    tpe = (@np).value
                } !Value,
                loc = {
                    kind = ValueKind::LOCAL,
                    name = name,
                    tpe = typechecking::pointer((@np).value)
                } !Value
            } !InsnStore

            push_insn(store, state)
        }

        for var i in 0..vector::length(body) {
            let node = vector::get(body, i) !*parser::Node
            walk(node, state)
        }

        // TODO Make another compiler pass that checks for missing return statements and dead code
        if not (@function).ret {
            // Check for missing return statement
            let last_insn = vector::peek((@(@state).current_block).insn) !*Insn
            if not last_insn or last_insn and (@last_insn).kind != InsnKind::RET {
                let ret = allocate(Insn)
                (@ret).kind = InsnKind::RET
                (@ret).value.ret.value = NO_VALUE
                push_insn(ret, state)
            }
        }
    }
    map::put((@state).result.functions, (@function).name, function)
}

def walk_Def(node: *parser::Node, state: *State){
    create_function((@node).tpe, (@node).value.def_.body, (@node).scope, state)
}

def walk_TypeDecl(node: *parser::Node, state: *State) {

}

def walk_top_VarDecl(node: *parser::Node, body: *vector::Vector, state: *State) {
    let left = vector::make()
    for var i in 0..vector::length((@node).value.var_decl.left) {
        let n = vector::get((@node).value.var_decl.left, i) !*parser::Node
        if (@n).kind == parser::NodeKind::ID_DECL {
            let global = allocate(Global)
            (@global).name = typechecking::last_ident_to_str((@n).value.id_decl.value)
            (@global).tpe = (@n).tpe
            map::put((@state).result.globals, (@global).name, global)
            vector::push(left, (@n).value.id_decl.value)
        } else {
            vector::push(left, (@n).value.expr)
        }
    }
    if vector::length((@node).value.var_decl.right) > 0 {
        let node_assign = allocate(parser::Node)
        (@node_assign).kind = parser::NodeKind::ASSIGN
        (@node_assign).loc = (@node).loc
        (@node_assign).value.assign = {
            left = left,
            right = (@node).value.var_decl.right
        } !NodeAssign
        vector::push(body, node_assign)
    }
}

export def compile(node: *parser::Node, filename: string, module: string) -> Result {
    assert((@node).kind == parser::NodeKind::PROGRAM)
    
    let body = vector::make()
    let state = {
        filename = filename,
        module = module,
        result = {
            functions = map::make(),
            structures = map::make(),
            globals = map::make()
        } !Result
    } !State

    for var i in 0..vector::length((@node).value.body) {
        let n = vector::get((@node).value.body, i) !*parser::Node
        switch (@n).kind !int {
            case parser::NodeKind::DEF:
                walk_Def(n, *state)
            case parser::NodeKind::TYPE_DECL:
                walk_TypeDecl(n, *state)
            case parser::NodeKind::VAR_DECL:
                walk_top_VarDecl(n, body, *state)
            case:
                vector::push(body, n)
        }
    }
    let ident = parser::make_identifier(["main"])
    (@ident).loc.module = module
    (@ident).loc.filename = filename
    let main_tpe = typechecking::make_type(typechecking::TypeKind::FUNCTION, ident)
    
    let string_array_tpe = allocate(typechecking::Type)
    (@string_array_tpe).kind = typechecking::TypeKind::ARRAY
    (@string_array_tpe).tpe = builtins::string_

    let named = allocate(typechecking::NamedParameter)
    (@named).name = "args"
    (@named).value = string_array_tpe
    let args = vector::make()
    vector::push(args, named)

    (@main_tpe).parameter_t = args
    // TODO Infer return types
    (@main_tpe).return_t = vector::make()

    scope::create_variable(
        (@node).scope, 
        parser::make_identifier(["args"]), 
        parser::ShareMarker::NONE, 
        parser::VarDecl::VAR, 
        string_array_tpe, null
    )

    create_function(main_tpe, body, (@node).scope, *state)

    return state.result
}
