import buffer
import parser
import vector
import map
import scope
import typechecking
import util
import builtins
import debug

export type Label = struct {
    name: string
}

export type ValueKind = enum {
    NULL; LOCAL; GLOBAL;
    BOOL; INT; FLOAT; STRING
    ARRAY; STRUCT; UNION
}

export type Value = struct {
    kind: ValueKind
    name: string
    sign: int
    i: uint64
    f: double
    s: string
    // Used for both struct and array
    values: [Value]
    // Address of a value
    addr: *Value
    tpe: *typechecking::Type
}

let NO_VALUE = { kind = ValueKind::NULL, tpe = null } !Value

export type InsnKind = enum {
    ADD; SUB; MUL; SREM; UREM; SDIV; UDIV
    FADD; FSUB; FMUL; FREM; FDIV
    RET; LOAD; STORE; ALLOCA
    EXTRACTVALUE; GETELEMENTPTR
    TRUNC; ZEXT; SEXT; FPTRUNC; FPEXT
    FPTOUI; FPTOSI; UITOFP; SITOFP
    PTRTOINT; INTTOPTR; BITCAST
    CALL; BR_UNC; BR
}

export type InsnGetElementPtr = struct {
    ret: Value
    // Here the type isn't the same as ret
    tpe: *typechecking::Type
    value: Value
    index: [Value]
}

export type InsnConvert = struct {
    ret: Value
    value: Value
}

export type InsnExtractValue = struct {
    ret: Value
    value: Value
    index: [int]
}

export type InsnStore = struct {
    value: Value
    loc: Value
}

export type InsnLoad = struct {
    value: Value
    loc: Value
}

export type InsnReturn = struct {
    value: Value
}

export type InsnArithmetic = struct {
    ret: Value
    left: Value
    right: Value
}

export type InsnAlloca = struct {
    ret: Value
}

export type InsnCall = struct {
    name: Value
    ret: Value
    args: [Value]
}

export type InsnBrUnc = struct {
    label_: Label
}

export type InsnBr = struct {
    cond: Value
    if_true: Label
    if_false: Label
}

export type InsnValue = struct #union {
    arith: InsnArithmetic
    ret: InsnReturn
    store: InsnStore
    load: InsnLoad
    alloca: InsnAlloca
    call: InsnCall
    br_unc: InsnBrUnc
    br: InsnBr
    extract_value: InsnExtractValue
    gep: InsnGetElementPtr
    convert: InsnConvert
}

export type Insn = struct {
    kind: InsnKind
    value: InsnValue
}

// Block for CFG
export type Block = struct {
    label_: string
    // Vector of Insn
    insn: *vector::Vector
    next: *Block
}

export type Function = struct {
    name: string
    // Vector of typechecking::NamedParameter
    args: *vector::Vector
    ret: *typechecking::Type
    multiple_returns: bool
    forward_declare: bool
    // First node
    block: *Block
}

export type Result = struct {
    functions: *map::Map
    structures: *map::Map
    globals: *map::Map
}

type LoopState = struct {
    break_insn: *Insn
    continue_insn: *Insn
}

type State = struct {
    label_counter: int
    counter: int
    filename: string
    module: string
    // TODO Make this a stack for nested functions
    current_function: *Function
    current_block: *Block
    // Vector of LoopState 
    loops: *vector::Vector
    result: Result
}

def get_break_insn(state: *State) -> *Insn {
    if vector::length((@state).loops) > 0 {
        return (@(vector::peek((@state).loops) !*LoopState)).break_insn
    }
    return null
}

def get_continue_insn(state: *State) -> *Insn {
    if vector::length((@state).loops) > 0 {
        return (@(vector::peek((@state).loops) !*LoopState)).continue_insn
    }
    return null
}

def push_loop_state(state: *State) {
    let loops = allocate(LoopState)

    let break_insn = allocate(Insn)
    (@break_insn).kind = InsnKind::BR_UNC
    let continue_insn = allocate(Insn)
    (@continue_insn).kind = InsnKind::BR_UNC

    (@loops).break_insn = break_insn
    (@loops).continue_insn = continue_insn
    
    vector::push((@state).loops, loops)
}

def pop_loop_state(state: *State) {
    vector::pop((@state).loops)
}

def make_label(state: *State) -> Label {
    let s = util::int_to_str((@state).label_counter)
    (@state).label_counter += 1
    return { name = s } !Label
}

def make_unique_name(state: *State) -> string {
    let s = util::int_to_str((@state).counter)
    (@state).counter += 1
    return s
}

def push_label(label_: Label, state: *State) {
    let block = allocate(Block)
    // TODO Might want to use the actual label here
    (@block).label_ = label_.name
    (@block).insn = vector::make()
    (@(@state).current_block).next = block
    (@state).current_block = block
}

def push_insn(insn: *Insn, state: *State) {
    vector::push((@(@state).current_block).insn, insn)
}

def walk_expression(node: *parser::Node, state: *State) -> Value
def walk(node: *parser::Node, state: *State)

def walk_Boolean(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    let value = {
        kind = ValueKind::BOOL,
        i = (@node).value.i,
        tpe = tpe
    } !Value
    return value
}

def walk_Integer(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    let value = {
        kind = ValueKind::INT,
        i = (@tpe).i,
        sign = (@tpe).sign,
        tpe = tpe
    } !Value
    return value
}

def walk_Float(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    let value = {
        kind = ValueKind::FLOAT,
        f = (@node).value.f,
        tpe = tpe
    } !Value
    return value
}

def convert_to(node: *parser::Node, value: Value, tpe: *typechecking::Type, state: *State) -> Value {
    if typechecking::equals(value.tpe, tpe) {
        return value
    }

    var kind: InsnKind

    if typechecking::is_integer(tpe) {
        if typechecking::is_integer(value.tpe) {
            if (@value.tpe).size == (@tpe).size {
                // Types only differ in sign, llvm doesn't treat them any different
                return value
            } else if (@value.tpe).size > (@tpe).size {
                kind = InsnKind::TRUNC
            } else if (@tpe).unsig {
                kind = InsnKind::ZEXT
            } else {
                kind = InsnKind::SEXT
            }
        } else if typechecking::is_float(value.tpe) {
            if (@tpe).unsig {
                kind = InsnKind::FPTOUI
            } else {
                kind = InsnKind::FPTOSI
            }
        } else if typechecking::is_pointer(value.tpe) {
            kind = InsnKind::PTRTOINT
        } else {
            typechecking::errorn(node, "Can't convert ")
            error(debug::type_to_str(value.tpe), " to ", debug::type_to_str(tpe), "\n")
            return value
        }
    } else if typechecking::is_float(tpe) {
        if typechecking::is_integer(value.tpe) {
            if (@value.tpe).unsig {
                kind = InsnKind::UITOFP
            } else {
                kind = InsnKind::SITOFP
            }
        } else if typechecking::is_float(value.tpe) {
            if (@value.tpe).size > (@tpe).size {
                kind = InsnKind::FPTRUNC
            } else {
                kind = InsnKind::FPEXT
            }
        } else {
            typechecking::errorn(node, "Can't convert ")
            error(debug::type_to_str(value.tpe), " to ", debug::type_to_str(tpe), "\n")
            return value
        }
    } else if typechecking::is_pointer(tpe) {
        if typechecking::is_pointer(value.tpe) {
            kind = InsnKind::BITCAST
        } else if typechecking::is_integer(value.tpe) {
            kind = InsnKind::INTTOPTR
        } else {
            typechecking::errorn(node, "Can't convert ")
            error(debug::type_to_str(value.tpe), " to ", debug::type_to_str(tpe), "\n")
            return value
        }
    }

    let ret = {
        kind = ValueKind::LOCAL,
        name = make_unique_name(state),
        tpe = tpe
    } !Value

    let insn = allocate(Insn)
    (@insn).kind = kind
    (@insn).value.convert = {
        ret = ret,
        value = value
    } !InsnConvert

    push_insn(insn, state)

    return ret
}

def walk_Cast(node: *parser::Node, state: *State) -> Value {
    let value = walk_expression((@node).value.expr, state)
    return convert_to(node, value, (@node).tpe, state)
}

def walk_ArithmeticOp(node: *parser::Node, insn_kind: InsnKind, tpe: *typechecking::Type, state: *State) -> Value {
    // TODO Type conversions
    let left = convert_to(node, walk_expression((@node).value.bin_op.left, state), tpe, state)
    let right = convert_to(node, walk_expression((@node).value.bin_op.right, state), tpe, state)

    let value = { 
        kind = ValueKind::LOCAL, 
        name = make_unique_name(state),
        tpe = tpe 
    } !Value
    
    let insn = allocate(Insn)
    (@insn).kind = insn_kind
    (@insn).value.arith = {
        left = left,
        right = right,
        ret = value
    } !InsnArithmetic

    push_insn(insn, state)

    return value
}

def walk_Add(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    var insn_kind = InsnKind::ADD
    if typechecking::is_float(tpe) {
        insn_kind = InsnKind::FADD
    }
    return walk_ArithmeticOp(node, insn_kind, tpe, state)
}

def walk_Sub(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    var insn_kind = InsnKind::SUB
    if typechecking::is_float(tpe) {
        insn_kind = InsnKind::FSUB 
    }
    return walk_ArithmeticOp(node, insn_kind, tpe, state)
}

def walk_Mul(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    var insn_kind = InsnKind::MUL
    if typechecking::is_float(tpe) {
        insn_kind = InsnKind::FMUL 
    }
    return walk_ArithmeticOp(node, insn_kind, tpe, state)
}

def walk_Mod(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    var insn_kind = InsnKind::SREM
    if typechecking::is_float(tpe) {
        insn_kind = InsnKind::FREM 
    } else if (@tpe).unsig {
        insn_kind = InsnKind::UREM
    }
    return walk_ArithmeticOp(node, insn_kind, tpe, state)
}

def walk_Div(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    var insn_kind = InsnKind::SDIV
    if typechecking::is_float(tpe) {
        insn_kind = InsnKind::FDIV 
    } else if (@tpe).unsig {
        insn_kind = InsnKind::UDIV
    }
    return walk_ArithmeticOp(node, insn_kind, tpe, state)
}

def walk_Call(node: *parser::Node, state: *State) -> Value {
    if not (@node).tpe { return NO_VALUE }
    var name = (@(@node).tpe).type_name
    let parameter_t = (@(@node).tpe).parameter_t
    name = typechecking::mangle_function_name(name, parameter_t)
    let function = map::get((@state).result.functions, name) !*Function

    if not function { return NO_VALUE }
    
    let name_v = {
        kind = ValueKind::GLOBAL,
        name = name,
        tpe = null
    } !Value

    var value = NO_VALUE
    if (@function).ret {
        value = {
            kind = ValueKind::LOCAL,
            name = make_unique_name(state),
            tpe = (@function).ret
        } !Value
    }

    let args = allocate(Value, vector::length(parameter_t))
    for var i in 0..vector::length((@node).value.func_call.args) {
        let n = vector::get((@node).value.func_call.args, i) !*parser::Node
        args[i] = walk_expression(n, state)
    }
    for var i in 0..vector::length((@node).value.func_call.kwargs) {
        let n = vector::get((@node).value.func_call.args, i) !*parser::Node
        assert((@n).kind == parser::NodeKind::NAMED_ARG)
        // Find named parameter
        let name = typechecking::last_ident_to_str((@n).value.named_arg.name)
        let value = (@n).value.named_arg.value
        for var j in 0..vector::length(parameter_t) {
            let p = vector::get(parameter_t, j) !*typechecking::NamedParameter
            if (@p).name == name {
                args[j] = walk_expression(value, state)
            }
        }
    }

    let insn = allocate(Insn)
    (@insn).kind = InsnKind::CALL
    (@insn).value.call = {
        name = name_v,
        ret = value,
        args = args
    } !InsnCall

    push_insn(insn, state)

    return value
}

def walk_Identifier(node: *parser::Node, state: *State) -> Value {
    let value = {
        kind = ValueKind::LOCAL,
        name = make_unique_name(state),
        tpe = (@node).tpe
    } !Value

    let val = scope::get((@node).scope, node)
    if not val { return NO_VALUE }

    let name = (@val).assembly_name
    var kind = ValueKind::LOCAL
    if (@val).global {
        kind = ValueKind::GLOBAL
    }

    let loc = {
        kind = kind,
        name = name,
        tpe = typechecking::pointer((@node).tpe)
    } !Value

    let l = allocate(Value)
    (@l) = loc
    value.addr = l
    
    let insn = allocate(Insn)
    (@insn).kind = InsnKind::LOAD
    (@insn).value.load = {
        value = value,
        loc = loc
    }

    push_insn(insn, state)
    return value
}

def walk_Assign(node: *parser::Node, state: *State) -> Value {
    // TODO Make this possible: a, b = c, d = e, f
    // Right now we can only return one value
    // This probably means adding tuples to the language

    let right = (@node).value.assign.right
    let left = (@node).value.assign.left
    var last_value: Value

    var j = 0
    for var i in 0..vector::length(right) {
        let n = vector::get(right, i) !*parser::Node
        let value = walk_expression(n, state)
        let tpe = (@n).tpe
        if not tpe { continue }
        if (@tpe).kind == typechecking::TypeKind::FUNCTION and vector::length((@tpe).return_t) > 1 {
            for var k in 0..vector::length((@tpe).return_t) {
                let t = vector::get((@tpe).return_t, k)
                if j >= vector::length(left) { return NO_VALUE }
                let l = vector::get(left, j) !*parser::Node

                let addr = walk_expression(l, state).addr
                if not addr {
                    typechecking::errorn(l, "Can't assign, expression has no address\n")
                    return NO_VALUE
                }

                let ret = {
                    kind = ValueKind::LOCAL,
                    name = make_unique_name(state),
                    tpe = t
                } !Value

                let index = allocate(int, 1)
                index[0] = k

                let extract = allocate(Insn)
                (@extract).kind = InsnKind::EXTRACTVALUE
                (@extract).value.extract_value = {
                    ret = ret,
                    value = value,
                    index = index
                } !InsnExtractValue

                let store = allocate(Insn)
                (@store).kind = InsnKind::STORE
                (@store).value.store = {
                    value = ret,
                    loc = @addr
                } !InsnStore

                push_insn(extract, state)
                push_insn(store, state)

                last_value = ret
                j += 1
            }
        } else {
            if j >= vector::length(left) { return NO_VALUE }
            let l = vector::get(left, j) !*parser::Node
            // TODO This adds a useless load instruction
            let addr = walk_expression(l, state).addr
            if not addr { return NO_VALUE }

            let store = allocate(Insn)
            (@store).kind = InsnKind::STORE
            (@store).value.store = {
                value = value,
                loc = @addr
            } !InsnStore

            push_insn(store, state)

            last_value = value
            j += 1
        }
    }
    return last_value
}

def walk_Deref(node: *parser::Node, state: *State) -> Value {
    let value = walk_expression((@node).value.expr, state)
    let tpe = value.tpe

    let addr = allocate(Value)
    (@addr) = value
    let ret = {
        kind = ValueKind::LOCAL,
        name = make_unique_name(state),
        tpe = (@tpe).tpe,
        addr = addr
    } !Value

    let load = allocate(Insn)
    (@load).kind = InsnKind::LOAD
    (@load).value.load = {
        value = ret,
        loc = value
    } !InsnLoad

    push_insn(load, state)
    return ret
}

def walk_Ptr(node: *parser::Node, state: *State) -> Value {
    let value = walk_expression((@node).value.expr, state)
    if not value.addr { return NO_VALUE }

    return @(value.addr)
}

def walk_MemberAccess(node: *parser::Node, state: *State) -> Value {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not (@node).tpe { return NO_VALUE }
    let value = walk_expression(left, state)
    let struct_tpe = (@left).tpe

    // TODO This might double error
    let name = typechecking::last_ident_to_str(right)
    let index = allocate(Value, 2)
    index[0] = {
        kind = ValueKind::INT,
        sign = 1,
        i = 0,
        tpe = builtins::int_
    } !Value

    for var i in 0..(@struct_tpe).fields.size {
        let member = (@struct_tpe).fields[i]
        if member.name == name {
            index[1] = {
                kind = ValueKind::INT,
                sign = 1,
                i = i,
                tpe = builtins::int_
            } !Value
            break
        }
    }

    let gep_ret = {
        kind = ValueKind::LOCAL,
        name = make_unique_name(state),
        tpe = typechecking::pointer((@node).tpe)
    } !Value

    let gep = allocate(Insn)
    (@gep).kind = InsnKind::GETELEMENTPTR
    (@gep).value.gep = {
        ret = gep_ret,
        tpe = struct_tpe,
        value = @value.addr,
        index = index
    } !InsnGetElementPtr

    let addr = allocate(Value)
    (@addr) = gep_ret
    let ret = {
        kind = ValueKind::LOCAL,
        name = make_unique_name(state),
        tpe = (@node).tpe,
        addr = addr
    } !Value

    let load = allocate(Insn)
    (@load).kind = InsnKind::LOAD
    (@load).value.load = {
        value = ret,
        loc = gep_ret
    } !InsnLoad

    push_insn(gep, state)
    push_insn(load, state)

    return ret
}

def walk_expression(node: *parser::Node, state: *State) -> Value {
    switch (@node).kind !int {
        case parser::NodeKind::IDENTIFIER:
            return walk_Identifier(node, state)
        case parser::NodeKind::INTEGER:
            return walk_Integer(node, state)
        case parser::NodeKind::FLOAT:
            return walk_Float(node, state)
        case parser::NodeKind::BOOLEAN:
            return walk_Boolean(node, state)
        case parser::NodeKind::CAST:
            return walk_Cast(node, state)
        case parser::NodeKind::ADD:
            return walk_Add(node, state)
        case parser::NodeKind::SUB:
            return walk_Sub(node, state)
        case parser::NodeKind::MUL:
            return walk_Mul(node, state)
        case parser::NodeKind::MOD:
            return walk_Mod(node, state)
        case parser::NodeKind::DIV:
            return walk_Div(node, state)
        case parser::NodeKind::FUNC_CALL:
            return walk_Call(node, state)
        case parser::NodeKind::ASSIGN:
            return walk_Assign(node, state)
        case parser::NodeKind::DEREF:
            return walk_Deref(node, state)
        case parser::NodeKind::PTR:
            return walk_Ptr(node, state)
        case parser::NodeKind::MEMBER_ACCESS:
            return walk_MemberAccess(node, state)
        case:
            error((@node).kind, "\n")
            assert(false)
    }
}

def walk_If(node: *parser::Node, state: *State) {

    // TODO Type conversions
    let cond = walk_expression((@node).value.if_.cond, state)
    let entry_label = make_label(state)
    var entry = allocate(Insn)
    (@entry).kind = InsnKind::BR
    (@entry).value.br = {
        cond = cond,
        if_true = entry_label
    }

    let exit = allocate(Insn)
    (@exit).kind = InsnKind::BR_UNC

    push_insn(entry, state)
    push_label(entry_label, state)
    for var i in 0..vector::length((@node).value.if_.body) {
        let stmt = vector::get((@node).value.if_.body, i) !*parser::Node
        walk(stmt, state)
    }
    push_insn(exit, state)

    for var i in 0..vector::length((@node).value.if_.else_if) {
        let else_if = vector::get((@node).value.if_.else_if, i) !*parser::Node
        let cond = walk_expression((@else_if).value.else_if.cond, state)

        let br_label = make_label(state)
        (@entry).value.br.if_false = br_label
        push_label(br_label, state)

        entry = allocate(Insn)
        (@entry).kind = InsnKind::BR
        (@entry).value.br = {
            cond = cond
        }
        push_insn(entry, state)
        let entry_label = make_label(state)
        (@entry).value.br.if_true = entry_label

        push_label(entry_label, state)
        for var i in 0..vector::length((@else_if).value.else_if.body) {
            let stmt = vector::get((@else_if).value.else_if.body, i)
            walk(stmt, state)
        }
        push_insn(exit, state)
    }

    let else_ = (@node).value.if_.else_
    if else_ {
        let entry_label = make_label(state)
        (@entry).value.br.if_false = entry_label
        push_label(entry_label, state)
        
        for var i in 0..vector::length((@else_).value.body) {
            let stmt = vector::get((@else_).value.body, i) !*parser::Node
            walk(stmt, state)
        }
        push_insn(exit, state)
    }

    let exit_label = make_label(state)
    if not else_ {
        (@entry).value.br.if_false = exit_label
    }
    (@exit).value.br_unc.label_ = exit_label
    push_label(exit_label, state)
}

def walk_Return(node: *parser::Node, state: *State) {
    let current_function = (@state).current_function
    if not current_function { return }

    var value: Value
    if (@current_function).multiple_returns {
        let ret_args = allocate(Value, vector::length((@node).value.body))
        for var i in 0..ret_args.size {
            ret_args[i] = walk_expression(vector::get((@node).value.body, i) !*parser::Node, state)
        }
        value = {
            kind = ValueKind::STRUCT,
            values = ret_args,
            tpe = (@current_function).ret
        } !Value
    } else {
        let arg = vector::peek((@node).value.body)
        value = walk_expression(arg, state)
    }

    let ret = allocate(Insn)
    (@ret).kind = InsnKind::RET
    (@ret).value.ret.value = value

    push_insn(ret, state)
    (@state).label_counter += 1
}

def walk_Break(node: *parser::Node, state: *State) {
    let break_insn = get_break_insn(state)
    if not break_insn {
        typechecking::errorn(node, "break used outside of a loop\n")
        return
    }
    push_insn(break_insn, state)
    (@state).label_counter += 1
}

def walk_Continue(node: *parser::Node, state: *State) {
    let continue_insn = get_continue_insn(state)
    if not continue_insn {
        typechecking::errorn(node, "continue used outside of a loop\n")
        return
    }
    push_insn(continue_insn, state)
    (@state).label_counter += 1
}

def walk_Loop(node: *parser::Node, state: *State) {
    push_loop_state(state)
    let continue_insn = get_continue_insn(state)
    let break_insn = get_break_insn(state)

    push_insn(continue_insn, state)
    let start_label = make_label(state)
    push_label(start_label, state)
    for var i in 0..vector::length((@node).value.body) {
        let n = vector::get((@node).value.body, i)
        walk(n, state)
    }
    push_insn(continue_insn, state)
    let end_label = make_label(state)
    push_label(end_label, state)

    (@continue_insn).value.br_unc.label_ = start_label
    (@break_insn).value.br_unc.label_ = end_label
    pop_loop_state(state)
}

def walk_VarDecl(node: *parser::Node, state: *State) {
    let left = (@node).value.var_decl.left
    let right = (@node).value.var_decl.right

    let assign_left = vector::make()

    for var i in 0..vector::length(left) {
        let n = vector::get(left, i) !*parser::Node
        if (@n).kind == parser::NodeKind::ID_DECL {
            let v = (@n).value.id_decl.value
            let tpe = (@v).tpe

            let value = scope::get((@node).scope, v)
            if not value { continue }
            let name = (@value).assembly_name

            let insn = allocate(Insn)
            (@insn).kind = InsnKind::ALLOCA
            (@insn).value.alloca = {
                ret = {
                    kind = ValueKind::LOCAL,
                    name = name,
                    tpe = tpe
                } !Value
            } !InsnAlloca

            push_insn(insn, state)
            vector::push(assign_left, v)
        } else {
            vector::push(assign_left, (@n).value.expr)
        }
    }

    if vector::length(right) > 0 {
        let assign = allocate(parser::Node)
        (@assign).kind = parser::NodeKind::ASSIGN
        (@assign).loc = (@node).loc
        (@assign).scope = (@node).scope
        (@assign).value.assign = {
            left = assign_left,
            right = right
        } !parser::NodeAssign
        walk_Assign(assign, state)
    }
}

def walk(node: *parser::Node, state: *State) {
    switch (@node).kind !int {
        case parser::NodeKind::VAR_DECL:
            walk_VarDecl(node, state)
        case parser::NodeKind::RETURN:
            walk_Return(node, state)
        case parser::NodeKind::BREAK:
            walk_Break(node, state)
        case parser::NodeKind::CONTINUE:
            walk_Continue(node, state)
        case parser::NodeKind::IF:
            walk_If(node, state)
        case parser::NodeKind::LOOP:
            walk_Loop(node, state)
        case: walk_expression(node, state)
    }
}

def create_function(tpe: *typechecking::Type, body: *vector::Vector, scpe: *scope::Scope, state: *State) {
    let function = allocate(Function)
    (@function).name = typechecking::mangle_function_name((@tpe).type_name, (@tpe).parameter_t)
    (@function).multiple_returns = false
    (@function).forward_declare = true
    if body {
        (@function).forward_declare = false
    }

    if vector::length((@tpe).return_t) > 1 {
        // Create anonymous struct as return type
        // TODO Might want to use an inline struct type for return values
        let ret_tpe = typechecking::make_anonymous_type(typechecking::TypeKind::STRUCT, (@state).module)
        let length = vector::length((@tpe).return_t)
        let fields = allocate(typechecking::StructMember, length)

        // TODO Somehow refactor this with typechecking::type_lookup
        var offset = 0
        var align = 1
        for var i in 0..length {
            let t = vector::get((@tpe).return_t, i) !*typechecking::Type
            let name = util::int_to_str(i)

            offset = (ceil(offset / (@t).align  !double) * (@tpe).align) !int
            align = util::lcm(align, (@t).align)

            fields[i] = { name, t, offset } !StructMember
            offset += (@t).size
        }
        offset = (ceil(offset / align !double) * align) !int

        (@ret_tpe).size = offset
        (@ret_tpe).align = align
        (@ret_tpe).fields = fields

        (@function).ret = ret_tpe
        (@function).multiple_returns = true

        // Store return type in structures
        map::put((@state).result.structures, (@ret_tpe).type_name, ret_tpe)
    } else if vector::length((@tpe).return_t) == 1 {
        (@function).ret = vector::get((@tpe).return_t, 0) !*typechecking::Type
    } else {
        (@function).ret = null
    }

    (@function).args = (@tpe).parameter_t

    if body {
        (@state).current_function = function
        (@state).counter = 0
        (@state).label_counter = 0
        
        let block = allocate(Block)
        (@block).label_ = "start"
        (@block).insn = vector::make()
        (@block).next = null

        (@function).block = block
        (@state).current_block = block

        // Create function arguments
        for var i in 0..vector::length((@tpe).parameter_t) {
            let np = vector::get((@tpe).parameter_t, i) !*typechecking::NamedParameter
            /*let vars = map::keys((@scpe).fields)
            for var i in 0..vars.size {
                let v = vars[i]
                print(v, "\n")
            }*/
            let name = (@scope::get(scpe, parser::make_identifier([(@np).name]))).assembly_name
            let buf = buffer::make_buffer()
            buffer::append_str(*buf, name)
            buffer::append_str(*buf, ".value")
            // Rename to name.value
            (@np).name = buffer::to_string(*buf)
            // Insert alloca and store instructions

            let alloca = allocate(Insn)
            (@alloca).kind = InsnKind::ALLOCA
            (@alloca).value.alloca = {
                ret = {
                    kind = ValueKind::LOCAL,
                    name = name,
                    tpe = (@np).value
                } !Value
            } !InsnAlloca

            push_insn(alloca, state)

            let store = allocate(Insn)
            (@store).kind = InsnKind::STORE
            (@store).value.store = {
                value = {
                    kind = ValueKind::LOCAL,
                    name = (@np).name,
                    tpe = (@np).value
                } !Value,
                loc = {
                    kind = ValueKind::LOCAL,
                    name = name,
                    tpe = typechecking::pointer((@np).value)
                } !Value
            } !InsnStore

            push_insn(store, state)
        }

        for var i in 0..vector::length(body) {
            let node = vector::get(body, i) !*parser::Node
            walk(node, state)
        }

        // TODO Make another compiler pass that checks for missing return statements and dead code
        if not (@function).ret {
            // Check for missing return statement
            let last_insn = vector::peek((@(@state).current_block).insn) !*Insn
            if not last_insn or last_insn and (@last_insn).kind != InsnKind::RET {
                let ret = allocate(Insn)
                (@ret).kind = InsnKind::RET
                (@ret).value.ret.value = NO_VALUE
                push_insn(ret, state)
            }
        }
    }
    map::put((@state).result.functions, (@function).name, function)
}

def walk_Def(node: *parser::Node, state: *State){
    create_function((@node).tpe, (@node).value.def_.body, (@node).scope, state)
}

def walk_TypeDecl(node: *parser::Node, state: *State) {
    let left = (@node).value.type_decl.left
    for var i in 0..vector::length(left) {
        let n = vector::get(left, i) !*parser::Node
        let tpe = (@n).tpe
        if not tpe { continue }
        if (@tpe).kind == typechecking::TypeKind::STRUCT or
            (@tpe).kind == typechecking::TypeKind::UNION {
            
            map::put((@state).result.structures, (@tpe).type_name, tpe)
        }
    }
}

def walk_top_VarDecl(node: *parser::Node, body: *vector::Vector, state: *State) {
    let left = vector::make()
    for var i in 0..vector::length((@node).value.var_decl.left) {
        let n = vector::get((@node).value.var_decl.left, i) !*parser::Node
        if (@n).kind == parser::NodeKind::ID_DECL {
            let v = (@n).value.id_decl.value
            let value = scope::get((@node).scope, v)
            if not value { continue }
            let name = (@value).assembly_name
            
            let global = allocate(Value)
            (@global).kind = ValueKind::GLOBAL
            (@global).name = name
            (@global).tpe = (@v).tpe
            map::put((@state).result.globals, (@global).name, global)
            vector::push(left, (@n).value.id_decl.value)
        } else {
            vector::push(left, (@n).value.expr)
        }
    }
    if vector::length((@node).value.var_decl.right) > 0 {
        let node_assign = allocate(parser::Node)
        (@node_assign).kind = parser::NodeKind::ASSIGN
        (@node_assign).loc = (@node).loc
        (@node_assign).scope = (@node).scope
        (@node_assign).value.assign = {
            left = left,
            right = (@node).value.var_decl.right
        } !NodeAssign
        vector::push(body, node_assign)
    }
}

export def compile(node: *parser::Node, filename: string, module: string) -> Result {
    assert((@node).kind == parser::NodeKind::PROGRAM)
    
    let body = vector::make()
    let state = {
        filename = filename,
        module = module,
        loops = vector::make(),
        result = {
            functions = map::make(),
            structures = map::make(),
            globals = map::make()
        } !Result
    } !State

    for var i in 0..vector::length((@node).value.body) {
        let n = vector::get((@node).value.body, i) !*parser::Node
        switch (@n).kind !int {
            case parser::NodeKind::DEF:
                walk_Def(n, *state)
            case parser::NodeKind::TYPE_DECL:
                walk_TypeDecl(n, *state)
            case parser::NodeKind::VAR_DECL:
                walk_top_VarDecl(n, body, *state)
            case:
                vector::push(body, n)
        }
    }
    let ident = parser::make_identifier(["main"])
    (@ident).loc.module = module
    (@ident).loc.filename = filename
    let main_tpe = typechecking::make_type(typechecking::TypeKind::FUNCTION, ident)
    
    let string_array_tpe = allocate(typechecking::Type)
    (@string_array_tpe).kind = typechecking::TypeKind::ARRAY
    (@string_array_tpe).tpe = builtins::string_

    let named = allocate(typechecking::NamedParameter)
    (@named).name = "args"
    (@named).value = string_array_tpe
    let args = vector::make()
    vector::push(args, named)

    (@main_tpe).parameter_t = args
    // TODO Infer return types
    (@main_tpe).return_t = vector::make()

    scope::create_variable(
        (@node).scope, 
        parser::make_identifier(["args"]), 
        parser::ShareMarker::NONE, 
        parser::VarDecl::VAR, 
        string_array_tpe, null
    )

    create_function(main_tpe, body, (@node).scope, *state)

    return state.result
}
