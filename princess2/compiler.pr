import parser
import vector
import map
import typechecking
import util
import builtins

export type Label = struct {
    name: string
}

export type ValueKind = enum {
    LOCAL; GLOBAL;
    INT; FLOAT; STRING
    ARRAY; STRUCT
}

export type Value = struct {
    kind: ValueKind
    name: string
    sign: int
    i: uint64
    f: double
    s: string
    // Used for both struct and array
    values: [Value]
    tpe: *typechecking::Type
}

export type InsnKind = enum {
    ADD; SUB; MUL; SREM; UREM; SDIV; UDIV
    FADD; FSUB; FMUL; FREM; FDIV
    RET; LOAD; STORE
}

export tpye InsnStore = struct {
    value: Value
    loc: Value
}

export type InsnLoad = struct {
    tpe: *typechecking::Type
    loc: Value
}

export type InsnReturn = struct {
    tpe: *typechecking::Type
    value: Value
}

export type InsnArithmetic = struct {
    ret: Value
    left: Value
    right: Value
    tpe: *typechecking::Type
}

export type InsnValue = struct #union {
    arith: InsnArithmetic
    ret: InsnReturn
    store: InsnStore
    load: InsnLoad
}

export type Insn = struct {
    kind: InsnKind
    value: InsnValue
}

// Block for CFG
export type Block = struct {
    label_: string
    // Vector of Insn
    insn: *vector::Vector
    next: *Block
}

export type Function = struct {
    name: string
    // Vector of typechecking::NamedParameter
    args: *vector::Vector
    ret: *typechecking::Type
    // First node
    block: *Block
}

export type Structure = struct {
    name: string
    packed: bool
    // Vector of typechecking::Type
    values: *vector::Vector
}

export type Global = struct {
    name: string
    tpe: *typechecking::Type
}

export type Result = struct {
    functions: *map::Map
    structures: *map::Map
    globals: *map::Map
}

type State = struct {
    label_counter: int
    counter: int
    filename: string
    module: string
    current_function: *Function
    current_block: *Block
    result: Result
}

def make_unique_name(state: *State) -> string {
    let s = util::int_to_str((@state).counter)
    (@state).counter += 1
    return s
}

def walk_expression(node: *parser::Node, state: *State) -> Value

def walk_Integer(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    let value = {
        kind = ValueKind::INT,
        i = (@tpe).i,
        sign = (@tpe).sign
    } !Value
    return value
}

def walk_Add(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe

    var insn_kind = InsnKind::ADD
    if typechecking::is_float(tpe) {
        insn_kind = InsnKind::FADD
    }

    // TODO Type conversions
    let left = walk_expression((@node).value.bin_op.left, state)
    let right = walk_expression((@node).value.bin_op.right, state)

    let value = { 
        kind = ValueKind::LOCAL, 
        name = make_unique_name(state),
        tpe = tpe 
    } !Value
    
    let insn = allocate(Insn)
    (@insn).kind = insn_kind
    (@insn).value.arith = {
        left = left,
        right = right,
        ret = value,
        tpe = tpe
    } !InsnArithmetic

    vector::push((@(@state).current_block).insn, insn)

    return value
}

def walk_Assign(node: *parser::Node, state: *State) -> Value {

}

def walk_expression(node: *parser::Node, state: *State) -> Value {
    switch (@node).kind !int {
        case parser::NodeKind::INTEGER:
            return walk_Integer(node, state)
        case parser::NodeKind::ADD:
            return walk_Add(node, state)
        case parser::NodeKind::ASSIGN:
            return walk_Assign(node, state)
        case:
            assert(false)
    }
}

def walk(node: *parser::Node, state: *State) {
    switch (@node).kind !int {
        case: walk_expression(node, state)
    }
}

def create_function(tpe: *typechecking::Type, body: *vector::Vector, state: *State) {
    let function = allocate(Function)
    (@function).name = typechecking::mangle_function_name((@tpe).type_name, (@tpe).parameter_t)
    (@function).args = (@tpe).parameter_t

    if vector::length((@tpe).return_t) > 1 {
        // Create anonymous struct as return type
        let ret_tpe = typechecking::make_anonymous_type(typechecking::TypeKind::STRUCT, (@state).module)
        let length = vector::length((@tpe).return_t)
        let fields = allocate(typechecking::StructMember, length)

        // TODO Somehow refactor this with typechecking::type_lookup
        var offset = 0
        var align = 1
        for var i in 0..length {
            let tpe = vector::get((@tpe).return_t, i) !*typechecking::Type
            let name = util::int_to_str(i)

            offset = (ceil(offset / (@tpe).align !double) * (@tpe).align) !int
            align = util::lcm(align, (@tpe).align)

            fields[i] = { name, tpe, offset } !StructMember
            offset += (@tpe).size
        }
        offset = (ceil(offset / align !double) * align) !int

        (@ret_tpe).size = offset
        (@ret_tpe).align = align
        (@ret_tpe).fields = fields

        (@function).ret = ret_tpe

        // Store return type in structures
        map::put((@state).result.structures, (@ret_tpe).type_name, ret_tpe)
    } else if vector::length((@tpe).return_t) == 1 {
        (@function).ret = vector::get((@tpe).return_t, 0) !*typechecking::Type
    } else {
        (@function).ret = null
    }

    (@state).current_function = function
    (@state).counter = 0
    (@state).label_counter = 1
    
    let block = allocate(Block)
    (@block).label_ = "start"
    (@block).insn = vector::make()
    (@block).next = null

    (@function).block = block
    (@state).current_block = block

    for var i in 0..vector::length(body) {
        let node = vector::get(body, i)
        walk(node, state)
    }
    map::put((@state).result.functions, (@function).name, function)

    // TODO Make another compiler pass that checks for missing return statements and dead code
    if not (@function).ret {
        // Check for missing return statement
        var last_block = block
        while (@last_block).next {
            last_block = (@last_block).next
        }
        let last_insn = vector::peek((@last_block).insn) !*Insn
        if last_insn and (@last_insn).kind != InsnKind::RET {
            let ret = allocate(Insn)
            (@ret).kind = InsnKind::RET
            (@ret).value.ret.tpe = null
            vector::push((@last_block).insn, ret)
        }
    }
}

def walk_Def(node: *parser::Node, state: *State){
    create_function((@node).tpe, (@node).value.def_.body, state)
}

def walk_TypeDecl(node: *parser::Node, state: *State) {

}

def walk_top_VarDecl(node: *parser::Node, body: *vector::Vector, state: *State) {
    let left = vector::make()
    for i in 0..vector::length((@node).value.var_decl.left) {
        let n = vector::get((@node).value.var_decl.left, i) !*parser::Node
        if (@n).kind == parser::NodeKind::ID_DECL {
            let global = allocate(Global)
            (@global).name = parser::last_ident_to_str((@n).value.id_decl.value)
            (@global).tpe = (@n).tpe
            map::put((@state).globals, (@global).name, global)
            vector::push(left, (@n).value.id_decl.value)
        } else {
            vector::push(left, (@n).value.expr)
        }
    }
    if vector::length((@node).value.var_decl.right) > 0 {
        let node_assign = allocate(parser::Node)
        (@node_assign).kind = parser::NodeKind::ASSIGN
        (@node_assign).loc = (@node).loc
        (@node_assign).value.assign = {
            left = left
            right = (@node).value.var_decl.right
        } !NodeAssign
        vector::push(body, node_assign)
    }
}

export def compile(node: *parser::Node, filename: string, module: string) -> Result {
    assert((@node).kind == parser::NodeKind::PROGRAM)
    
    let body = vector::make()
    let state = {
        filename = filename,
        module = module,
        result = {
            functions = map::make(),
            structures = map::make(),
            globals = map::make()
        } !Result
    } !State

    for var i in 0..vector::length((@node).value.body) {
        let n = vector::get((@node).value.body, i) !*parser::Node
        switch (@n).kind !int {
            case parser::NodeKind::DEF:
                walk_Def(n, *state)
            case parser::NodeKind::TYPE_DECL:
                walk_TypeDecl(n, *state)
            case parser::NodeKind::VAR_DECL:
                walk_top_VarDecl(n, body, *state)
            case:
                vector::push(body, n)
        }
    }
    let ident = parser::make_identifier(["main"])
    (@ident).loc.module = module
    (@ident).loc.filename = filename
    let main_tpe = typechecking::make_type(typechecking::TypeKind::FUNCTION, ident)
    
    let string_array_tpe = allocate(typechecking::Type)
    (@string_array_tpe).kind = typechecking::TypeKind::ARRAY
    (@string_array_tpe).tpe = builtins::string_

    let named = allocate(typechecking::NamedParameter)
    (@named).name = "args"
    (@named).value = string_array_tpe
    let args = vector::make()
    vector::push(args, named)

    (@main_tpe).parameter_t = args
    // TODO Infer return types
    (@main_tpe).return_t = vector::make()

    create_function(main_tpe, body, *state)

    return state.result
}
