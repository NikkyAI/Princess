// TODO Right now pretty much every operation is adding a load instruction
// This is because every sub expression can be used as a value, even if only 
// the address is used. A potential fix would be to add a flag to walk_expression
// only when the value is needed. The optimizer discards the load instructions
// but its still better if they aren't present in the first place

import buffer
import parser
import vector
import map
import scope
import util
import debug
import toolchain
import builtins
import typechecking

export type Label = struct {
    name: string
}

export type ValueKind = enum {
    NULL; LOCAL; GLOBAL;
    BOOL; INT; FLOAT; STRING
    ARRAY; STRUCT; UNION; TYPE
}

export type Value = struct {
    kind: ValueKind
    name: string
    sign: int
    i: uint64
    f: double
    s: string
    undef: bool
    // This is the value of a type
    value_tpe: *typechecking::Type
    value: *Value
    // Used for both struct and array
    values: [Value]
    // Address of a value
    addr: *Value
    tpe: *typechecking::Type
}

export let NO_VALUE = { kind = ValueKind::NULL, tpe = null } !Value

export type InsnKind = enum {
    ADD; SUB; MUL; SREM; UREM; SDIV; UDIV
    FADD; FSUB; FMUL; FREM; FDIV; ASHR; SHL
    AND; OR; XOR; FCMP; ICMP
    RET; LOAD; STORE; ALLOCA
    INSERTVALUE; EXTRACTVALUE; GETELEMENTPTR
    TRUNC; ZEXT; SEXT; FPTRUNC; FPEXT
    FPTOUI; FPTOSI; UITOFP; SITOFP
    PTRTOINT; INTTOPTR; BITCAST
    CALL; BR_UNC; BR; UNREACHABLE
}

// Floating point constants
export let f_ueq = "ueq"
export let f_ugt = "ugt"
export let f_uge = "uge"
export let f_ult = "ult"
export let f_ule = "ule"
export let f_une = "une"

// Integer constants
export let i_eq  = "eq"
export let i_ne  = "ne"
export let i_ugt = "ugt"
export let i_uge = "uge"
export let i_ult = "ult"
export let i_ule = "ule"
export let i_sgt = "sgt"
export let i_sge = "sge"
export let i_slt = "slt"
export let i_sle = "sle"

export type InsnCmp = struct {
    op: string
    ret: Value
    left: Value
    right: Value
}

export type InsnInsertValue = struct {
    ret: Value
    value: Value
    element: Value
    index: [int]
}

export type InsnGetElementPtr = struct {
    ret: Value
    // Here the type isn't the same as ret
    tpe: *typechecking::Type
    value: Value
    index: [Value]
}

export type InsnConvert = struct {
    ret: Value
    value: Value
}

export type InsnExtractValue = struct {
    ret: Value
    value: Value
    index: [int]
}

export type InsnStore = struct {
    value: Value
    loc: Value
}

export type InsnLoad = struct {
    value: Value
    loc: Value
}

export type InsnReturn = struct {
    value: Value
}

export type InsnArithmetic = struct {
    ret: Value
    left: Value
    right: Value
}

export type InsnAlloca = struct {
    ret: Value
}

export type InsnCall = struct {
    name: Value
    ret: Value
    args: [Value]
    proto: [typechecking::NamedParameter]
}

export type InsnBrUnc = struct {
    label_: Label
}

export type InsnBr = struct {
    cond: Value
    if_true: Label
    if_false: Label
}

export type InsnValue = struct #union {
    arith: InsnArithmetic
    ret: InsnReturn
    store: InsnStore
    load: InsnLoad
    alloca: InsnAlloca
    call: InsnCall
    br_unc: InsnBrUnc
    br: InsnBr
    insert_value: InsnInsertValue
    extract_value: InsnExtractValue
    gep: InsnGetElementPtr
    convert: InsnConvert
    cmp: InsnCmp
}

export type Insn = struct {
    kind: InsnKind
    value: InsnValue
}

// Block for CFG
export type Block = struct {
    label_: string
    // Vector of Insn
    insn: *vector::Vector
    next: *Block
}

export type Function = struct {
    name: string
    unmangled: string
    // Vector of typechecking::NamedParameter
    args: *vector::Vector
    ret: *typechecking::Type
    multiple_returns: bool
    forward_declare: bool
    // First node
    block: *Block
}

export type Result = struct {
    functions: *map::Map
    structures: *map::Map
    globals: *map::Map
}

type LoopState = struct {
    break_insn: *Insn
    continue_insn: *Insn
}

export type State = struct {
    module: *toolchain::Module
    counter: int
    global_counter: int
    // TODO Make this a stack for nested functions
    current_function: *Function
    current_block: *Block
    // Vector of LoopState 
    loops: *vector::Vector
    result: *Result
}

def make_value(tpe: *typechecking::Type, value: *) -> Value {
    switch (@tpe).kind !int {
        case typechecking::TypeKind::TYPE:
            return {kind = ValueKind::TYPE, tpe = typechecking::type_, value_tpe = value !*typechecking::Type} !Value
        case typechecking::TypeKind::WORD:
            return {kind = ValueKind::INT, tpe = builtins::int_, sign = 1, i = @(value !*uint64)} !Value
        case typechecking::TypeKind::FLOAT:
            return {kind = ValueKind::FLOAT, tpe = builtins::double_, f = @(value !*double)} !Value
        case typechecking::TypeKind::BOOL:
            return {kind = ValueKind::BOOL, tpe = builtins::bool_, sign = 1, i = @(value !*uint64)} !Value
        case:
            error((@tpe).kind, "\n") 
            assert(false)
    }
}

def get_break_insn(state: *State) -> *Insn {
    if vector::length((@state).loops) > 0 {
        return (@(vector::peek((@state).loops) !*LoopState)).break_insn
    }
    return null
}

def get_continue_insn(state: *State) -> *Insn {
    if vector::length((@state).loops) > 0 {
        return (@(vector::peek((@state).loops) !*LoopState)).continue_insn
    }
    return null
}

def push_loop_state(state: *State) {
    let loops = allocate(LoopState)

    let break_insn = allocate(Insn)
    (@break_insn).kind = InsnKind::BR_UNC
    let continue_insn = allocate(Insn)
    (@continue_insn).kind = InsnKind::BR_UNC

    (@loops).break_insn = break_insn
    (@loops).continue_insn = continue_insn
    
    vector::push((@state).loops, loops)
}

def pop_loop_state(state: *State) {
    vector::pop((@state).loops)
}

export def make_label(state: *State) -> Label {
    let s = util::int_to_str((@state).counter)
    (@state).counter += 1
    return { name = s } !Label
}

export def make_unique_name(state: *State) -> string {
    let s = util::int_to_str((@state).counter)
    (@state).counter += 1
    return s
}

export def make_int_value(v: int) -> Value {
    var i = v
    var sign = 1
    if i < 0 {
        i = -i
        sign = -1
    }
    let value = {
        kind = ValueKind::INT,
        i = i,
        sign = sign,
        tpe = builtins::int_
    } !Value

    if v < 0 {
        value.sign = -1
    } else {
        value.sign = 1
    }

    return value
}

export def make_local_value(tpe: *typechecking::Type, addr: *Value, state: *State) -> Value {
    return {
        kind = ValueKind::LOCAL,
        name = make_unique_name(state),
        tpe = tpe,
        addr = addr
    } !Value
}

export def make_global_value(tpe: *typechecking::Type, name: string, value: *Value, state: *State) -> Value {
    let buf = buffer::make_buffer()
    buffer::append_str(*buf, name)
    buffer::append_char(*buf, '.')
    buffer::append_str(*buf, util::int_to_str((@state).global_counter))
    name = buffer::to_string(*buf)
    (@state).global_counter += 1

    let global = allocate(Value)
    (@global).kind = ValueKind::GLOBAL
    (@global).undef = false
    (@global).name = name
    (@global).value = value
    (@global).tpe = tpe
    map::put((@(@state).result).globals, (@global).name, global)

    return {
        kind = ValueKind::GLOBAL,
        name = name,
        tpe = typechecking::pointer(tpe),
        addr = null
    } !Value
}

export def push_label(label_: Label, state: *State) {
    let block = allocate(Block)
    // TODO Might want to use the actual label here
    (@block).label_ = label_.name
    (@block).insn = vector::make()
    (@block).next = null
    (@(@state).current_block).next = block
    (@state).current_block = block
}

export def push_insn(insn: *Insn, state: *State) {
    vector::push((@(@state).current_block).insn, insn)
}

export def walk_expression(node: *parser::Node, state: *State) -> Value
export def walk(node: *parser::Node, state: *State)

def walk_Null(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    let value = {
        kind = ValueKind::NULL,
        tpe = tpe
    } !Value
    return value
}

def walk_Boolean(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    let value = {
        kind = ValueKind::BOOL,
        i = (@node).value.i,
        sign = 1,
        tpe = tpe
    } !Value
    return value
}

def walk_Integer(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    let value = {
        kind = ValueKind::INT,
        i = (@node).value.i,
        sign = 1,
        tpe = tpe
    } !Value
    return value
}

def walk_Float(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    let value = {
        kind = ValueKind::FLOAT,
        f = (@node).value.f,
        tpe = tpe
    } !Value
    return value
}

def walk_Char(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    let value = {
        kind = ValueKind::INT,
        i = (@node).value.i,
        sign = 1,
        tpe = tpe
    } !Value
    return value    
}

def walk_String(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    
    let str_value = allocate(Value)
    @str_value = {
        kind = ValueKind::STRING,
        s = (@node).value.str,
        tpe = tpe
    } !Value

    let global = make_global_value(tpe, "str", str_value, state)
    let globalp = allocate(Value)
    (@globalp) = global

    let local = make_local_value(tpe, globalp, state)
    
    let load = allocate(Insn)
    (@load).kind = InsnKind::LOAD
    (@load).value.load = {
        value = local,
        loc = global
    } !InsnLoad

    push_insn(load, state)

    return local
}

def convert_to(node: *parser::Node, value: Value, tpe: *typechecking::Type, state: *State) -> Value {
    if not value.tpe or not tpe { return value }
    
    if typechecking::equals(value.tpe, tpe) {
        return value
    }

    var kind: InsnKind
    if (@tpe).kind == typechecking::TypeKind::ARRAY {
        if (@value.tpe).kind == typechecking::TypeKind::STATIC_ARRAY and 
            (not (@tpe).tpe or typechecking::equals((@tpe).tpe, (@value.tpe).tpe)) {

            var local = make_local_value(typechecking::pointer((@value.tpe).tpe), null, state)

            let index = allocate(Value, 2)
            index[0] = make_int_value(0)
            index[0].tpe = builtins::size_t_
            index[1] = make_int_value(0)
            index[1].tpe = builtins::size_t_

            let gep = allocate(Insn)
            (@gep).kind = InsnKind::GETELEMENTPTR
            (@gep).value.gep = {
                ret = local,
                tpe = value.tpe,
                value = @value.addr,
                index = index
            } !InsnGetElementPtr

            push_insn(gep, state)

            if not (@tpe).tpe {
                let local1 = local
                local = make_local_value(typechecking::pointer(null), null, state)
                let bitcast = allocate(Insn)
                (@bitcast).kind = InsnKind::BITCAST
                (@bitcast).value.convert = {
                    ret = local,
                    value = local1
                } !InsnConvert

                push_insn(bitcast, state)
            }

            let ret = make_local_value(tpe, null, state)

            let values = allocate(Value, 2)
            values[0] = {
                kind = ValueKind::INT,
                tpe = builtins::size_t_,
                i = (@value.tpe).length,
                sign = 1
            } !Value
            values[1] = {
                undef = true,
                tpe = typechecking::pointer((@tpe).tpe)
            }

            let value = {
                kind = ValueKind::STRUCT,
                values = values,
                tpe = tpe
            } !Value

            let index2 = allocate(int, 1)
            index2[0] = 1
            let insert = allocate(Insn)
            (@insert).kind = InsnKind::INSERTVALUE
            (@insert).value.insert_value = {
                ret = ret,
                value = value,
                element = local, 
                index = index2
            } !InsnInsertValue

            push_insn(insert, state)

            return ret
        } else if not (@tpe).tpe and (@value.tpe).kind == typechecking::TypeKind::ARRAY {
            let index1 = allocate(int, 1)
            index1[0] = 0

            let size = make_local_value(builtins::size_t_, null, state)
            let extract1 = allocate(Insn)
            (@extract1).kind = InsnKind::EXTRACTVALUE
            (@extract1).value.extract_value = {
                ret = size,
                value = value,
                index = index1
            } !InsnExtractValue

            push_insn(extract1, state)

            let index2 = allocate(int, 1)
            index2[0] = 1

            let ptr = make_local_value(typechecking::pointer((@value.tpe).tpe), null, state)
            let extract2 = allocate(Insn)
            (@extract2).kind = InsnKind::EXTRACTVALUE
            (@extract2).value.extract_value = {
                ret = ptr,
                value = value,
                index = index2
            } !InsnExtractValue

            push_insn(extract2, state)

            let bitcast_ret = make_local_value(typechecking::pointer(null), null, state)
            let bitcast = allocate(Insn)
            (@bitcast).kind = InsnKind::BITCAST
            (@bitcast).value.convert = {
                ret = bitcast_ret,
                value = ptr
            } !InsnConvert

            push_insn(bitcast, state)

            let insert1_ret = make_local_value(tpe, null, state)
            let insert1 = allocate(Insn)
            (@insert1).kind = InsnKind::INSERTVALUE
            (@insert1).value.insert_value = {
                ret = insert1_ret,
                value = { kind = ValueKind::STRUCT, undef = true, tpe = tpe } !Value,
                element = size,
                index = index1
            } !InsnInsertValue

            push_insn(insert1, state)

            let insert2_ret = make_local_value(tpe, null, state)
            let insert2 = allocate(Insn)
            (@insert2).kind = InsnKind::INSERTVALUE
            (@insert2).value.insert_value = {
                ret = insert2_ret,
                value = insert1_ret,
                element = bitcast_ret,
                index = index2
            } !InsnInsertValue

            push_insn(insert2, state)

            return insert2_ret
        } else {
            typechecking::errorn(node, "Can't convert ")
            error(debug::type_to_str(value.tpe), " to ", debug::type_to_str(tpe), "\n")
            return value
        }
    } else if (@tpe).kind == typechecking::TypeKind::BOOL {
        if typechecking::is_pointer(value.tpe) {
            // TODO This isn't the correct type, we need something like
            // intptr_t
            value = convert_to(node, value, builtins::size_t_, state)
        }
        if typechecking::is_float(value.tpe) {
            let ret = make_local_value(builtins::bool_, null, state)
            let insn = allocate(Insn)
            (@insn).kind = InsnKind::FCMP
            (@insn).value.cmp = {
                op = f_une,
                ret = ret,
                left = value,
                right = {
                    kind = ValueKind::FLOAT,
                    tpe = value.tpe,
                    f = 0.0
                } !Value
            }
            push_insn(insn, state)
            return ret
        } else if typechecking::is_integer(value.tpe) {
            let ret = make_local_value(builtins::bool_, null, state)
            let insn = allocate(Insn)
            (@insn).kind = InsnKind::ICMP
            (@insn).value.cmp = {
                op = i_ne,
                ret = ret,
                left = value,
                right = {
                    kind = ValueKind::INT,
                    tpe = value.tpe,
                    i = 0,
                    sign = 1
                } !Value
            }
            push_insn(insn, state)
            return ret
        } else {
            // TODO Arrays and Co
            typechecking::errorn(node, "Can't convert ")
            error(debug::type_to_str(value.tpe), " to ", debug::type_to_str(tpe), "\n")
            return value
        }
    } else if typechecking::is_integer(tpe) {
        if typechecking::is_integer(value.tpe) {
            if (@value.tpe).size == (@tpe).size {
                // Types only differ in sign, llvm doesn't treat them any different
                return value
            } else if (@value.tpe).size > (@tpe).size {
                kind = InsnKind::TRUNC
            } else if (@tpe).unsig {
                kind = InsnKind::ZEXT
            } else {
                kind = InsnKind::SEXT
            }
        } else if typechecking::is_float(value.tpe) {
            if (@tpe).unsig {
                kind = InsnKind::FPTOUI
            } else {
                kind = InsnKind::FPTOSI
            }
        } else if typechecking::is_pointer(value.tpe) {
            kind = InsnKind::PTRTOINT
        } else {
            typechecking::errorn(node, "Can't convert ")
            error(debug::type_to_str(value.tpe), " to ", debug::type_to_str(tpe), "\n")
            return value
        }
    } else if typechecking::is_float(tpe) {
        if typechecking::is_integer(value.tpe) {
            if (@value.tpe).unsig {
                kind = InsnKind::UITOFP
            } else {
                kind = InsnKind::SITOFP
            }
        } else if typechecking::is_float(value.tpe) {
            if (@value.tpe).size > (@tpe).size {
                kind = InsnKind::FPTRUNC
            } else {
                kind = InsnKind::FPEXT
            }
        } else {
            typechecking::errorn(node, "Can't convert ")
            error(debug::type_to_str(value.tpe), " to ", debug::type_to_str(tpe), "\n")
            return value
        }
    } else if typechecking::is_pointer(tpe) {
        if typechecking::is_pointer(value.tpe) {
            kind = InsnKind::BITCAST
        } else if typechecking::is_integer(value.tpe) {
            kind = InsnKind::INTTOPTR
        } else {
            typechecking::errorn(node, "Can't convert ")
            error(debug::type_to_str(value.tpe), " to ", debug::type_to_str(tpe), "\n")
            return value
        }
    } else {
        typechecking::errorn(node, "Can't convert ")
        error(debug::type_to_str(value.tpe), " to ", debug::type_to_str(tpe), "\n")
        return value
    }

    let ret = make_local_value(tpe, null, state)

    let insn = allocate(Insn)
    (@insn).kind = kind
    (@insn).value.convert = {
        ret = ret,
        value = value
    } !InsnConvert

    push_insn(insn, state)

    return ret
}

def walk_Cast(node: *parser::Node, state: *State) -> Value {
    let value = walk_expression((@node).value.expr, state)
    return convert_to(node, value, (@node).tpe, state)
}

def walk_StructLit(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe

    if not tpe {
        typechecking::errorn(node, "Need to specify a type for struct literal\n")
        return NO_VALUE
    }

    let args = (@node).value.struct_lit.args
    let kwargs = (@node).value.struct_lit.kwargs

    let values = allocate(Value, (@tpe).fields.size)
    for var i in 0..vector::length(args) {
        let arg = vector::get(args, i) !*parser::Node
        let value = walk_expression(arg, state)
        if i > values.size {
            typechecking::errorn(arg, "Too many arguments to struct literal\n")
            return NO_VALUE
        }
        values[i] = value
    }
    for var i in 0..vector::length(kwargs) {
        let kwarg = vector::get(kwargs, i) !*parser::Node
        let name = typechecking::last_ident_to_str((@kwarg).value.named_arg.name)
        let value = walk_expression((@kwarg).value.named_arg.value, state)
        
        var found = false
        for var j in 0..(@tpe).fields.size {
            let field_name = (@tpe).fields[j].name
            if field_name == name {
                values[j] = value
                found = true
                break
            }
        }
        if not found {
            typechecking::errorn(kwarg, "Unknown field \"")
            error(name, "\"\n")
            return NO_VALUE
        }
    }
    var value = {
        kind = ValueKind::STRUCT,
        values = values,
        tpe = tpe
    } !Value

    for var i in 0..values.size {
        let val = values[i]
        if val.kind == ValueKind::LOCAL or val.kind == ValueKind::GLOBAL {
            values[i] = {
                undef = true,
                tpe = val.tpe
            } !Value

            let ret = make_local_value(tpe, null, state)
            
            let index = allocate(int, 1)
            index[0] = i
            let insert = allocate(Insn)
            (@insert).kind = InsnKind::INSERTVALUE
            (@insert).value.insert_value = {
                ret = ret,
                value = value,
                element = val,
                index = index
            } !InsnInsertValue
            
            push_insn(insert, state)
            value = ret
        }
    }
    
    return value
}

def walk_ArithmeticOp(node: *parser::Node, insn_kind: InsnKind, tpe: *typechecking::Type, state: *State) -> Value {
    let left = convert_to(node, walk_expression((@node).value.bin_op.left, state), tpe, state)
    let right = convert_to(node, walk_expression((@node).value.bin_op.right, state), tpe, state)

    let value = make_local_value(tpe, null, state)
    let insn = allocate(Insn)
    (@insn).kind = insn_kind
    (@insn).value.arith = {
        left = left,
        right = right,
        ret = value
    } !InsnArithmetic

    push_insn(insn, state)

    return value
}

def walk_Not(node: *parser::Node, state: *State) -> Value {
    let expr = convert_to(node, walk_expression((@node).value.expr, state), builtins::bool_, state)
    
    let ret = make_local_value(builtins::bool_, null, state)
    let xor = allocate(Insn)
    (@xor).kind = InsnKind::XOR
    (@xor).value.arith = {
        ret = ret,
        left = expr,
        right = { kind = ValueKind::BOOL, i = 1, sign = 1, tpe = builtins::bool_ } !Value
    } !InsnArithmetic

    push_insn(xor, state)
    return ret
}

// TODO It would be nice if and/or could work by returning the values themselves
def walk_And(node: *parser::Node, state: *State) -> Value {
    let left = convert_to(node, walk_expression((@node).value.bin_op.left, state), builtins::bool_, state)

    let ret_alloca = make_local_value(builtins::bool_, null, state)
    let alloca = allocate(Insn)
    (@alloca).kind = InsnKind::ALLOCA
    (@alloca).value.alloca = {
        ret = ret_alloca
    } !InsnAlloca
    ret_alloca.tpe = typechecking::pointer(builtins::bool_)

    push_insn(alloca, state)

    let br = allocate(Insn)
    (@br).kind = InsnKind::BR
    (@br).value.br = {
        cond = left
    } !InsnBr

    let to_end = allocate(Insn)
    (@to_end).kind = InsnKind::BR_UNC

    push_insn(br, state)

    let if_false = make_label(state)
    push_label(if_false, state)

    let store1 = allocate(Insn)
    (@store1).kind = InsnKind::STORE
    (@store1).value.store = {
        value = { kind = ValueKind::BOOL, i = 0, sign = 1, tpe = builtins::bool_ } !Value,
        loc = ret_alloca
    } !InsnStore

    push_insn(store1, state)
    push_insn(to_end, state)

    let if_true = make_label(state)
    push_label(if_true, state)

    let right = convert_to(node, walk_expression((@node).value.bin_op.right, state), builtins::bool_, state)

    let store2 = allocate(Insn)
    (@store2).kind = InsnKind::STORE
    (@store2).value.store = {
        value = right,
        loc = ret_alloca
    } !InsnStore

    push_insn(store2, state)
    push_insn(to_end, state)

    let end = make_label(state)
    push_label(end, state)

    (@br).value.br.if_true = if_true
    (@br).value.br.if_false = if_false
    (@to_end).value.br_unc.label_ = end

    let ret = make_local_value(builtins::bool_, null, state)
    let load = allocate(Insn)
    (@load).kind = InsnKind::LOAD
    (@load).value.load = {
        value = ret,
        loc = ret_alloca
    } !InsnLoad

    push_insn(load, state)

    return ret
}

def walk_Or(node: *parser::Node, state: *State) -> Value {
       let left = convert_to(node, walk_expression((@node).value.bin_op.left, state), builtins::bool_, state)

    let ret_alloca = make_local_value(builtins::bool_, null, state)
    let alloca = allocate(Insn)
    (@alloca).kind = InsnKind::ALLOCA
    (@alloca).value.alloca = {
        ret = ret_alloca
    } !InsnAlloca
    ret_alloca.tpe = typechecking::pointer(builtins::bool_)

    push_insn(alloca, state)

    let br = allocate(Insn)
    (@br).kind = InsnKind::BR
    (@br).value.br = {
        cond = left
    } !InsnBr

    let to_end = allocate(Insn)
    (@to_end).kind = InsnKind::BR_UNC

    push_insn(br, state)

    let if_true = make_label(state)
    push_label(if_true, state)

    let store1 = allocate(Insn)
    (@store1).kind = InsnKind::STORE
    (@store1).value.store = {
        value = { kind = ValueKind::BOOL, i = 1, sign = 1, tpe = builtins::bool_ } !Value,
        loc = ret_alloca
    } !InsnStore

    push_insn(store1, state)
    push_insn(to_end, state)

    let if_false = make_label(state)
    push_label(if_false, state)

    let right = convert_to(node, walk_expression((@node).value.bin_op.right, state), builtins::bool_, state)

    let store2 = allocate(Insn)
    (@store2).kind = InsnKind::STORE
    (@store2).value.store = {
        value = right,
        loc = ret_alloca
    } !InsnStore

    push_insn(store2, state)
    push_insn(to_end, state)

    let end = make_label(state)
    push_label(end, state)

    (@br).value.br.if_true = if_true
    (@br).value.br.if_false = if_false
    (@to_end).value.br_unc.label_ = end

    let ret = make_local_value(builtins::bool_, null, state)
    let load = allocate(Insn)
    (@load).kind = InsnKind::LOAD
    (@load).value.load = {
        value = ret,
        loc = ret_alloca
    } !InsnLoad

    push_insn(load, state)

    return ret
}

def walk_Add(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    if not tpe { return NO_VALUE }

    var insn_kind = InsnKind::ADD
    if typechecking::is_float(tpe) {
        insn_kind = InsnKind::FADD
    }
    return walk_ArithmeticOp(node, insn_kind, tpe, state)
}

def walk_Sub(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    if not tpe { return NO_VALUE }

    var insn_kind = InsnKind::SUB
    if typechecking::is_float(tpe) {
        insn_kind = InsnKind::FSUB 
    }
    return walk_ArithmeticOp(node, insn_kind, tpe, state)
}

def walk_Mul(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    if not tpe { return NO_VALUE }

    var insn_kind = InsnKind::MUL
    if typechecking::is_float(tpe) {
        insn_kind = InsnKind::FMUL 
    }
    return walk_ArithmeticOp(node, insn_kind, tpe, state)
}

def walk_Mod(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    if not tpe { return NO_VALUE }

    var insn_kind = InsnKind::SREM
    if typechecking::is_float(tpe) {
        insn_kind = InsnKind::FREM 
    } else if (@tpe).unsig {
        insn_kind = InsnKind::UREM
    }
    return walk_ArithmeticOp(node, insn_kind, tpe, state)
}

def walk_Div(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    if not tpe { return NO_VALUE }

    var insn_kind = InsnKind::SDIV
    if typechecking::is_float(tpe) {
        insn_kind = InsnKind::FDIV 
    } else if (@tpe).unsig {
        insn_kind = InsnKind::UDIV
    }
    return walk_ArithmeticOp(node, insn_kind, tpe, state)
}

def walk_Shl(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    return walk_ArithmeticOp(node, InsnKind::SHL, tpe, state)
}

def walk_Shr(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    return walk_ArithmeticOp(node, InsnKind::ASHR, tpe, state)
}

def walk_Call(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).function
    if not tpe { return NO_VALUE }
    let parameter_t = (@tpe).parameter_t

    let args = allocate(Value, 
        vector::length((@node).value.func_call.args) + 
        vector::length((@node).value.func_call.kwargs))

    for var i in 0..vector::length((@node).value.func_call.args) {
        let n = vector::get((@node).value.func_call.args, i) !*parser::Node

        var p: *typechecking::NamedParameter = null
        if i < vector::length(parameter_t) {
            p = vector::get(parameter_t, i) !*typechecking::NamedParameter
        } else {
            p = vector::peek(parameter_t) !*typechecking::NamedParameter
            if not (@p).varargs { return NO_VALUE }
        }
        var expr = walk_expression(n, state)
        expr = convert_to(n, expr, (@p).value, state)
        args[i] = expr
    }
    for var i in 0..vector::length((@node).value.func_call.kwargs) {
        let n = vector::get((@node).value.func_call.kwargs, i) !*parser::Node
        assert((@n).kind == parser::NodeKind::NAMED_ARG)
        // Find named parameter
        let name = typechecking::last_ident_to_str((@n).value.named_arg.name)
        let value = (@n).value.named_arg.value
        for var j in 0..vector::length(parameter_t) {
            let p = vector::get(parameter_t, j) !*typechecking::NamedParameter
            if (@p).name == name {
                var expr = walk_expression(value, state)
                expr = convert_to(n, expr, (@p).value, state)
                args[j] = expr
            }
        }
    }

    if (@tpe).macro {
        return (@tpe).macro(node, args, state)
    }

    var name = (@tpe).type_name
    name = typechecking::mangle_function_name(name, parameter_t)
    
    let function = map::get((@(@state).result).functions, name) !*Function
    if not function { return NO_VALUE }

    let name_v = {
        kind = ValueKind::GLOBAL,
        name = name,
        tpe = null
    } !Value

    var addr = NO_VALUE
    var value = NO_VALUE
    if (@function).ret {
        addr = make_local_value((@function).ret, null, state)
        
        let alloca = allocate(Insn)
        (@alloca).kind = InsnKind::ALLOCA
        (@alloca).value.alloca = {
            ret = addr
        } !InsnAlloca
        push_insn(alloca, state)
        
        addr.tpe = typechecking::pointer((@function).ret)
        let addrp = allocate(Value)
        (@addrp) = addr
        value = make_local_value((@function).ret, addrp, state)
    }

    let insn = allocate(Insn)
    (@insn).kind = InsnKind::CALL
    (@insn).value.call = {
        name = name_v,
        ret = value,
        args = args
    } !InsnCall

    push_insn(insn, state)

    if (@function).ret {
        let store = allocate(Insn)
        (@store).kind = InsnKind::STORE
        (@store).value.store = {
            value = value,
            loc = addr
        }
        push_insn(store, state)
    }

    return value
}

def walk_Identifier(node: *parser::Node, state: *State) -> Value {
    let val = scope::get((@node).scope, node)
    if not val { return NO_VALUE }
    if (@val).value {
        return make_value((@val).tpe, (@val).value)
    }

    let value = make_local_value((@node).tpe, null, state)

    let name = (@val).assembly_name
    var kind = ValueKind::LOCAL
    if (@val).global {
        kind = ValueKind::GLOBAL
    }

    let loc = {
        kind = kind,
        name = name,
        tpe = typechecking::pointer((@node).tpe)
    } !Value

    let l = allocate(Value)
    (@l) = loc
    value.addr = l
    
    let insn = allocate(Insn)
    (@insn).kind = InsnKind::LOAD
    (@insn).value.load = {
        value = value,
        loc = loc
    }

    push_insn(insn, state)
    return value
}

def walk_Assign(node: *parser::Node, state: *State) -> Value {
    // TODO Make this possible: a, b = c, d = e, f
    // Right now we can only return one value

    let right = (@node).value.assign.right
    let left = (@node).value.assign.left
    var last_value: Value

    var j = 0
    for var i in 0..vector::length(right) {
        let n = vector::get(right, i) !*parser::Node
        var value = walk_expression(n, state)
        let tpe = (@n).tpe
        if not tpe { continue }
        if (@tpe).kind == typechecking::TypeKind::TUPLE {
            for var k in 0..vector::length((@tpe).return_t) {
                let t = vector::get((@tpe).return_t, k) !*typechecking::Type
                if j >= vector::length(left) { return NO_VALUE }
                let l = vector::get(left, j) !*parser::Node

                let addr = walk_expression(l, state).addr
                if not addr {
                    typechecking::errorn(l, "Can't assign, expression has no address\n")
                    return NO_VALUE
                }

                let gep_ret = make_local_value(typechecking::pointer(t), null, state)

                let index = allocate(Value, 2)
                index[0] = make_int_value(0)
                index[1] = make_int_value(k)

                let gep = allocate(Insn)
                (@gep).kind = InsnKind::GETELEMENTPTR
                (@gep).value.gep = {
                    ret = gep_ret,
                    tpe = value.tpe,
                    value = @value.addr,
                    index = index
                } !InsnGetElementPtr

                push_insn(gep, state)
                
                let gep_retp = allocate(Value)
                @gep_retp = gep_ret
                var ret = make_local_value(t, gep_retp, state)

                let load = allocate(Insn)
                (@load).kind = InsnKind::LOAD
                (@load).value.load = {
                    value = ret,
                    loc = gep_ret
                } !InsnLoad

                push_insn(load, state)

                ret = convert_to(n, ret, (@l).tpe, state)

                let store = allocate(Insn)
                (@store).kind = InsnKind::STORE
                (@store).value.store = {
                    value = ret,
                    loc = @addr
                } !InsnStore

                push_insn(store, state)

                last_value = ret
                j += 1
            }
        } else {
            if j >= vector::length(left) { return NO_VALUE }
            let l = vector::get(left, j) !*parser::Node
            // TODO This adds a useless load instruction
            let addr = walk_expression(l, state).addr
            if not addr { 
                typechecking::errorn(l, "Can't assign, expression has no address\n")
                return NO_VALUE 
            }

            value = convert_to(n, value, (@l).tpe, state)

            let store = allocate(Insn)
            (@store).kind = InsnKind::STORE
            (@store).value.store = {
                value = value,
                loc = @addr
            } !InsnStore

            push_insn(store, state)

            last_value = value
            j += 1
        }
    }
    return last_value
}

def walk_AssignEq(node: *parser::Node, state: *State) -> Value {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right

    var kind: parser::NodeKind
    switch (@node).kind !int {
        case parser::NodeKind::PADD_EQ: kind = parser::NodeKind::PADD
        case parser::NodeKind::PSUB_EQ: kind = parser::NodeKind::PSUB
        case parser::NodeKind::ADD_EQ:  kind = parser::NodeKind::ADD
        case parser::NodeKind::SUB_EQ:  kind = parser::NodeKind::SUB
        case parser::NodeKind::MUL_EQ:  kind = parser::NodeKind::MUL
        case parser::NodeKind::DIV_EQ:  kind = parser::NodeKind::DIV
        case parser::NodeKind::MOD_EQ:  kind = parser::NodeKind::MOD
        case parser::NodeKind::AND_EQ:  kind = parser::NodeKind::BAND
        case parser::NodeKind::OR_EQ:   kind = parser::NodeKind::BOR
        case parser::NodeKind::XOR_EQ:  kind = parser::NodeKind::BXOR
        case parser::NodeKind::SHL_EQ:  kind = parser::NodeKind::SHL
        case parser::NodeKind::SHR_EQ:  kind = parser::NodeKind::SHR
        case: assert(false)
    }

    let arithmetic = allocate(parser::Node)
    (@arithmetic).kind = kind
    (@arithmetic).loc = (@node).loc
    (@arithmetic).scope = (@node).scope
    (@arithmetic).tpe = (@node).tpe
    (@arithmetic).value.bin_op = {
        left = left,
        right = right
    } !parser::NodeBinaryOp

    let left_vec = vector::make()
    vector::push(left_vec, left)
    let right_vec = vector::make()
    vector::push(right_vec, arithmetic)

    let assign_eq_node = allocate(parser::Node)
    (@assign_eq_node).kind = parser::NodeKind::ASSIGN
    (@assign_eq_node).loc = (@node).loc
    (@assign_eq_node).scope = (@node).scope
    (@assign_eq_node).value.assign = {
        left = left_vec,
        right = right_vec
    } !parser::NodeAssign

    return walk_expression(assign_eq_node, state)
}

def walk_Deref(node: *parser::Node, state: *State) -> Value {
    let value = walk_expression((@node).value.expr, state)
    let tpe = value.tpe

    let addr = allocate(Value)
    (@addr) = value
    let ret = make_local_value((@tpe).tpe, addr, state)

    let load = allocate(Insn)
    (@load).kind = InsnKind::LOAD
    (@load).value.load = {
        value = ret,
        loc = value
    } !InsnLoad

    push_insn(load, state)
    return ret
}

def walk_Ptr(node: *parser::Node, state: *State) -> Value {
    let value = walk_expression((@node).value.expr, state)
    if not value.addr { return NO_VALUE }

    return @(value.addr)
}

def walk_MemberAccess_gep(node: *parser::Node, tpe: *typechecking::Type, value: Value, index: [Value], state: *State) -> Value {
    let gep_ret = make_local_value(typechecking::pointer((@node).tpe), null, state) 
    let gep = allocate(Insn)
    (@gep).kind = InsnKind::GETELEMENTPTR
    (@gep).value.gep = {
        ret = gep_ret,
        tpe = tpe,
        value = @value.addr,
        index = index
    } !InsnGetElementPtr

    let addr = allocate(Value)
    @addr = gep_ret

    let ret = make_local_value((@node).tpe, addr, state)
    let load = allocate(Insn)
    (@load).kind = InsnKind::LOAD
    (@load).value.load = {
        value = ret,
        loc = gep_ret
    } !InsnLoad

    push_insn(gep, state)
    push_insn(load, state)

    return ret
}

def walk_MemberAccess(node: *parser::Node, state: *State) -> Value {
    if not (@node).tpe { return NO_VALUE }

    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right

    let value = walk_expression(left, state)
    if not value.addr {
        typechecking::errorn(node, "Can't use member access, expression has no address\n")
        return NO_VALUE
    }

    let tpe = (@left).tpe

    // TODO This might double error
    let name = typechecking::last_ident_to_str(right)

    if (@tpe).kind == typechecking::TypeKind::STATIC_ARRAY {
        if name == "size" {
            let i = make_int_value((@tpe).length)
            i.tpe = builtins::size_t_
            return i
        } else if name == "value" {
            let index = allocate(Value, 2)
            index[0] = make_int_value(0)
            index[0].tpe = builtins::size_t_
            index[1] = make_int_value(0)
            index[1].tpe = builtins::size_t_

            let gep_ret = make_local_value((@node).tpe, null, state)
            let gep = allocate(Insn)
            (@gep).kind = InsnKind::GETELEMENTPTR
            (@gep).value.gep = {
                ret = gep_ret,
                tpe = tpe,
                value = @value.addr,
                index = index
            } !InsnGetElementPtr

            push_insn(gep, state)
            return gep_ret
        } else { assert(false) }
    } else if (@tpe).kind == typechecking::TypeKind::ARRAY {
        let index = allocate(Value, 2)
        index[0] = make_int_value(0)

        if name == "size" {
            index[1] = make_int_value(0)
        } else if name == "value" {
            index[1] = make_int_value(1)
        }

        return walk_MemberAccess_gep(node, tpe, value, index, state)
    } else {
        let index = allocate(Value, 2)
        index[0] = make_int_value(0)

        for var i in 0..(@tpe).fields.size {
            let member = (@tpe).fields[i]
            if member.name == name {
                index[1] = {
                    kind = ValueKind::INT,
                    sign = 1,
                    i = i,
                    tpe = builtins::int_
                } !Value
                break
            }
        }
        return walk_MemberAccess_gep(node, tpe, value, index, state)
    }
}

// TODO Lots of duplicate code
def walk_ArraySubscript(node: *parser::Node, state: *State) -> Value {
    if not (@node).tpe { return NO_VALUE }

    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    
    let array_tpe = (@left).tpe
    let left_value = walk_expression(left, state)
    let right_value = walk_expression(right, state)

    if (@array_tpe).kind == typechecking::TypeKind::ARRAY {
        let index1 = allocate(Value, 2)
        index1[0] = make_int_value(0)
        index1[1] = make_int_value(1)

        let gep_ret1 = make_local_value(typechecking::pointer(typechecking::pointer((@node).tpe)), null, state)
        
        let gep1 = allocate(Insn)
        (@gep1).kind = InsnKind::GETELEMENTPTR
        (@gep1).value.gep = {
            ret = gep_ret1,
            tpe = array_tpe,
            value = @left_value.addr,
            index = index1
        } !InsnGetElementPtr

        let load1_value = make_local_value(typechecking::pointer((@node).tpe), null, state)

        let load1 = allocate(Insn)
        (@load1).kind = InsnKind::LOAD
        (@load1).value.load = {
            value = load1_value,
            loc = gep_ret1
        } !InsnLoad

        let index2 = allocate(Value, 1)
        index2[0] = right_value

        let gep_ret2 = make_local_value(typechecking::pointer((@node).tpe), null, state)

        let gep2 = allocate(Insn)
        (@gep2).kind = InsnKind::GETELEMENTPTR
        (@gep2).value.gep = {
            ret = gep_ret2,
            tpe = (@node).tpe,
            value = load1_value,
            index = index2
        } !InsnGetElementPtr
        
        let addr = allocate(Value)
        (@addr) = gep_ret2
        let ret = make_local_value((@node).tpe, addr, state)

        let load2 = allocate(Insn)
        (@load2).kind = InsnKind::LOAD
        (@load2).value.load = {
            value = ret,
            loc = gep_ret2
        } !InsnLoad

        push_insn(gep1, state)
        push_insn(load1, state)
        push_insn(gep2, state)
        push_insn(load2, state)
        
        return ret
    } else if (@array_tpe).kind == typechecking::TypeKind::STATIC_ARRAY {  
        var index = allocate(Value, 2)
        index[0] = make_int_value(0)
        index[1] = right_value

        let gep_ret = make_local_value(typechecking::pointer((@node).tpe), null, state)

        let gep = allocate(Insn)
        (@gep).kind = InsnKind::GETELEMENTPTR
        (@gep).value.gep = {
            ret = gep_ret,
            tpe = array_tpe,
            value = @left_value.addr,
            index = index
        } !InsnGetElementPtr

        let addr = allocate(Value)
        (@addr) = gep_ret
        let ret = make_local_value((@node).tpe, addr, state)

        let load = allocate(Insn)
        (@load).kind = InsnKind::LOAD
        (@load).value.load = {
            value = ret,
            loc = gep_ret
        } !InsnLoad

        push_insn(gep, state)
        push_insn(load, state)

        return ret
    } else if typechecking::is_pointer(array_tpe) {
        var index = allocate(Value, 1)
        index[0] = right_value

        let gep_ret = make_local_value(typechecking::pointer((@node).tpe), null, state)

        let gep = allocate(Insn)
        (@gep).kind = InsnKind::GETELEMENTPTR
        (@gep).value.gep = {
            ret = gep_ret,
            tpe = (@node).tpe,
            value = left_value,
            index = index
        } !InsnGetElementPtr

        let addr = allocate(Value)
        (@addr) = gep_ret
        let ret = make_local_value((@node).tpe, addr, state)

        let load = allocate(Insn)
        (@load).kind = InsnKind::LOAD
        (@load).value.load = {
            value = ret,
            loc = gep_ret
        } !InsnLoad

        push_insn(gep, state)
        push_insn(load, state)
        
        return ret
    } else {
        assert(false)
    }
}

def walk_SizeOf(node: *parser::Node, state: *State) -> Value {
    var tpe = (@(@node).value.expr).tpe
    if not tpe {
        typechecking::errorn(node, "Invalid expression\n")
        return NO_VALUE
    }
    let value = make_int_value((@tpe).size)
    value.tpe = builtins::size_t_
    
    return value
}

def walk_AlignOf(node: *parser::Node, state: *State) -> Value {
    var tpe = (@(@node).value.expr).tpe
    if not tpe {
        typechecking::errorn(node, "Invalid expression\n")
        return NO_VALUE
    }
    let value = make_int_value((@tpe).align)
    value.tpe = builtins::size_t_
    
    return value
}

def compare(node: *parser::Node, left: Value, right: Value, state: *State) -> Value {
    var tpe: *typechecking::Type = null
    if typechecking::is_pointer(left.tpe) {
        // TODO We need something like intptr_t, but for now size_t will suffice
        left = convert_to(node, left, builtins::size_t_, state)
    }
    if typechecking::is_pointer(right.tpe) {
        right = convert_to(node, right, builtins::size_t_, state)
    }
    if typechecking::is_arithmetic(left.tpe) and typechecking::is_arithmetic(right.tpe) {
        tpe = typechecking::common_type(left.tpe, right.tpe)

        left = convert_to(node, left, tpe, state)
        right = convert_to(node, right, tpe, state)

        var kind: InsnKind
        var op: string
        if typechecking::is_float(tpe) {
            kind = InsnKind::FCMP
            switch (@node).kind !int {
                case parser::NodeKind::EQ:  op = f_ueq
                case parser::NodeKind::NEQ: op = f_une
                case parser::NodeKind::GT:  op = f_ugt
                case parser::NodeKind::LT:  op = f_ult
                case parser::NodeKind::GEQ: op = f_uge
                case parser::NodeKind::LEQ: op = f_ule
                case: assert(false)
            }
        } else {
            kind = InsnKind::ICMP
            if (@tpe).unsig {
                switch (@node).kind !int {
                    case parser::NodeKind::EQ:  op = i_eq
                    case parser::NodeKind::NEQ: op = i_ne
                    case parser::NodeKind::GT:  op = i_ugt
                    case parser::NodeKind::LT:  op = i_ult
                    case parser::NodeKind::GEQ: op = f_uge
                    case parser::NodeKind::LEQ: op = f_ule
                    case: assert(false)
                }
            } else {
                switch (@node).kind !int {
                    case parser::NodeKind::EQ:  op = i_eq
                    case parser::NodeKind::NEQ: op = i_ne
                    case parser::NodeKind::GT:  op = i_sgt
                    case parser::NodeKind::LT:  op = i_slt
                    case parser::NodeKind::GEQ: op = i_sge
                    case parser::NodeKind::LEQ: op = i_sle
                    case: assert(false)
                }
            }
        }

        let ret = make_local_value((@node).tpe, null, state)

        let insn = allocate(Insn)
        (@insn).kind = kind
        (@insn).value.cmp = {
            op = op,
            ret = ret,
            left = left,
            right = right
        }

        push_insn(insn, state)

        return ret
    } else if typechecking::equals(left.tpe, right.tpe) { 
        if typechecking::equals(left.tpe, builtins::string_) {
            // TODO Compare strings
        }
        return NO_VALUE
    } else {
        // TODO Compare arrays that aren't of equal type
        return NO_VALUE
    }
}

def walk_ComparisionOp(node: *parser::Node, state: *State) -> Value {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right

    if not left or not right { return NO_VALUE }
    if not (@left).tpe or not (@right).tpe { return NO_VALUE }

    if (@left).kind >= parser::NodeKind::EQ and (@left).kind <= parser::NodeKind::LEQ {
        let value_left = walk_expression(left, state)
        // These two values get compared
        let value_leftc = walk_expression((@left).value.bin_op.right, state)
        let value_rightc = walk_expression(right, state)
        let value = compare(node, value_leftc, value_rightc, state)
        
        let ret = make_local_value(builtins::bool_, null, state)

        let insn_and = allocate(Insn)
        (@insn_and).kind = InsnKind::AND
        (@insn_and).value.arith = {
            ret = ret,
            left = value_left,
            right = value
        } !InsnArithmetic

        push_insn(insn_and, state)

        return ret
    } else {
        let value_left = walk_expression(left, state)
        let value_right = walk_expression(right, state)
        return compare(node, value_left, value_right, state)
    }
}

def walk_PointerOp(node: *parser::Node, kind: parser::NodeKind, state: *State) -> Value {
    let value_left = walk_expression((@node).value.bin_op.left, state)
    let value_right = walk_expression((@node).value.bin_op.right, state)

    // TODO This is not the correct type
    let ret_ptrtoint = make_local_value(builtins::size_t_, null, state)

    let ptrtoint = allocate(Insn)
    (@ptrtoint).kind = InsnKind::PTRTOINT
    (@ptrtoint).value.convert = {
        ret = ret_ptrtoint,
        value = value_left
    } !InsnConvert

    let ret_arith = make_local_value(builtins::size_t_, null, state)

    let arith = allocate(Insn)
    (@arith).kind = kind
    (@arith).value.arith = {
        ret = ret_arith,
        left = ret_ptrtoint,
        right = value_right
    }

    let ret_inttoptr = make_local_value((@node).tpe, null, state)

    let inttoptr = allocate(Insn)
    (@inttoptr).kind = InsnKind::INTTOPTR
    (@inttoptr).value.convert = {
        ret = ret_inttoptr,
        value = ret_arith
    } !InsnConvert

    push_insn(ptrtoint, state)
    push_insn(arith, state)
    push_insn(inttoptr, state)

    return ret_inttoptr
}

export def walk_expression(node: *parser::Node, state: *State) -> Value {
    if not node { return NO_VALUE }
    switch (@node).kind !int {
        case parser::NodeKind::NULL:
            return walk_Null(node, state)
        case parser::NodeKind::IDENTIFIER:
            return walk_Identifier(node, state)
        case parser::NodeKind::INTEGER:
            return walk_Integer(node, state)
        case parser::NodeKind::FLOAT:
            return walk_Float(node, state)
        case parser::NodeKind::BOOLEAN:
            return walk_Boolean(node, state)
        case parser::NodeKind::CHAR:
            return walk_Char(node, state)
        case parser::NodeKind::STRING:
            return walk_String(node, state)
        case parser::NodeKind::SIZE_OF:
            return walk_SizeOf(node, state)
        case parser::NodeKind::ALIGN_OF:
            return walk_AlignOf(node, state)
        case parser::NodeKind::CAST:
            return walk_Cast(node, state)
        case parser::NodeKind::NOT:
            return walk_Not(node, state)
        case parser::NodeKind::AND:
            return walk_And(node, state)
        case parser::NodeKind::OR:
            return walk_Or(node, state)
        case parser::NodeKind::ADD:
            return walk_Add(node, state)
        case parser::NodeKind::SUB:
            return walk_Sub(node, state)
        case parser::NodeKind::MUL:
            return walk_Mul(node, state)
        case parser::NodeKind::MOD:
            return walk_Mod(node, state)
        case parser::NodeKind::DIV:
            return walk_Div(node, state)
        case parser::NodeKind::SHL:
            return walk_Shl(node, state)
        case parser::NodeKind::SHR:
            return walk_Shr(node, state)
        case parser::NodeKind::PADD:
            return walk_PointerOp(node, InsnKind::ADD, state)
        case parser::NodeKind::PSUB:
            return walk_PointerOp(node, InsnKind::SUB, state)
        case parser::NodeKind::EQ..parser::NodeKind::LEQ:
            return walk_ComparisionOp(node, state)
        case parser::NodeKind::FUNC_CALL:
            return walk_Call(node, state)
        case parser::NodeKind::ASSIGN:
            return walk_Assign(node, state)
        case parser::NodeKind::PADD_EQ..parser::NodeKind::SHR_EQ:
            return walk_AssignEq(node, state)
        case parser::NodeKind::DEREF:
            return walk_Deref(node, state)
        case parser::NodeKind::PTR:
            return walk_Ptr(node, state)
        case parser::NodeKind::MEMBER_ACCESS:
            return walk_MemberAccess(node, state)
        case parser::NodeKind::ARRAY_SUBSCRIPT:
            return walk_ArraySubscript(node, state)
        case parser::NodeKind::STRUCT_LIT:
            return walk_StructLit(node, state)
        case:
            error((@node).kind, "\n")
            assert(false)
    }
}

def walk_If(node: *parser::Node, state: *State) {

    let cond = convert_to(node, walk_expression((@node).value.if_.cond, state), builtins::bool_, state)
    let entry_label = make_label(state)
    var entry = allocate(Insn)
    (@entry).kind = InsnKind::BR
    (@entry).value.br = {
        cond = cond,
        if_true = entry_label
    }

    let exit = allocate(Insn)
    (@exit).kind = InsnKind::BR_UNC

    push_insn(entry, state)
    push_label(entry_label, state)
    for var i in 0..vector::length((@node).value.if_.body) {
        let stmt = vector::get((@node).value.if_.body, i) !*parser::Node
        walk(stmt, state)
    }
    push_insn(exit, state)

    for var i in 0..vector::length((@node).value.if_.else_if) {
        let else_if = vector::get((@node).value.if_.else_if, i) !*parser::Node
        let cond = walk_expression((@else_if).value.else_if.cond, state)

        let br_label = make_label(state)
        (@entry).value.br.if_false = br_label
        push_label(br_label, state)

        entry = allocate(Insn)
        (@entry).kind = InsnKind::BR
        (@entry).value.br = {
            cond = cond
        }
        push_insn(entry, state)
        let entry_label = make_label(state)
        (@entry).value.br.if_true = entry_label

        push_label(entry_label, state)
        for var i in 0..vector::length((@else_if).value.else_if.body) {
            let stmt = vector::get((@else_if).value.else_if.body, i)
            walk(stmt, state)
        }
        push_insn(exit, state)
    }

    let else_ = (@node).value.if_.else_
    if else_ {
        let entry_label = make_label(state)
        (@entry).value.br.if_false = entry_label
        push_label(entry_label, state)
        
        for var i in 0..vector::length((@else_).value.body) {
            let stmt = vector::get((@else_).value.body, i) !*parser::Node
            walk(stmt, state)
        }
        push_insn(exit, state)
    }

    let exit_label = make_label(state)
    if not else_ {
        (@entry).value.br.if_false = exit_label
    }
    (@exit).value.br_unc.label_ = exit_label
    push_label(exit_label, state)
}

def walk_Return(node: *parser::Node, state: *State) {
    let current_function = (@state).current_function
    if not current_function { return }

    var value: Value
    if (@current_function).multiple_returns {
        let ret_args = allocate(Value, vector::length((@node).value.body))
        for var i in 0..ret_args.size {
            ret_args[i] = walk_expression(vector::get((@node).value.body, i) !*parser::Node, state)
        }
        value = {
            kind = ValueKind::STRUCT,
            values = ret_args,
            tpe = (@current_function).ret
        } !Value
    } else {
        let arg = vector::peek((@node).value.body)
        value = walk_expression(arg, state)
    }

    let ret = allocate(Insn)
    (@ret).kind = InsnKind::RET
    (@ret).value.ret.value = value

    push_insn(ret, state)
    (@state).counter += 1
}

def walk_Break(node: *parser::Node, state: *State) {
    let break_insn = get_break_insn(state)
    if not break_insn {
        typechecking::errorn(node, "break used outside of a loop\n")
        return
    }
    push_insn(break_insn, state)
    (@state).counter += 1
}

def walk_Continue(node: *parser::Node, state: *State) {
    let continue_insn = get_continue_insn(state)
    if not continue_insn {
        typechecking::errorn(node, "continue used outside of a loop\n")
        return
    }
    push_insn(continue_insn, state)
    (@state).counter += 1
}

def walk_Loop(node: *parser::Node, state: *State) {
    push_loop_state(state)
    let continue_insn = get_continue_insn(state)
    let break_insn = get_break_insn(state)

    push_insn(continue_insn, state)
    let start_label = make_label(state)
    push_label(start_label, state)
    for var i in 0..vector::length((@node).value.body) {
        let n = vector::get((@node).value.body, i)
        walk(n, state)
    }
    push_insn(continue_insn, state)
    let end_label = make_label(state)
    push_label(end_label, state)

    (@continue_insn).value.br_unc.label_ = start_label
    (@break_insn).value.br_unc.label_ = end_label
    pop_loop_state(state)
}

def walk_While(node: *parser::Node, state: *State) {
    push_loop_state(state)
    let continue_insn = get_continue_insn(state)
    let break_insn = get_break_insn(state)

    push_insn(continue_insn, state)
    let start_label = make_label(state)
    push_label(start_label, state)

    let cond = walk_expression((@node).value.while_loop.expr, state)
    
    let br = allocate(Insn)
    (@br).kind = InsnKind::BR
    (@br).value.br = {
        cond = cond
    } !InsnBr
    
    push_insn(br, state)

    let inner = make_label(state)
    push_label(inner, state)
    (@br).value.br.if_true = inner

    for var i in 0..vector::length((@node).value.while_loop.body) {
        let n = vector::get((@node).value.while_loop.body, i)
        walk(n, state)
    }

    push_insn(continue_insn, state)
    let end_label = make_label(state)
    push_label(end_label, state)
    (@br).value.br.if_false = end_label

    (@continue_insn).value.br_unc.label_ = start_label
    (@break_insn).value.br_unc.label_ = end_label
    pop_loop_state(state)
}

// TODO Allow arrays
def walk_For(node: *parser::Node, state: *State) {
    let range = (@node).value.for_loop.expr
    assert((@range).kind == parser::NodeKind::RANGE or (@range).kind == parser::NodeKind::RANGE_INC)
    
    var op = i_slt
    if (@range).kind == parser::NodeKind::RANGE_INC {
        op = i_sle
    }

    let startv = walk_expression((@range).value.bin_op.left, state)
    let endv = walk_expression((@range).value.bin_op.right, state)

    let iddecl = (@node).value.for_loop.iddecl
    var loc: Value
    if (@iddecl).kind == parser::NodeKind::FOR_ID_DECL {
        let value = scope::get((@iddecl).scope, (@iddecl).value.for_id_decl.ident)
        if not value { return }

        let alloca = allocate(Insn)
        (@alloca).kind = InsnKind::ALLOCA
        (@alloca).value.alloca = {
            ret = {
                kind = ValueKind::LOCAL,
                name = (@value).assembly_name,
                tpe = (@iddecl).tpe
            } !Value
        } !InsnAlloca

        push_insn(alloca, state)

        loc = {
            kind = ValueKind::LOCAL,
            name = (@value).assembly_name,
            tpe = typechecking::pointer((@iddecl).tpe)
        } !Value
    } else {
        let addr = walk_expression(iddecl, state).addr
        if not addr { return }
        loc = @addr
    }
    
    let store = allocate(Insn)
    (@store).kind = InsnKind::STORE
    (@store).value.store = {
        loc = loc,
        value = startv
    }

    push_insn(store, state)

    push_loop_state(state)
    let continue_insn = get_continue_insn(state)
    let break_insn = get_break_insn(state)

    push_insn(continue_insn, state)
    let start_label = make_label(state)
    push_label(start_label, state)

    let load_ret = make_local_value(builtins::int_, null, state)
    let load = allocate(Insn)
    (@load).kind = InsnKind::LOAD
    (@load).value.load = {
        value = load_ret,
        loc = loc
    } !InsnLoad

    push_insn(load, state)

    let cmp_ret = make_local_value(builtins::bool_, null, state)
    let cmp = allocate(Insn)
    (@cmp).kind = InsnKind::ICMP
    (@cmp).value.cmp = {
        op = op,
        ret = cmp_ret,
        left = load_ret,
        right = endv
    } !InsnCmp

    push_insn(cmp, state)

    let br = allocate(Insn)
    (@br).kind = InsnKind::BR
    (@br).value.br = {
        cond = cmp_ret
    } !InsnBr
    
    push_insn(br, state)

    let inner = make_label(state)
    push_label(inner, state)
    (@br).value.br.if_true = inner

    for var i in 0..vector::length((@node).value.for_loop.body) {
        let n = vector::get((@node).value.for_loop.body, i)
        walk(n, state)
    }

    let add_ret = make_local_value(builtins::int_, null, state)
    let add = allocate(Insn)
    (@add).kind = InsnKind::ADD
    (@add).value.arith = {
        ret = add_ret,
        left = load_ret,
        right = { kind = ValueKind::INT, i = 1, tpe = builtins::int_ } !Value
    } !InsnArithmetic

    push_insn(add, state)

    let store2 = allocate(Insn)
    (@store2).kind = InsnKind::STORE
    (@store2).value.store = {
        loc = loc,
        value = add_ret
    }

    push_insn(store2, state)

    push_insn(continue_insn, state)
    let end_label = make_label(state)
    push_label(end_label, state)
    (@br).value.br.if_false = end_label

    (@continue_insn).value.br_unc.label_ = start_label
    (@break_insn).value.br_unc.label_ = end_label
    pop_loop_state(state)
}

def walk_VarDecl(node: *parser::Node, state: *State) {
    let left = (@node).value.var_decl.left
    let right = (@node).value.var_decl.right

    let assign_left = vector::make()

    for var i in 0..vector::length(left) {
        let n = vector::get(left, i) !*parser::Node
        if (@n).kind == parser::NodeKind::ID_DECL {
            let v = (@n).value.id_decl.value
            let tpe = (@v).tpe

            let value = scope::get((@node).scope, v)
            if not value { continue }
            let name = (@value).assembly_name

            let insn = allocate(Insn)
            (@insn).kind = InsnKind::ALLOCA
            (@insn).value.alloca = {
                ret = {
                    kind = ValueKind::LOCAL,
                    name = name,
                    tpe = tpe
                } !Value
            } !InsnAlloca

            push_insn(insn, state)
            vector::push(assign_left, v)
        } else {
            vector::push(assign_left, (@n).value.expr)
        }
    }

    if vector::length(right) > 0 {
        let assign = allocate(parser::Node)
        (@assign).kind = parser::NodeKind::ASSIGN
        (@assign).loc = (@node).loc
        (@assign).scope = (@node).scope
        (@assign).value.assign = {
            left = assign_left,
            right = right
        } !parser::NodeAssign
        walk_Assign(assign, state)
    }
}

export def walk(node: *parser::Node, state: *State) {
    if not node { return }
    switch (@node).kind !int {
        case parser::NodeKind::VAR_DECL:
            walk_VarDecl(node, state)
        case parser::NodeKind::RETURN:
            walk_Return(node, state)
        case parser::NodeKind::BREAK:
            walk_Break(node, state)
        case parser::NodeKind::CONTINUE:
            walk_Continue(node, state)
        case parser::NodeKind::IF:
            walk_If(node, state)
        case parser::NodeKind::LOOP:
            walk_Loop(node, state)
        case parser::NodeKind::WHILE:
            walk_While(node, state)
        case parser::NodeKind::FOR:
            walk_For(node, state)
        case: walk_expression(node, state)
    }
}

def create_function(tpe: *typechecking::Type, body: *vector::Vector, scpe: *scope::Scope, state: *State) {
    let function = allocate(Function)
    (@function).name = typechecking::mangle_function_name((@tpe).type_name, (@tpe).parameter_t)
    (@function).unmangled = (@tpe).type_name
    (@function).multiple_returns = false
    (@function).forward_declare = true
    if body {
        (@function).forward_declare = false
    }

    if vector::length((@tpe).return_t) > 1 {
        // Create anonymous struct as return type
        let ret_tpe = typechecking::make_anonymous_type(typechecking::TypeKind::STRUCT)
        (@ret_tpe).packed = false
        let length = vector::length((@tpe).return_t)
        let fields = allocate(typechecking::StructMember, length)

        // TODO Somehow refactor this with typechecking::type_lookup
        var offset = 0
        var align = 1
        for var i in 0..length {
            let t = vector::get((@tpe).return_t, i) !*typechecking::Type
            let name = util::int_to_str(i)

            offset = (ceil(offset / (@t).align  !double) * (@tpe).align) !int
            align = util::lcm(align, (@t).align)

            fields[i] = { name, t, offset } !StructMember
            offset += (@t).size
        }
        offset = (ceil(offset / align !double) * align) !int

        (@ret_tpe).size = offset
        (@ret_tpe).align = align
        (@ret_tpe).fields = fields

        (@function).ret = ret_tpe
        (@function).multiple_returns = true
    } else if vector::length((@tpe).return_t) == 1 {
        (@function).ret = vector::get((@tpe).return_t, 0) !*typechecking::Type
    } else {
        (@function).ret = null
    }

    (@function).args = vector::make()
    for var i in 0..vector::length((@tpe).parameter_t) {
        let np = allocate(typechecking::NamedParameter)
        (@np) = @(vector::get((@tpe).parameter_t, i) !*typechecking::NamedParameter)
        vector::push((@function).args, np)
    }

    if body {
        (@state).current_function = function
        (@state).counter = 0
        
        let block = allocate(Block)
        (@block).label_ = "start"
        (@block).insn = vector::make()
        (@block).next = null

        (@function).block = block
        (@state).current_block = block

        // Create function arguments
        for var i in 0..vector::length((@function).args) {
            let np = vector::get((@function).args, i) !*typechecking::NamedParameter
            /*let vars = map::keys((@scpe).fields)
            for var i in 0..vars.size {
                let v = vars[i]
                print(v, "\n")
            }*/
            let name = (@scope::get(scpe, parser::make_identifier([(@np).name]))).assembly_name
            let buf = buffer::make_buffer()
            buffer::append_str(*buf, name)
            buffer::append_str(*buf, ".value")
            // Rename to name.value
            (@np).name = buffer::to_string(*buf)
            // Insert alloca and store instructions

            let alloca = allocate(Insn)
            (@alloca).kind = InsnKind::ALLOCA
            (@alloca).value.alloca = {
                ret = {
                    kind = ValueKind::LOCAL,
                    name = name,
                    tpe = (@np).value
                } !Value
            } !InsnAlloca

            push_insn(alloca, state)

            let store = allocate(Insn)
            (@store).kind = InsnKind::STORE
            (@store).value.store = {
                value = {
                    kind = ValueKind::LOCAL,
                    name = (@np).name,
                    tpe = (@np).value
                } !Value,
                loc = {
                    kind = ValueKind::LOCAL,
                    name = name,
                    tpe = typechecking::pointer((@np).value)
                } !Value
            } !InsnStore

            push_insn(store, state)
        }

        for var i in 0..vector::length(body) {
            let node = vector::get(body, i) !*parser::Node
            walk(node, state)
        }

        // TODO Make another compiler pass that checks for missing return statements and dead code
        if not (@function).ret {
            // Check for missing return statement
            let last_insn = vector::peek((@(@state).current_block).insn) !*Insn
            if not last_insn or (@last_insn).kind != InsnKind::RET {
                let ret = allocate(Insn)
                (@ret).kind = InsnKind::RET
                (@ret).value.ret.value = NO_VALUE
                push_insn(ret, state)
            }
        }
    }
    map::put((@(@state).result).functions, (@function).name, function)
}

def walk_Def(node: *parser::Node, state: *State){
    create_function((@node).tpe, (@node).value.def_.body, (@node).scope, state)
}

def walk_TypeDecl(node: *parser::Node, state: *State) {
    let left = (@node).value.type_decl.left
    for var i in 0..vector::length(left) {
        let n = vector::get(left, i) !*parser::Node
        let tpe = (@n).tpe
        if not tpe { continue }
        if (@tpe).kind == typechecking::TypeKind::STRUCT or
            (@tpe).kind == typechecking::TypeKind::UNION {
            
            map::put((@(@state).result).structures, (@tpe).type_name, tpe)
        }
    }
}

def walk_top_VarDecl(node: *parser::Node, body: *vector::Vector, state: *State) {
    let left = vector::make()
    for var i in 0..vector::length((@node).value.var_decl.left) {
        let n = vector::get((@node).value.var_decl.left, i) !*parser::Node
        if (@n).kind == parser::NodeKind::ID_DECL {
            let v = (@n).value.id_decl.value
            let value = scope::get((@node).scope, v)
            if not value { continue }
            let name = (@value).assembly_name
            
            let global = allocate(Value)
            (@global).kind = ValueKind::GLOBAL
            (@global).undef = false
            (@global).name = name
            (@global).value = null
            (@global).tpe = (@v).tpe
            map::put((@(@state).result).globals, (@global).name, global)
            vector::push(left, (@n).value.id_decl.value)
        } else {
            vector::push(left, (@n).value.expr)
        }
    }
    if vector::length((@node).value.var_decl.right) > 0 {
        let node_assign = allocate(parser::Node)
        (@node_assign).kind = parser::NodeKind::ASSIGN
        (@node_assign).loc = (@node).loc
        (@node_assign).scope = (@node).scope
        (@node_assign).value.assign = {
            left = left,
            right = (@node).value.var_decl.right
        } !NodeAssign
        vector::push(body, node_assign)
    }
}

let imported_modules = vector::make()
def walk_top_Import(node: *parser::Node, body: *vector::Vector, state: *State) {
    let imports = (@node).value.body
    for var i in 0..vector::length(imports) {
        let imprt = vector::get(imports, i) !*parser::Node
        let name = (@imprt).value.import_module.name
        var alias = (@imprt).value.import_module.alias 
        if not alias {
            alias = name
        }

        let filename = toolchain::find_module_file(name)
        if length(filename) == 0 { continue }
        
        var found = false
        for var j in 0..vector::length(imported_modules) {
            let imported = @(vector::get(imported_modules, j) !*string)
            if imported == filename { 
                found = true
                break
            }
        }
        if found { continue }

        vector::push(imported_modules, util::copy_string(filename))

        let args = vector::make()
        let arg = parser::make_identifier(["args"])
        (@arg).scope = (@node).scope
        (@arg).tpe = typechecking::array(builtins::string_)
        vector::push(args, arg)

        let name_size = vector::length((@name).value.body)
        let array = allocate(string, name_size + 1)
        for var j in 0..name_size {
            array[j] = @(vector::get((@name).value.body, j) !*string)
        }
        array[array.size - 1] = "main"
        let ident = parser::make_identifier(array)
        (@ident).scope = (@node).scope

        let sc = (@scope::get((@node).scope, alias)).value !*scope::Scope

        let call = allocate(parser::Node)
        (@call).kind = parser::NodeKind::FUNC_CALL
        (@call).scope = (@node).scope
        (@call).tpe = null
        (@call).function = (@(map::get((@sc).fields, "main") !*scope::Value)).tpe
        (@call).value.func_call = {
            left = ident,
            args = args,
            kwargs = vector::make()
        } !parser::NodeFuncCall

        vector::push(body, call)
    }
}

export def compile(module: *toolchain::Module) -> *Result {
    let node = (@module).node

    assert((@node).kind == parser::NodeKind::PROGRAM)
    
    let body = vector::make()
    let state = allocate(State)
    @state = {
        module = module,
        counter = 0,
        global_counter = 0,
        loops = vector::make(),
        result = allocate(Result)
    } !State

    @(@state).result = {
        functions = map::make(),
        structures = map::make(),
        globals = map::make()
    } !Result

    // Forward declare functions from other files
    // TODO This doesn't work for functions that return multiple parameters
    let sc = (@node).scope
    if (@sc).imports {
        for var i in 0..vector::length((@sc).imports) {
            let module = vector::get((@sc).imports, i) !*toolchain::Module
            let m_scope = (@module).scope
            let keys = map::keys((@m_scope).fields)
            for var i in 0..keys.size {
                let value = map::get((@m_scope).fields, keys[i]) !*scope::Value
                if typechecking::is_function((@value).tpe) and (@value).share !int & parser::ShareMarker::EXPORT {
                    create_function((@value).tpe, null, sc, state)
                }
            }
        }
    }

    for var i in 0..vector::length((@node).value.body) {
        let n = vector::get((@node).value.body, i) !*parser::Node
        switch (@n).kind !int {
            case parser::NodeKind::DEF:
                walk_Def(n, state)
            case parser::NodeKind::TYPE_DECL:
                walk_TypeDecl(n, state)
            case parser::NodeKind::VAR_DECL:
                walk_top_VarDecl(n, body, state)
            case parser::NodeKind::IMPORT:
                walk_top_Import(n, body, state)
            case:
                vector::push(body, n)
        }
    }
    let ident = parser::make_identifier(["main"])
    (@ident).loc.module = (@module).module
    (@ident).loc.filename = (@module).filename
    let main_tpe = typechecking::make_type(typechecking::TypeKind::FUNCTION, ident)
    
    let string_array_tpe = typechecking::array(builtins::string_)
    
    let named = allocate(typechecking::NamedParameter)
    (@named).name = "args"
    (@named).value = string_array_tpe
    (@named).varargs = false
    let args = vector::make()
    vector::push(args, named)

    (@main_tpe).parameter_t = args
    // TODO Infer return types
    (@main_tpe).return_t = vector::make()
    (@main_tpe).macro = null
    (@main_tpe).proto = null

    let args_ident = parser::make_identifier(["args"])
    scope::create_variable(
        (@node).scope, 
        args_ident, 
        parser::ShareMarker::NONE, 
        parser::VarDecl::VAR, 
        string_array_tpe, null
    )
    let value = scope::get((@node).scope, args_ident)
    (@value).global = false

    scope::create_function((@node).scope, ident, parser::ShareMarker::EXPORT, main_tpe, false)
    create_function(main_tpe, body, (@node).scope, state)

    return (@state).result
}
