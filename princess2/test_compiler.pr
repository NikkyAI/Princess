import compiler
import codegen
import lexer
import util
import parser
import scope
import typechecking

export var print_ll = false

def compile(s: string) -> string {
    codegen::outfolder = "./bin"

    let main = "main"
    let tokens = lexer::lex(s)
    let lines = util::split_lines(s)
    let node = parser::parse(tokens, lines, main, main)
    let scope = scope::enter_scope(builtins::builtins)
    typechecking::typecheck(node, scope, main, main)
    let result = compiler::compile(node, main, main)
    codegen::gen(result, main, main)
    
    let fh = open("./bin/main.ll", "r")
    seek(fh, 0, SEEK_END)
    let filesize = tell(fh)
    rewind(fh)
    let buf = allocate(char, filesize + 1)
    read(fh, buf, filesize)
    buf[filesize] = '\0'
    close(fh)

    if print_ll {
        print("\n")
        print(s)
        print("\n")
        print(buf)
    }

    return buf
}

def test_emit_arithmetic {
    print(">Test arithmetic instruction... ")

    var str = "
        10 + 10 + 10
    "
    var res = compile(str)

    str = "
        10 * 2 + 5 / 4 - 5 % 3
    "
    res = compile(str)

    str = "
        10.5 / 4.0
    "
    res = compile(str)

    print("OK\n")
}

def test_emit_call {
    print(">Test call instruction... ")

    var str = "
        def add(a: int, b: int) -> int {
            return a + b
        }
        add(10, 10)
    "
    var res = compile(str)

    // Overloaded function
    str = "
        def add(a: int, b: int) -> int {
            return a + b
        }
        def add(a: double, b: double) -> double {
            return a + b
        }
        add(10, 10)
        add(10.0, 10.5)
    "
    res = compile(str)

    print("OK\n")
}

def test_emit_if {
    print(">Test if statement... ")

    var str = "
        def foo
        if true {
            foo()
        }
        foo()
    "
    var res = compile(str)

    str = "
        def foo
        if true {
            foo()
        } else if false {
            foo()
        } else if true {
            foo()
        }
        foo()
    "
    res = compile(str)

    str = "
        def foo
        if true {
            foo()
        } else {
            foo()
        }
        foo()
    "
    res = compile(str)

    // Nested
    str = "
        def foo
        if true {
            foo()
            if true {
                foo()
            } else {
                foo()
            }
        } else {
            foo()
            if true {
                foo()
            } else if true {
                foo()
            } else {
                foo()
            }
        }
        foo()
    "
    res = compile(str)

    print("OK\n")
}

def test_emit_loop {
    print(">Test loop statement... ")

    var str = "
        def foo
        loop {
            foo()
            continue
            foo()
            break
            foo()
        }
    "
    var res = compile(str)

    str = "
        loop {
            if true {
                break
            } else {
                continue
            }
            break
        }
    "
    res = compile(str)
    
    str = "
        loop {
            continue
            loop {
                continue
                break
            }
            break
        }
    "
    res = compile(str)

    print("OK\n")
}

def test_emit_vardecl {
    print(">Test vardecl... ")

    var str = "
        def foo {
            var a: int, b: int
        }
    "
    var res = compile(str)

    // Test scoping
    str = "
        def foo {
            var a: int
            if false {
                var a: int
            }
        }
    "
    res = compile(str)

    print("OK\n")
}

def test_emit_globals {
    print(">Test globals... ")

    var str = "
        var global: int
    "
    var res = compile(str)

    str = "
        let global = 20
    "
    res = compile(str)

    str = "
        let a, b = 10, 20
    "
    res = compile(str)

    str = "
        def foo -> int, int {
            return 10, 20
        }
        let a, b = foo()
    "
    res = compile(str)

    str = "
        def foo -> int, int {
            return 10, 20
        }
        var a: int
        let (a), b = foo()
    "
    res = compile(str)

    str = "
        def foo -> int {
            return 10
        }
        var a: int
        var b: int
        a = b = foo()
    "
    res = compile(str)

    print("OK\n")
}

def test_emit_ptr {
    print(">Test pointers... ")
    
    var str = "
        let a = 20
        let pa = *a
        @pa = 40
    "
    var res = compile(str)

    str = "
        let a = 20
        let pa = *a
        let ppa = *pa
        @@ppa = 40
        let b = @@ppa
    "
    res = compile(str)

    print("OK\n")
}

def test_emit_convert {
    print(">Test type conversion... ")

    var str = "
        let a = 10 !float
        let b = a !int
    "
    var res = compile(str)

    str = "
        let a = 10!float + 20
        let b = 10!uint + 20
    "
    res = compile(str)

    print("OK\n")
}

def test_member_access {
    print(">Test member access... ")

    var str = "
        type S = struct {
            value: int
        }
        type T = struct {
            a: int
            b: S
        }

        var t: T
        let a = t.a
        let b = t.b.value

        t.b.value = 20
        t.a = 40
    "
    var res = compile(str)

    print("OK\n")
}

def test_array_subscript {
    print(">Test array subscript... ")

    var str = "
        var a: [int]
        var b: *int
        var c: [3; int]

        let d = a[2]
        let e = b[2]
        let f = c[2]

        a[2] = 5
        b[2] = 10
        c[2] = 15
    "
    var res = compile(str)

    print("OK\n")
}

export def test {
    print("Running tests on Compiler...\n")
    test_emit_arithmetic()
    test_emit_call()
    test_emit_if()
    test_emit_loop()
    test_emit_vardecl()
    test_emit_globals()
    test_emit_ptr()
    test_emit_convert()
    test_member_access()
    test_array_subscript()
}