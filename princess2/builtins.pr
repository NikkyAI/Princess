import scope
import typechecking
import map

let state: typechecking::State
state.node = null
state.filename = "builtins"
state.scope = null

export let builtins: scope::Scope
builtins.parent = null
builtins.fields = map::make()

def create_int_type(name: string, size: int, unsig: bool) -> *typechecking::Type {
    var tpe = typechecking::make_type(typechecking::TypeKind::WORD, name, *state)
    (@tpe).size = size
    (@tpe).unsig = unsig
    scope::create_type(*builtins, *state, scope::Share::EXPORT, name, tpe)
    return tpe
}

export let char_    = create_int_type("char", size_of char, false)

export let byte_    = create_int_type("byte", size_of byte, false)
export let short_   = create_int_type("short", size_of short, false)
export let int_     = create_int_type("int", size_of int, false)
export let long_    = create_int_type("long", size_of long, false)

export let ubyte_   = create_int_type("ubyte", size_of ubyte, true)
export let ushort_  = create_int_type("ushort", size_of ushort, true)
export let uint_    = create_int_type("uint", size_of uint, true)
export let ulong_   = create_int_type("ulong", size_of ulong, true)

export let int8_    = create_int_type("int8", size_of int8, false)
export let int16_   = create_int_type("int16", size_of int16, false)
export let int32_   = create_int_type("int32", size_of int32, false)
export let int64_   = create_int_type("int64", size_of int64, false)

export let uint8_   = create_int_type("uint8", size_of uint8, true)
export let uint16_  = create_int_type("uint16", size_of uint16, true)
export let uint32_  = create_int_type("uint32", size_of uint32, true)
export let uint64_  = create_int_type("uint64", size_of uint64, true)

export let SIGNED   = [byte_, short_, int_, long_, int8_, int16_, int32_, int64_]
export let UNSIGNED = [ubyte_, ushort_, uint_, ulong_, uint8_, uint16_, uint32_, uint64_]

def is_in(list: [*typechecking::Type], tpe: *typechecking::Type) -> bool {
    for var i in 0..list.size {
        let t = list[i]
        if typechecking::equals(tpe, t) { 
            return true
        }
        return false
    }
}

export def is_signed(tpe: *typechecking::Type) -> bool {
    return is_in(SIGNED, tpe)
}

export def is_unsigned(tpe: *typechecking::Type) -> bool {
    return is_in(UNSIGNED, tpe)
}

export def to_unsigned(tpe: *typechecking::Type) -> *typechecking::Type {
    assert(is_signed(tpe))
    var index = 0
    for var i in 0..SIGNED.size {
        if typechecking::equals(tpe, SIGNED[i]) {
            index = i
            break
        }
    }
    return UNSIGNED[index]
}