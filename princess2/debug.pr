import parser
import vector

def print_indent(indent: int) {
    for var i in 0:indent:1 {
        print(" ")
    }
}

def print_node_(node: *parser::Node, indent: int)

def print_bin_op(str: string, node: *parser::Node, indent: int) {
    print(str)
    print(" {\n")
    print_indent(indent)
    print("left = ")
    print_node_((@node).value.bin_op.left, indent + 1)
    print("\n")
    print_indent(indent)
    print("right = ")
    print_node_((@node).value.bin_op.right, indent + 1)
    print("\n")
    print_indent(indent - 1)
    print("}")
}

def print_un_op(str: string, node: *parser::Node, indent: int) {
    print(str)
    print(" {\n")
    print_indent(indent)
    print("expr = ")
    print_node_((@node).value.expr, indent + 1)
    print("\n")
    print_indent(indent - 1)
    print("}")
}

def print_vector(name: string, vec: *vector::Vector, indent: int) {
    print_indent(indent)
    print(name)
    print(" = [\n")
    for var i in 0:vector::length(vec):1 {
        print_indent(indent + 1)
        print_node_(vector::get(vec, i), indent + 2)
        print("\n")
    }
    print_indent(indent)
    print("]")
}

def print_func_call(node: *parser::Node, indent: int) {
    print("FuncCall {\n")
    print_indent(indent)
    print("left = ")
    print_node_((@node).value.func_call.left, indent + 1)
    print("\n")
    print_vector("args", (@node).value.func_call.args, indent)
    print("\n")
    print_vector("kwargs", (@node).value.func_call.kwargs, indent)
    print("\n")
    print_indent(indent - 1)
    print("}")
}

def print_var_decl(node: *parser::Node, indent: int) {
    print("VarDecl {\n")
    print_indent(indent)
    print("share = ")
    print((@node).value.var_decl.share)
    print("\n")
    print_indent(indent)
    print("kw = ")
    print((@node).value.var_decl.kw)
    print("\n")
    print_vector("left", (@node).value.var_decl.left, indent)
    print("\n")
    print_vector("right", (@node).value.var_decl.right, indent)
    print("\n")
    print_indent(indent - 1)
    print("}")
}

def print_node_(node: *parser::Node, indent: int) {
    switch((@node).kind !int) {
        case parser::NodeKind::PROGRAM:
            print("Program [\n")
            for var i in 0:vector::length((@node).value.body):1 {
                print_indent(indent)
                print_node_(vector::get((@node).value.body, i), indent + 1)
                print("\n")
            }
            print_indent(indent - 1)
            print("]")
        case parser::NodeKind::INTEGER:
            print("Integer ", (@node).value.i)
        case parser::NodeKind::CHAR:
            print("Char '", (@node).value.i !char, "'")
        case parser::NodeKind::STRING:
            print("String \"", (@node).value.str, "\"")
        case parser::NodeKind::FLOAT:
            print("Float ", (@node).value.f)
        case parser::NodeKind::BOOLEAN:
            print("Boolean ")
            if (@node).value.i {
                print("true")
            } else {
                print("false")
            }
        case parser::NodeKind::IDENTIFIER:
            print("Identifier ", (@node).value.str)
        case parser::NodeKind::CAST:
            print_bin_op("Cast", node, indent)
        case parser::NodeKind::ADD:
            print_bin_op("Add", node, indent)
        case parser::NodeKind::SUB:
            print_bin_op("Sub", node, indent)
        case parser::NodeKind::MUL:
            print_bin_op("Mul", node, indent)
        case parser::NodeKind::DIV:
            print_bin_op("Div", node, indent)
        case parser::NodeKind::MOD:
            print_bin_op("Mod", node, indent)
        case parser::NodeKind::AND:
            print_bin_op("And", node, indent)
        case parser::NodeKind::OR:
            print_bin_op("Or", node, indent)
        case parser::NodeKind::UADD:
            print_un_op("UAdd", node, indent)
        case parser::NodeKind::USUB:
            print_un_op("USub", node, indent)
        case parser::NodeKind::PTR:
            print_un_op("Ptr", node, indent)
        case parser::NodeKind::DEREF:
            print_un_op("Deref", node, indent)
        case parser::NodeKind::BNOT:
            print_un_op("BNot", node, indent)
        case parser::NodeKind::NOT:
            print_un_op("Not", node, indent)
        case parser::NodeKind::BAND:
            print_bin_op("BAnd", node, indent)
        case parser::NodeKind::BOR:
            print_bin_op("BOr", node, indent)
        case parser::NodeKind::BXOR:
            print_bin_op("BXor", node, indent)
        case parser::NodeKind::SHL:
            print_bin_op("Shl", node, indent)
        case parser::NodeKind::SHR:
            print_bin_op("Shr", node, indent)
        case parser::NodeKind::PADD:
            print_bin_op("PAdd", node, indent)
        case parser::NodeKind::PSUB:
            print_bin_op("PSub", node, indent)
        case parser::NodeKind::EQ:
            print_bin_op("Eq", node, indent)
        case parser::NodeKind::NEQ:
            print_bin_op("NEq", node, indent)
        case parser::NodeKind::GT:
            print_bin_op("Gt", node, indent)
        case parser::NodeKind::LT:
            print_bin_op("Lt", node, indent)
        case parser::NodeKind::GEQ:
            print_bin_op("GEq", node, indent)
        case parser::NodeKind::LEQ:
            print_bin_op("LEq", node, indent)
        case parser::NodeKind::FUNC_CALL:
            print_func_call(node, indent)
        case parser::NodeKind::VAR_DECL:
            print_var_decl(node, indent)
        case:
            print("Error: Missing node")
    }
}

export def print_node(node: *parser::Node) {
    print_node_(node, 1)
    print("\n")
}