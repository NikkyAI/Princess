import vector
import util
import lexer
import parser
import typechecking
import scope
import builtins
import debug

type Result = struct {
    scope: *scope::Scope
    node: *parser::Node
}

def typecheck(s: string) -> Result {
    let tokens = lexer::lex(s)
    let lines = util::split_lines(s)
    let node = parser::parse(tokens, lines, "main")
    let scope = scope::enter_scope(builtins::builtins)
    typechecking::typecheck(node, scope, "main")
    
    return { scope, node } !Result
}

def next_error_msg(errors: *vector::Vector) -> string {
    let error = vector::pop(errors) !*debug::Error
    return (@error).msg
}

def test_vardecl {
    print(">Test VarDecl... ")

    var str = "
        var foo: byte = 5
    "
    var res = typecheck(str)
    let v1 = (@scope::get(res.scope, parser::make_identifier(["foo"]))).tpe
    assert(v1 == builtins::byte_)

    str = "
        var bar: long
        let foo, (bar) = 0, 1
    "
    res = typecheck(str)
    let v2 = (@scope::get(res.scope, parser::make_identifier(["bar"]))).tpe
    let v3 = (@scope::get(res.scope, parser::make_identifier(["foo"]))).tpe
    assert(v2 == builtins::long_)
    assert(v3 == builtins::int_)

    debug::redirect_stderr()
    str = "
        const a, b = 20
        var c, d = 10, 20, 30
        var c = 10
        var e, (c) = 10
        var f: int = \"string\"
    "
    res = typecheck(str)
    var errors = debug::catch_errors()
    assert(next_error_msg(errors) == "Incompatible types int and [7; char]")
    assert(next_error_msg(errors) == "Must assign a value")
    assert(next_error_msg(errors) == "Too many values to assign")
    assert(next_error_msg(errors) == "Unbalanced assignment")
    print("OK\n")
}

def test_literals {
    print(">Test literals...")

    var str = "
        let v1 = \"string\"
        let v2 = 'c'
        let v3 = 0.0
        let v4 = 0xFF
        let v5 = false
    "

    var res = typecheck(str)
    let v1 = (@scope::get(res.scope, parser::make_identifier(["v1"]))).tpe
    let v2 = (@scope::get(res.scope, parser::make_identifier(["v2"]))).tpe 
    let v3 = (@scope::get(res.scope, parser::make_identifier(["v3"]))).tpe 
    let v4 = (@scope::get(res.scope, parser::make_identifier(["v4"]))).tpe
    let v5 = (@scope::get(res.scope, parser::make_identifier(["v5"]))).tpe

    assert((@v1).kind == typechecking::TypeKind::STATIC_ARRAY)
    assert((@v1).tpe == builtins::char_)
    assert(v2 == builtins::char_)
    assert(v3 == builtins::double_)
    assert(v4 == builtins::int_)
    assert(v5 == builtins::bool_)

    print("OK\n")
}

def test_assign {
    print(">Test assignment... ")
    
    var str = "
        var foo = 5
        var bar = 10

        foo, bar = 10, 20
    "
    typecheck(str)

    debug::redirect_stderr()
    str = "
        let foo = 20
        foo = 40
        var bar: int
        bar = \"string\"
    "
    typecheck(str)
    var errors = debug::catch_errors()
    assert(next_error_msg(errors) == "Incompatible types int and [7; char]")
    assert(next_error_msg(errors) == "Assignment to non var")

    print("OK\n")
}

def test_operators {
    print(">Test operators... ")

    var str = "
        let foo = 0
        let bar = -foo
        let baz = +50
    "

    // TODO This doesnt really test anything, we need to inspect the nodes
    var res = typecheck(str)
    let v1 = (@scope::get(res.scope, parser::make_identifier(["foo"]))).tpe
    let v2 = (@scope::get(res.scope, parser::make_identifier(["baz"]))).tpe
    assert(v1 == builtins::int_)
    assert(v2 == builtins::int_)

    str = "
        let v3 = 10 + 20
        let v4 = v3 + 0 !short
        let v5 = 0 !long - 0 !int
        let v6 = 0 !long & 0 !int
    "
    res = typecheck(str)
    let v3 = (@scope::get(res.scope, parser::make_identifier(["v3"]))).tpe
    let v4 = (@scope::get(res.scope, parser::make_identifier(["v4"]))).tpe
    let v5 = (@scope::get(res.scope, parser::make_identifier(["v5"]))).tpe
    let v6 = (@scope::get(res.scope, parser::make_identifier(["v6"]))).tpe
    assert(v3 == builtins::int_)
    assert(v4 == builtins::int_)
    assert(v5 == builtins::long_)
    assert(v6 == builtins::long_)

    debug::redirect_stderr()
    str = "
        var a = 0 !float
        var b = 1
        var c = a & b
        var d = \"string\"
        var e = not d
    "
    res = typecheck(str)
    var errors = debug::catch_errors()
    assert(next_error_msg(errors) == "Incompatible type [7; char], must be boolean type")
    assert(next_error_msg(errors) == "Invalid operands of type float and int to bitwise operator")

    print("OK\n")
}

export def test {
    print("Running tests on Typechecking...\n")
    test_vardecl()
    test_literals()
    test_operators()
    test_assign()
}