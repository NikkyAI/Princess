import vector
import util
import lexer
import parser
import typechecking
import scope
import builtins
import debug
import codegen

type Result = struct {
    scope: *scope::Scope
    node: *parser::Node
}

def typecheck(s: string) -> Result {
    codegen::outfolder = "./bin"
    let tokens = lexer::lex(s)
    let lines = util::split_lines(s)
    let node = parser::parse(tokens, lines, "main", "main")
    let scope = scope::enter_scope(builtins::builtins)
    typechecking::typecheck(node, scope, "main", "main")
    
    return { scope, node } !Result
}

def next_error_msg(errors: *vector::Vector) -> string {
    let error = vector::pop(errors) !*debug::Error
    return (@error).msg
}

def test_vardecl {
    print(">Test vardecl... ")

    var str = "
        var foo: byte = 5
    "
    var res = typecheck(str)
    let v1 = (@scope::get(res.scope, parser::make_identifier(["foo"]))).tpe
    assert(v1 == builtins::byte_)

    str = "
        var bar: long
        let foo, (bar) = 0, 1
    "
    res = typecheck(str)
    let v2 = (@scope::get(res.scope, parser::make_identifier(["bar"]))).tpe
    let v3 = (@scope::get(res.scope, parser::make_identifier(["foo"]))).tpe
    assert(v2 == builtins::long_)
    assert(v3 == builtins::int_)

    debug::redirect_stderr()
    str = "
        const a, b = 20
        var c, d = 10, 20, 30
        var c = 10
        var e, (c) = 10
        var f: int = \"string\"
    "
    res = typecheck(str)
    var errors = debug::catch_errors()
    assert(next_error_msg(errors) == "Incompatible types int and [7; char]")
    assert(next_error_msg(errors) == "Must assign a value")
    assert(next_error_msg(errors) == "Too many values to assign")
    assert(next_error_msg(errors) == "Unbalanced assignment")
    print("OK\n")
}

def test_literals {
    print(">Test literals... ")

    var str = "
        let v1 = \"string\"
        let v2 = 'c'
        let v3 = 0.0
        let v4 = 0xFF
        let v5 = false
    "

    var res = typecheck(str)
    let v1 = (@scope::get(res.scope, parser::make_identifier(["v1"]))).tpe
    let v2 = (@scope::get(res.scope, parser::make_identifier(["v2"]))).tpe 
    let v3 = (@scope::get(res.scope, parser::make_identifier(["v3"]))).tpe 
    let v4 = (@scope::get(res.scope, parser::make_identifier(["v4"]))).tpe
    let v5 = (@scope::get(res.scope, parser::make_identifier(["v5"]))).tpe

    assert((@v1).kind == typechecking::TypeKind::STATIC_ARRAY)
    assert((@v1).tpe == builtins::char_)
    assert(v2 == builtins::char_)
    assert(v3 == builtins::double_)
    assert(v4 == builtins::int_)
    assert(v5 == builtins::bool_)

    print("OK\n")
}

def test_assign {
    print(">Test assignment... ")
    
    var str = "
        var foo = 5
        var bar = 10

        foo, bar = 10, 20

        def function -> int, int {
            return 0, 0
        }
        foo, bar = function()
    "
    typecheck(str)

    debug::redirect_stderr()
    str = "
        var v
        let foo = 20
        foo = 40
        var bar: int
        bar = \"string\"
    "
    typecheck(str)
    var errors = debug::catch_errors()
    assert(next_error_msg(errors) == "Incompatible types int and [7; char]")
    assert(next_error_msg(errors) == "Assignment to non var")
    assert(next_error_msg(errors) == "Need to specify a type")

    print("OK\n")
}

def test_operators {
    print(">Test operators... ")

    var str = "
        let foo = 0
        let bar = -foo
        let baz = +50
    "

    // TODO This doesnt really test anything, we need to inspect the nodes
    var res = typecheck(str)
    let v1 = (@scope::get(res.scope, parser::make_identifier(["foo"]))).tpe
    let v2 = (@scope::get(res.scope, parser::make_identifier(["baz"]))).tpe
    assert(v1 == builtins::int_)
    assert(v2 == builtins::int_)

    str = "
        let v3 = 10 + 20
        let v4 = v3 + 0 !short
        let v5 = 0 !long - 0 !int
        let v6 = 0 !long & 0 !int
    "
    res = typecheck(str)
    let v3 = (@scope::get(res.scope, parser::make_identifier(["v3"]))).tpe
    let v4 = (@scope::get(res.scope, parser::make_identifier(["v4"]))).tpe
    let v5 = (@scope::get(res.scope, parser::make_identifier(["v5"]))).tpe
    let v6 = (@scope::get(res.scope, parser::make_identifier(["v6"]))).tpe
    assert(v3 == builtins::int_)
    assert(v4 == builtins::int_)
    assert(v5 == builtins::long_)
    assert(v6 == builtins::long_)

    debug::redirect_stderr()
    str = "
        var a = 0 !float
        var b = 1
        var c = a & b
        var d = \"string\"
        var e = not d
    "
    res = typecheck(str)
    var errors = debug::catch_errors()
    assert(next_error_msg(errors) == "Incompatible type [7; char], must be boolean type")
    assert(next_error_msg(errors) == "Invalid operands of type float and int to bitwise operator")

    print("OK\n")
}

def test_def {
    print(">Test def... ")

    var str = "
        def foo {}
    "
    var res = typecheck(str)

    str = "
        def foo
        def foo {}
    "
    res = typecheck(str)

    str = "
        def foo {}
        def foo(a: float) {}
    "
    res = typecheck(str)

    debug::redirect_stderr()
    str = "
        def foo {}
        def foo {}
    "
    res = typecheck(str)
    var errors = debug::catch_errors()
    assert(next_error_msg(errors) == "Function \"foo\" was already declared previously (same arguments)")

    debug::redirect_stderr()
    str = "
        def foo {
            export var foo: int
            export def nested_function {}
        }
    "
    res = typecheck(str)
    errors = debug::catch_errors()
    assert(next_error_msg(errors) == "Can't share non top level function")
    assert(next_error_msg(errors) == "Can't share non top level variable")

    print("OK\n")
}

def test_typedecl {
    print(">Test typedecl... ")

    var str = "
        type A = int
        type B = A

        var a: B = 0
    "
    var res = typecheck(str)

    str = "
        type A
        type A = int
        type module::A
        type module::A = int
    "
    res = typecheck(str)

    debug::redirect_stderr()
    str = "
        type A = int
        type A = float
        var B = 0
        type B = int
    "
    res = typecheck(str)
    var errors = debug::catch_errors()
    assert(next_error_msg(errors) == "Redeclaration of \"B\"")
    assert(next_error_msg(errors) == "Redeclaration of \"A\"")

    print("OK\n")
}

def test_struct {
    print(">Test struct... ")

    var str = "
        type A = struct {
            a: int32
            b: int64
            c: int16
            d: int8
        }
        type B = struct {
            a: int8
            b: int16
        }
        type C = struct {
            a: int16
            b: int8
            c: int32
        }
    "
    var res = typecheck(str)
    var s1 = (@scope::get(res.scope, parser::make_identifier(["A"]))).value !*typechecking::Type
    assert((@s1).size == 24)
    assert((@s1).align == 8)
    var s2 = (@scope::get(res.scope, parser::make_identifier(["B"]))).value !*typechecking::Type
    assert((@s2).size == 4)
    assert((@s2).align == 2)
    var s3 = (@scope::get(res.scope, parser::make_identifier(["C"]))).value !*typechecking::Type
    assert((@s3).size == 8)
    assert((@s3).align == 4)

    str = "
        type A = struct #union {
            a: int8
            b: int32
            c: int64
        }
    "
    res = typecheck(str)
    var s4 = (@scope::get(res.scope, parser::make_identifier(["A"]))).value !*typechecking::Type
    assert((@s4).size == 8)
    assert((@s4).align == 8)

    // TODO
    /*str = "
        type A = struct {
            a: *A
        }
    "
    res = typecheck(str)*/

    print("OK\n")
}

def test_import {
    print(">Test import... ")

    var str = "
        import test::a
        test::a::multiply_by_2(4)
        multiply_by_2(10)
        multiply_by_2(10.5)
    "
    var res = typecheck(str)

    str = "
        import test::a
        def multiply_by_2(a: int) -> int {
            return a * 2
        }
        multiply_by_2(10)
        test::a::multiply_by_2(10)
        multiply_by_2(10.5) // test::a
    "
    res = typecheck(str)

    debug::redirect_stderr()
    str = "
        import test::a
        import test::b
        multiply_by_2(10)
        multiply_by_2(10.5)
    "
    res = typecheck(str)
    var errors = debug::catch_errors()
    assert(next_error_msg(errors) == "Ambiguous reference")

    print("OK\n")
}

def test_return {
    print(">Test return... ")

    var str = "
        def foo -> int {
            return 0
        }
    "
    var res = typecheck(str)

    str = "
        def foo -> int, bool {
            return 0, true
        }
        def bar -> int, bool {
            return foo()
        }
    "
    res = typecheck(str)

    debug::redirect_stderr()
    str = "
        def foo -> int, bool {
            return false, 'c'
        }
    "
    res = typecheck(str)
    var errors = debug::catch_errors()
    assert(next_error_msg(errors) == "Wrong type of return argument, got char, expected bool")
    assert(next_error_msg(errors) == "Wrong type of return argument, got bool, expected int")

    print("OK\n")
}

def test_pointers {
    print(">Test pointers... ")

    var str = "
        let a = 10
        let b = *a
        let c = @b
    "
    var res = typecheck(str)
    let a = (@scope::get(res.scope, parser::make_identifier(["a"]))).tpe
    let b = (@scope::get(res.scope, parser::make_identifier(["b"]))).tpe
    let c = (@scope::get(res.scope, parser::make_identifier(["c"]))).tpe
    assert(a == builtins::int_)
    assert(typechecking::equals(b, typechecking::pointer(builtins::int_)))
    assert(c == builtins::int_)

    debug::redirect_stderr()
    str = "
        let a = 10
        let b = @a
    "
    res = typecheck(str)
    var errors = debug::catch_errors()
    assert(next_error_msg(errors) == "Needs to be a pointer type, got int")

    print("OK\n")
}

def test_member_access {
    print(">Test member access... ")

    var str = "
        type T = struct {
            a: int
            b: double
        }
        var foo: T
        let a = foo.a
        let b = foo.b
    "
    var res = typecheck(str)
    let a = (@scope::get(res.scope, parser::make_identifier(["a"]))).tpe
    let b = (@scope::get(res.scope, parser::make_identifier(["b"]))).tpe
    assert(a == builtins::int_)
    assert(b == builtins::double_)

    // TODO Test error messages

    print("OK\n")
}

def test_array_subscript {
    print(">Test array subscript... ")

    var str = "
        var a: [4; int]
        let b = a[2]

        var c = 10
        var d = *c
        let e = d[2]
    "
    var res = typecheck(str)
    let b = (@scope::get(res.scope, parser::make_identifier(["b"]))).tpe
    let e = (@scope::get(res.scope, parser::make_identifier(["e"]))).tpe
    assert(b == builtins::int_)
    assert(e == builtins::int_)

    print("OK\n")
}

def test_array_lit {
    print(">Test array literal... ")

    var str = "
        let a = [1, 2, 3, 4]
        let b: [int] = a
    "
    var res = typecheck(str)
    let a = (@scope::get(res.scope, parser::make_identifier(["a"]))).tpe
    let b = (@scope::get(res.scope, parser::make_identifier(["b"]))).tpe
    assert((@a).kind == typechecking::TypeKind::STATIC_ARRAY)
    assert((@a).tpe == builtins::int_)
    assert((@a).length == 4)
    assert((@b).kind == typechecking::TypeKind::ARRAY)
    assert((@b).tpe == builtins::int_)

    print("OK\n")
}

export def test {
    print("Running tests on Typechecking...\n")
    test_vardecl()
    test_literals()
    test_operators()
    test_assign()
    test_def()
    test_typedecl()
    test_struct()
    test_import()
    test_return()
    test_pointers()
    test_member_access()
    test_array_subscript()
    // TODO Test struct literal
    test_array_lit()
}