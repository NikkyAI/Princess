// TODO Right now only functions get imported into the local namespace
// Should do the same thing with types and variables

import map
import typechecking
import parser
import vector
import buffer
import util
import toolchain

export type Value = struct {
    share: parser::ShareMarker
    modifier: parser::VarDecl
    // Name used by the source code
    name: string
    // Name used by the assembly, might be suffixed with a number
    // in case of shadowed variables
    assembly_name: string
    tpe: *typechecking::Type
    value: *
    // In case multiple values share one name (overloaded functions)
    next: *Value
    forward_declare: bool
    // True if the value is a global value
    global: bool
}

export type Scope = struct {
    // Counter for local scopes (shadowing)
    // Starts from 0 for function scopes
    // is -1 for all other scopes
    scope_count: int
    parent: *Scope
    fields: *map::Map
    // This is a list of imported scopes,
    // for resolving names from other modules without
    // specifying the full path
    // Vector of toolchain::Module
    imports: *vector::Vector
}

def get_scope_count(scope: *Scope) -> *int {
    if not scope { return null }
    if (@scope).scope_count >= 0 {
        return *(@scope).scope_count
    }
    return get_scope_count((@scope).parent)
}

def is_global(scope: *Scope) -> bool {
    // TODO Check against builtins
    if (@scope).parent == null { return true }
    scope = (@scope).parent
    if (@scope).parent == null { return true }
    return false
}

export def enter_scope(scope: *Scope) -> *Scope {
    var s = allocate(Scope)
    var scope_count = get_scope_count(scope)
    if scope_count {
        (@scope_count) += 1
    }
    (@s).scope_count = -1
    (@s).parent = scope
    (@s).fields = map::make()
    (@s).imports = null
    return s
}

export def enter_function_scope(scope: *Scope) -> *Scope {
    var s = enter_scope(scope)
    (@s).scope_count = 0
    return s
}

export def exit_scope(scope: *Scope) -> *Scope {
    return (@scope).parent
}

export def get(scope: *Scope, id: *parser::Node) -> *Value

def find_function(v: *Value, parameter_t: *vector::Vector, score: *int) -> *Value {
    if not v { return null }
    if not typechecking::is_function((@v).tpe) {
        return null
    }
    var found: *Value = null
    loop {
        let s = typechecking::overload_score((@v).tpe, parameter_t)
        if s >= 0 {
            if s <= @score {
                @score = s
                found = v
            }
        }
        v = (@v).next
        if not v { break }
    }
    return found
}

export def get_function(scope: *Scope, id: *parser::Node, parameter_t: *vector::Vector) -> *Value {
    assert((@id).kind == parser::NodeKind::IDENTIFIER)
    if vector::length((@id).value.body) == 1 {
        let name = @(vector::get((@id).value.body, 0) !*string)
        var score = util::MAX_INT32 !int
        let first_value = find_function(map::get((@scope).fields, name), parameter_t, *score)
        let first_score = score
        var value = first_value
        let scores = vector::make()
        if value {
            var i = allocate(int)
            @i = score
            vector::push(scores, i)
        }
        if (@scope).imports {
            for var i in 0..vector::length((@scope).imports) {
                let module = vector::get((@scope).imports, i) !*toolchain::Module
                let scope2 = (@module).scope
                let value2 = find_function(map::get((@scope2).fields, name), parameter_t, *score)
                if value2 and (@value2).share !int & parser::ShareMarker::EXPORT {
                    value = value2
                    // TODO Why don't we stop leaking memory here
                    var i = allocate(int)
                    @i = score
                    vector::push(scores, i)
                }
            }
            if first_value and first_score == score {
                // We always return the declaration in the current file
                // if there are multiple ones with the same score
                return first_value
            }
            var found = false

            if vector::length(scores) > 1 {
                // Check if there was an ambiguous reference 
                for var i in 0..vector::length(scores) {
                    var score2 = vector::get(scores, i) !*int
                    if @score2 == score {
                        if found {
                            typechecking::errorn(id, "Ambiguous reference\n")
                            break   
                            // TODO I would return null here but that causes another error
                        }
                        found = true
                    }
                }
            }
        }
        if value { return value }
        if (@scope).parent {
            return get_function((@scope).parent, id, parameter_t)
        }
        return null
    } else {
        let head = vector::head_vec((@id).value.body)
        let tail = vector::tail((@id).value.body)

        let id_head = parser::copy_node(id)
        (@id_head).value.body = head
        let id_tail = parser::copy_node(id)
        (@id_tail).value.body = tail

        let s = get(scope, id_head)
        if s {
            if (@(@s).tpe).kind != typechecking::TypeKind::NAMESPACE {
                typechecking::errorn(id, "Use of :: on non namespace\n")
                return null
            }
            return get_function((@s).value !*Scope, id_tail, parameter_t)
        }
        return null
    }
}

def unwrap_function_without_parameters(v: *Value) -> *Value {
    if not v { return null }
    if not typechecking::is_function((@v).tpe) {
        return v
    }
    loop {
        if vector::length((@(@v).tpe).parameter_t) == 0 {
            return v
        }
        v = (@v).next
        if not v { break }
    }
    return null
}

export def get(scope: *Scope, id: *parser::Node) -> *Value {
    assert((@id).kind == parser::NodeKind::IDENTIFIER)
    if vector::length((@id).value.body) == 1 {
        let name = @(vector::get((@id).value.body, 0) !*string)
        var value = unwrap_function_without_parameters(map::get((@scope).fields, name))
        if value { return value }
        if (@scope).imports {
            for var i in 0..vector::length((@scope).imports) {
                let module = vector::get((@scope).imports, i) !*toolchain::Module
                let scope2 = (@module).scope
                var value2 = unwrap_function_without_parameters(map::get((@scope2).fields, name))
                if value2 and (@value2).share !int & parser::ShareMarker::EXPORT {
                    if value {
                        // TODO save location of values to give better error messages
                        typechecking::errorn(id, "Ambiguous reference\n")
                        return null
                    }
                    value = value2
                }
            }
        }
        if value { return value }
        if (@scope).parent {
            return get((@scope).parent, id)
        }
        return null
    } else {
        let head = vector::head_vec((@id).value.body)
        let tail = vector::tail((@id).value.body)

        let id_head = parser::copy_node(id)
        (@id_head).value.body = head
        let id_tail = parser::copy_node(id)
        (@id_tail).value.body = tail

        let s = get(scope, id_head)
        if s {
            if (@(@s).tpe).kind != typechecking::TypeKind::NAMESPACE {
                typechecking::errorn(id, "Use of :: on non namespace\n")
                return null
            }
            return get((@s).value !*Scope, id_tail)
        }
        return null
    }
}

export def get_const_value(scope: *Scope, id: *parser::Node) -> *Value {
    let value = get(scope, id)
    if not value {
        typechecking::errorn(id, "Unknown identifier \"")
        error(parser::identifier_to_str(id), "\"\n")
        return null
    }
    assert((@value).modifier == parser::VarDecl::CONST or (@value).modifier == parser::VarDecl::TYPE)
    return value
}

export def get_type(scope: *Scope, id: *parser::Node) -> *typechecking::Type {
    let value = get_const_value(scope, id)
    if not value { return null }
    assert((@value).modifier == parser::VarDecl::TYPE)
    return (@value).value !*typechecking::Type
}

export def enter_namespace(scope: *Scope, node: *parser::Node) -> *Scope

// This function creates the namespaces for identifiers like 
// namespace::path::foo
// beware, this function can return null
def create_path(scope: *Scope, node: *parser::Node) -> *Scope {
    assert((@node).kind == parser::NodeKind::IDENTIFIER)

    let length = vector::length((@node).value.body)
    for var i in 0..length - 1 {
        let ident = vector::get((@node).value.body, i) !*string
        let scope_v = map::get((@scope).fields, @ident) !*Value
        if not scope_v {
            let n = parser::copy_node(node)
            let vec = vector::make()
            vector::push(vec, ident)
            (@n).value.body = vec
            scope = enter_namespace(scope, n)
        } else {
            if (@(@scope_v).tpe).kind != typechecking::TypeKind::NAMESPACE {
                typechecking::errorn(node, "Illegal declaration of ")
                error(parser::identifier_to_str(node), "\n")
                return null
            } else {
                scope = (@scope_v).value !*Scope
            }
        }
    }
    return scope
}

// Returns the last element in a path, eg Element for path::Element
def last_path_element(node: *parser::Node) -> string {
    assert((@node).kind == parser::NodeKind::IDENTIFIER)
    let length = vector::length((@node).value.body)
    return @(vector::get((@node).value.body, length - 1) !*string)
}

import debug

// TODO Give better error messages, where was the function/variable declared previously?
export def create_function(
    scope: *Scope, node: *parser::Node, share: parser::ShareMarker, 
    tpe: *typechecking::Type, forward_declare: bool) {

    assert((@tpe).kind == typechecking::TypeKind::FUNCTION)

    scope = create_path(scope, node)
    if not scope { return }
    let name = last_path_element(node)
    
    let v = allocate(Value)
    (@v).share = share
    (@v).modifier = parser::VarDecl::CONST
    (@v).name = name
    (@v).assembly_name = name
    (@v).tpe = tpe
    (@v).value = null
    (@v).next = null
    (@v).forward_declare = forward_declare
    (@v).global = is_global(scope)

    if map::contains((@scope).fields, name) {
        var val = map::get((@scope).fields, name) !*Value
        if not typechecking::is_function((@val).tpe) {
            typechecking::errorn(node, "Redeclaration of ")
            error("\"", name, "\"\n")
        }
        var next = val
        while next {
            if typechecking::overload_score((@next).tpe, (@tpe).parameter_t) == 0 {
                if not (@next).forward_declare {
                    typechecking::errorn(node, "Function ")
                    error("\"", name, "\" was already declared previously (same arguments)\n")
                } else if not forward_declare {
                    (@next).forward_declare = false
                }
                return
            }
            if (@next).next {
                next = (@next).next
            } else {
                break
            }
        }
        (@next).next = v
    } else {
        map::put((@scope).fields, name, v)
    }
}

def append_scope_count(scope: *Scope, name: string) -> string {
    let scope_count = get_scope_count(scope)
    if scope_count {
        let buf = buffer::make_buffer()
        buffer::append_str(*buf, name)
        buffer::append_char(*buf, '.')
        buffer::append_str(*buf, util::int_to_str(@scope_count))
        return buffer::to_string(*buf)
    }
    return name
}

export def create_variable(
    scope: *Scope, node: *parser::Node, share: parser::ShareMarker, 
    modifier: parser::VarDecl, tpe: *typechecking::Type, value: *) {
    
    scope = create_path(scope, node)
    if not scope { return }
    let name = last_path_element(node)

    let global = is_global(scope)
    let v = allocate(Value)
    (@v).share = share
    (@v).modifier = modifier
    (@v).name = name
    if global {
        (@v).assembly_name = name
    } else {
        (@v).assembly_name = append_scope_count(scope, name)
    }
    (@v).tpe = tpe
    (@v).value = value
    (@v).next = null
    (@v).global = global

    if map::contains((@scope).fields, name) {
        typechecking::errorn(node, "Redeclaration of ")
        error("\"", name, "\"\n")
    } else {
        map::put((@scope).fields, name, v)
    }
}

export def create_type(
    scope: *Scope, node: *parser::Node, 
    share: parser::ShareMarker, tpe: *typechecking::Type) -> bool {
    
    scope = create_path(scope, node)
    if not scope { return false }
    let name = last_path_element(node)
    var type_t = typechecking::make_type(typechecking::TypeKind::TYPE, node)

    let v = allocate(Value)
    (@v).share = share
    (@v).modifier = parser::VarDecl::TYPE
    (@v).name = name
    (@v).assembly_name = name
    (@v).tpe = type_t
    (@v).value = tpe
    (@v).next = null
    (@v).global = is_global(scope)

    let value = map::get((@scope).fields, name) !*Value
    if value {
        let tpe2 = (@value).value !*typechecking::Type
        if (@(@value).tpe).kind != typechecking::TypeKind::TYPE or
            (@tpe2).kind != typechecking::TypeKind::STUB and    
            (@tpe).kind != typechecking::TypeKind::STUB {
            typechecking::errorn(node, "Redeclaration of ")
            error("\"", name, "\"\n")
            return false
        } else if (@tpe2).kind == typechecking::TypeKind::STUB and
            (@tpe).kind != typechecking::TypeKind::STUB {
            @tpe2 = @tpe
        }
    } else {
        map::put((@scope).fields, name, v)
    }
    return true
}

export def enter_namespace(scope: *Scope, node: *parser::Node) -> *Scope {
    
    scope = create_path(scope, node)
    if not scope { return null }
    let name = last_path_element(node)
    let tpe = typechecking::make_type(typechecking::TypeKind::NAMESPACE, node)
    let scope2 = enter_scope(scope)

    let v = allocate(Value)
    (@v).share = parser::ShareMarker::NONE
    (@v).modifier = parser::VarDecl::CONST
    (@v).name = name
    (@v).assembly_name = name
    (@v).tpe = tpe
    (@v).value = scope2
    (@v).next = null
    (@v).global = is_global(scope)

    if map::contains((@scope).fields, name) {
        typechecking::errorn(node, "Redeclaration of ")
        error("\"", name, "\"\n")
    } else {
        map::put((@scope).fields, name, v)
    }
    return scope2
}

export def insert_module(scope: *Scope, alias: *parser::Node, module: *toolchain::Module) {
    // Don't import the same module twice
    if (@scope).imports {
        for var i in 0..vector::length((@scope).imports) {
            let module2 = vector::get((@scope).imports, i) !*toolchain::Module
            if (@module).filename == (@module2).filename { return }
        }
    }

    let ns = enter_namespace(scope, alias)
    if not ns { return }
    let values = map::keys((@(@module).scope).fields)
    for var i in 0..values.size {
        let value = map::get((@(@module).scope).fields, values[i]) !*Value
        if (@value).share !int & parser::ShareMarker::EXPORT {
            map::put((@ns).fields, values[i], value)
        }
    }
    if not (@scope).imports {
        (@scope).imports = vector::make()
    }
    vector::push((@scope).imports, module)
}