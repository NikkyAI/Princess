import map
import typechecking
import parser
import vector
import buffer
import util

export type Share = enum {
    NONE = 0
    EXPORT = 1
    IMPORT = 2
    BOTH = 3
}

export type Modifier = enum {
    LET
    VAR
    CONST
    TYPE
}

export type Value = struct {
    share: Share
    modifier: Modifier
    // Name used by the source code
    name: string
    tpe: *typechecking::Type
    value: *
    // In case multiple values share one name (overloaded functions)
    next: *Value
}

export type Scope = struct {
    parent: *Scope
    fields: *map::Map
}

export def enter_scope(scope: *Scope) -> *Scope {
    var s = allocate(Scope)
    (@s).parent = scope
    (@s).fields = map::make()
    return s
}

export def exit_scope(scope: *Scope) -> *Scope {
    return (@scope).parent
}

export def get(scope: *Scope, id: *parser::Node) -> *Value {
    assert((@id).kind == parser::NodeKind::IDENTIFIER)
    if vector::length((@id).value.body) == 1 {
        let name = @(vector::get((@id).value.body, 0) !*string)
        var value = map::get((@scope).fields, name)
        if value {
            return value
        }
        if (@scope).parent {
            return get((@scope).parent, id)
        }
        return null
    } else {
        let head = vector::head_vec((@id).value.body)
        let tail = vector::tail((@id).value.body)

        let id_head = parser::copy_node(id)
        (@id_head).value.body = head

        let id_tail = parser::copy_node(id)
        (@id_tail).value.body = tail

        let s = get(scope, id_head)
        if s {
            assert((@(@s).tpe).kind == typechecking::TypeKind::NAMESPACE)
            return get((@s).value !*Scope, id_tail)
        }
        return null
    }
}

export def get_const_value(scope: *Scope, id: *parser::Node) -> *Value {
    let value = get(scope, id)
    if not value {
        typechecking::errorn(id, "Unknown identifier \"")
        error(parser::identifier_to_str(id), "\"\n")
        return null
    }
    assert((@value).modifier == Modifier::CONST or (@value).modifier == Modifier::TYPE)
    return value
}

export def get_type(scope: *Scope, id: *parser::Node) -> *typechecking::Type {
    let value = get_const_value(scope, id)
    assert((@value).modifier == Modifier::TYPE)
    return (@value).value !*typechecking::Type
}

// TODO Give better error messages, where was the function/variable declared previously?
export def create_function(
    scope: *Scope, node: *parser::Node, share: Share, 
    name: string, parameter_t: *vector::Vector, return_t: *vector::Vector) {

    var tpe = typechecking::make_type(typechecking::TypeKind::FUNCTION, name, node)
    (@tpe).parameter_t = parameter_t
    (@tpe).return_t = return_t
    
    var v = allocate(Value)
    (@v).share = share
    (@v).modifier = Modifier::CONST
    (@v).name = name
    (@v).tpe = tpe
    (@v).value = null
    (@v).next = null

    if map::contains((@scope).fields, name) {
        var val = map::get((@scope).fields, name) !*Value
        if not typechecking::is_function((@val).tpe) {
            typechecking::errorn(node, "Redeclaration of ")
            error("\"", name, "\"\n")
        }
        var next = (@val).next
        while next {
            if typechecking::overload_score((@next).tpe, tpe) == 0 {
                typechecking::errorn(node, "Function ")
                error("\"", name, "\" was already declared previously (same arguments)\n")
            }
            next = (@val).next
        }
        (@next).next = v
    } else {
        map::put((@scope).fields, name, v)
    }
}

export def create_variable(
    scope: *Scope, node: *parser::Node, share: Share, 
    modifier: Modifier, name: string, tpe: *typechecking::Type, value: *) {

    var v = allocate(Value)
    (@v).share = share
    (@v).modifier = modifier
    (@v).name = name
    (@v).tpe = tpe
    (@v).value = value
    (@v).next = null

    if map::contains((@scope).fields, name) {
        typechecking::errorn(node, "Redeclaration of ")
        error("\"", name, "\"\n")
    } else {
        map::put((@scope).fields, name, v)
    }
}

export def create_type(
    scope: *Scope, node: *parser::Node, 
    share: Share, tpe: *typechecking::Type) {
    
    let name = (@tpe).name
    var type_t = typechecking::make_type(typechecking::TypeKind::TYPE, name, node)

    var v = allocate(Value)
    (@v).share = share
    (@v).modifier = Modifier::TYPE
    (@v).name = name
    (@v).tpe = type_t
    (@v).value = tpe
    (@v).next = null

    if map::contains((@scope).fields, name) {
        typechecking::errorn(node, "Redeclaration of ")
        error("\"", name, "\"\n")
    } else {
        map::put((@scope).fields, name, v)
    }
}