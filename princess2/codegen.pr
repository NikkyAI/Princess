import vector
import buffer
import map
import util
import compiler
import typechecking

export var outfolder = "."

def type_to_str(tpe: *typechecking::Type) -> string {
    if not tpe { return "void" }
    let buf = buffer::make_buffer()
    switch (@tpe).kind !int {
        case typechecking::TypeKind::BOOL:
            buffer::append_str(*buf, "i1")
        case typechecking::TypeKind::WORD:
            buffer::append_char(*buf, 'i')
            buffer::append_str(*buf, util::int_to_str((@tpe).size * 8))
        case typechecking::TypeKind::INT_LITERAL:
            // TODO Promote to bigger types
            buffer::append_char(*buf, 'i')
            buffer::append_str(*buf, util::int_to_str((size_of int) * 8))
        case typechecking::TypeKind::FLOAT:
            switch (@tpe).size {
                case 4: buffer::append_str(*buf, "float")
                case 8: buffer::append_str(*buf, "double")
                case: assert(false)
            }
        case typechecking::TypeKind::POINTER:
            if (@tpe).tpe {
                buffer::append_str(*buf, type_to_str((@tpe).tpe))
                buffer::append_char(*buf, '*')
            } else {
                // void pointer is i8*
                buffer::append_str(*buf, "i8*")
            }
        case typechecking::TypeKind::ARRAY:
            buffer::append_str(*buf, "{i32, ")
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
            buffer::append_str(*buf, "*}")
        case typechecking::TypeKind::STATIC_ARRAY:
            buffer::append_char(*buf, '[')
            buffer::append_str(*buf, util::int_to_str((@tpe).length))
            buffer::append_str(*buf, " x ")
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
            buffer::append_char(*buf, ']')
        case typechecking::TypeKind::STRUCT..typechecking::TypeKind::UNION:
            buffer::append_str(*buf, "%\"")
            buffer::append_str(*buf, (@tpe).type_name)
            buffer::append_char(*buf, '"')
        case: assert(false)
    }
    return buffer::to_string(*buf)
}

def value_to_str(value: compiler::Value) -> string {
    let buf = buffer::make_buffer()
    switch value.kind !int {
        case compiler::ValueKind::LOCAL:
            buffer::append_char(*buf, '%')
            buffer::append_str(*buf, value.name)
        case compiler::ValueKind::GLOBAL:
            buffer::append_str(*buf, "@\"")
            buffer::append_str(*buf, value.name)
            buffer::append_char(*buf, '"')
        case compiler::ValueKind::BOOL:
            if value.i {
                buffer::append_str(*buf, "true")
            } else {
                buffer::append_str(*buf, "false")
            }
        case compiler::ValueKind::INT:
            buffer::append_str(*buf, util::uint_to_str_sign(value.sign, value.i))
        case compiler::ValueKind::FLOAT:
            buffer::append_str(*buf, util::double_to_hex_str(value.f))
        case: assert(false)
    }
    return buffer::to_string(*buf)
}

def emit_arithmetic(fp: *, name: string, insn: *compiler::Insn) {
    write_string(fp, "\t")
    write_string(fp, value_to_str((@insn).value.arith.ret))
    write_string(fp, " = ")
    write_string(fp, name, " ")
    write_string(fp, type_to_str((@insn).value.arith.ret.tpe))
    write_string(fp, " ")
    write_string(fp, value_to_str((@insn).value.arith.left))
    write_string(fp, ", ")
    write_string(fp, value_to_str((@insn).value.arith.right))
    write_string(fp, "\n")
}

def emit_ret(fp: *, insn: *compiler::Insn) {
    write_string(fp, "\tret ")
    write_string(fp, type_to_str((@insn).value.ret.value.tpe))
    if (@insn).value.ret.value.tpe {
        write_string(fp, " ", value_to_str((@insn).value.ret.value))
    }
    write_string(fp, "\n")
}

def emit_call(fp: *, insn: *compiler::Insn) {
    write_string(fp, "\t")
    if (@insn).value.call.ret.tpe {
        write_string(fp, value_to_str((@insn).value.call.ret))
        write_string(fp, " = ")
    }
    write_string(fp, "call ")
    write_string(fp, type_to_str((@insn).value.call.ret.tpe))
    write_string(fp, " ")
    write_string(fp, value_to_str((@insn).value.call.name))
    write_string(fp, "(")
    let argsize = (@insn).value.call.args.size
    for var i in 0..argsize {
        let arg = (@insn).value.call.args[i]
        write_string(fp, type_to_str(arg.tpe), " ")
        write_string(fp, value_to_str(arg))
        if i < argsize - 1 {
            write_string(fp, ", ")
        }
    }
    write_string(fp, ")\n")
}

def emit_alloca(fp: *, insn: *compiler::Insn) {
    write_string(fp, "\t")
    write_string(fp, value_to_str((@insn).value.alloca.ret))
    write_string(fp, " = alloca ")
    write_string(fp, type_to_str((@insn).value.alloca.ret.tpe))
    write_string(fp, "\n")
}

def emit_store(fp: *, insn: *compiler::Insn) {
    write_string(fp, "\t")
    write_string(fp, "store ")
    write_string(fp, type_to_str((@insn).value.store.value.tpe))
    write_string(fp, " ")
    write_string(fp, value_to_str((@insn).value.store.value))
    write_string(fp, ", ")
    write_string(fp, type_to_str((@insn).value.store.loc.tpe))
    write_string(fp, " ")
    write_string(fp, value_to_str((@insn).value.store.loc))
    write_string(fp, "\n")
}

def emit_load(fp: *, insn: *compiler::Insn) {
    write_string(fp, "\t")
    write_string(fp, value_to_str((@insn).value.load.value))
    write_string(fp, " = load ")
    write_string(fp, type_to_str((@insn).value.load.value.tpe))
    write_string(fp, ", ")
    write_string(fp, type_to_str((@insn).value.load.loc.tpe))
    write_string(fp, " ")
    write_string(fp, value_to_str((@insn).value.load.loc))
    write_string(fp, "\n")
}

def emit_br(fp: *, insn: *compiler::Insn) {
    write_string(fp, "\t")
    write_string(fp, "br ")
    write_string(fp, type_to_str((@insn).value.br.cond.tpe))
    write_string(fp, " ")
    write_string(fp, value_to_str((@insn).value.br.cond))
    write_string(fp, ", label %")
    write_string(fp, (@insn).value.br.if_true.name)
    write_string(fp, ", label %")
    write_string(fp, (@insn).value.br.if_false.name)
    write_string(fp, "\n")
}

def emit_br_unc(fp: *, insn: *compiler::Insn) {
    write_string(fp, "\t")
    write_string(fp, "br label %")
    write_string(fp, (@insn).value.br_unc.label_.name)
    write_string(fp, "\n")
}

def emit(fp: *, insn: *compiler::Insn) {
    switch (@insn).kind !int {
        case compiler::InsnKind::ADD:
            emit_arithmetic(fp, "add", insn)
        case compiler::InsnKind::FADD:
            emit_arithmetic(fp, "fadd", insn)
        case compiler::InsnKind::ALLOCA:
            emit_alloca(fp, insn)
        case compiler::InsnKind::STORE:
            emit_store(fp, insn)
        case compiler::InsnKind::LOAD:
            emit_load(fp, insn)
        case compiler::InsnKind::CALL:
            emit_call(fp, insn)
        case compiler::InsnKind::BR:
            emit_br(fp, insn)
        case compiler::InsnKind::BR_UNC:
            emit_br_unc(fp, insn)
        case compiler::InsnKind::RET:
            emit_ret(fp, insn)
        case: assert(false)
    }
}

def emit_structure(fp: *, structure: *compiler::Structure) {

}

def emit_block(fp: *, block: *compiler::Block) {
    write_string(fp, (@block).label_, ":\n")
    for var i in 0..vector::length((@block).insn) {
        let insn = vector::get((@block).insn, i) !*compiler::Insn
        emit(fp, insn)
    }
}

def emit_function(fp: *, function: *compiler::Function) {
    if (@function).forward_declare {
        write_string(fp, "declare ")
    } else {
        write_string(fp, "define ")
    }
    write_string(fp, type_to_str((@function).ret), " ")
    write_string(fp, "@\"", (@function).name, "\"(")

    let len = vector::length((@function).args)
    for var i in 0..len {
        let np = vector::get((@function).args, i) !*typechecking::NamedParameter
        let tpe = (@np).value
        let name = (@np).name

        write_string(fp, type_to_str(tpe))
        if not (@function).forward_declare {
            write_string(fp, " ")
            write_string(fp, "%", name)
        }
        if i < len - 1 {
            write_string(fp, ", ")
        }
    }

    write_string(fp, ")")
    if not (@function).forward_declare {
        write_string(fp, " {\n")
        var block = (@function).block
        while block {
            emit_block(fp, block)
            block = (@block).next
        }
        write_string(fp, "}\n")
    } else {
        write_string(fp, "\n")
    }
}

def emit_global(fp: *, global: *compiler::Value) {
    write_string(fp, value_to_str(@global))
    write_string(fp, " = global ")
    write_string(fp, type_to_str((@global).tpe))
    write_string(fp, " zeroinitializer\n")
}

def gen_main_function(fp: *) {
    write_string(fp, "define i32 @main(i32 %argc, i8** %argv) {\n")
    write_string(fp, "\t%size = zext i32 %argc to i64\n")
    write_string(fp, "\t%size.1 = mul i64 %size, ", size_of string, "\n")
    write_string(fp, "\t%args = call i8* @malloc(i64 %size.1)\n")
    write_string(fp, "\t%args.1 = bitcast i8* %args to {i32, i8*}*\n")
    write_string(fp, "\t%args.2 = alloca {i32, {i32, i8*}*}\n")
    write_string(fp, "\tcall void @free(i8* %args)\n")
    write_string(fp, "\tret i32 0\n")
    write_string(fp, "}\n")
}

export def gen(result: compiler::Result, filename: string, module: string) -> string {
    let buf = buffer::make_buffer()
    buffer::append_str(*buf, outfolder)
    buffer::append_char(*buf, '/')
    buffer::append_str(*buf, util::replace_all(module, "::", "."))
    buffer::append_str(*buf, ".ll")
    let outfile = buffer::to_string(*buf)

    let fp = open(outfile, "w")
    
    write_string(fp, "; This file was compiled by the grace of your highness Princess Vic Nightfall\n")

    let keys_structures = map::keys(result.structures)
    for var i in 0..keys_structures.size {
        let structure = map::get(result.structures, keys_structures[i]) !*compiler::Structure
        emit_structure(fp, structure)
    }

    let keys_functions = map::keys(result.functions)
    for var i in 0..keys_functions.size {
        let function = map::get(result.functions, keys_functions[i]) !*compiler::Function
        emit_function(fp, function)
    }

    let keys_globals = map::keys(result.globals)
    for var i in 0..keys_globals.size {
        let global = map::get(result.globals, keys_globals[i]) !*compiler::Value
        emit_global(fp, global)
    }

    // TODO
    /*if module == "main" {
        gen_main_function(fp)
    }*/

    close(fp)

    return outfile
}