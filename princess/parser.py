#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals

import sys

from tatsu.buffering import Buffer
from tatsu.parsing import Parser
from tatsu.parsing import tatsumasu, leftrec, nomemo
from tatsu.parsing import leftrec, nomemo  # noqa
from tatsu.util import re, generic_main  # noqa


KEYWORDS = {
    'and',
    'as',
    'break',
    'case',
    'const',
    'continue',
    'def',
    'else',
    'enum',
    'export',
    'false',
    'for',
    'from',
    'go_to',
    'if',
    'import',
    'in',
    'label',
    'let',
    'loop',
    'not',
    'null',
    'or',
    'return',
    'size_of',
    'struct',
    'switch',
    'true',
    'type',
    'unsigned',
    'var',
    'while',
    'word',
}  # type: ignore


class PrincessBuffer(Buffer):
    def __init__(
        self,
        text,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        namechars='_',
        **kwargs
    ):
        super(PrincessBuffer, self).__init__(
            text,
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            namechars=namechars,
            **kwargs
        )


class PrincessParser(Parser):
    def __init__(
        self,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        left_recursion=True,
        parseinfo=True,
        keywords=None,
        namechars='_',
        buffer_class=PrincessBuffer,
        **kwargs
    ):
        if keywords is None:
            keywords = KEYWORDS
        super(PrincessParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            parseinfo=parseinfo,
            keywords=keywords,
            namechars=namechars,
            buffer_class=buffer_class,
            **kwargs
        )

    @tatsumasu('Body')
    def _code_body_(self):  # noqa
        self._token('{')
        self._n__()

        def block1():
            self._statement_()
        self._closure(block1)
        self.name_last_node('@')
        self._cut()
        self._token('}')

    @tatsumasu('Program')
    @nomemo
    def _program_(self):  # noqa

        def block1():
            self._statement_()
        self._closure(block1)
        self.name_last_node('@')
        self._check_eof()

    @tatsumasu()
    def _t_newline_(self):  # noqa
        self._pattern('[\\n]+')

    @tatsumasu()
    def _t_term_(self):  # noqa
        with self._choice():
            with self._option():
                self._token(';')
            with self._option():
                self._t_newline_()
            with self._option():
                with self._if():
                    self._check_eof()
            with self._option():
                with self._if():
                    self._token('}')
            self._error('no available options')

    @tatsumasu()
    def _n__(self):  # noqa
        self._pattern('[\\n\\t ]*')

    @tatsumasu()
    def _t_oparen_(self):  # noqa
        self._token('(')

    @tatsumasu()
    def _t_cparen_(self):  # noqa
        self._token(')')

    @tatsumasu()
    def _digit_(self):  # noqa
        self._pattern('[0-9]')

    @tatsumasu()
    def _hex_digit_(self):  # noqa
        self._pattern('[a-fA-F0-9]')

    @tatsumasu()
    def _oct_digit_(self):  # noqa
        self._pattern('[0-8]')

    @tatsumasu()
    def _bin_digit_(self):  # noqa
        self._pattern('[01]')

    @tatsumasu()
    def _sign_(self):  # noqa
        with self._choice():
            with self._option():
                self._pattern('[+-]')
            with self._option():
                self._constant('+')
            self._error('no available options')

    @tatsumasu()
    def _exp_(self):  # noqa
        self._pattern('[Ee]')
        self._sign_()
        self.name_last_node('sign')
        self._cut()

        def block2():
            self._digit_()
        self._positive_closure(block2)
        self.name_last_node('num')
        self.ast._define(
            ['num', 'sign'],
            []
        )

    @tatsumasu('Float')
    def _t_float_literal_(self):  # noqa
        with self._choice():
            with self._option():
                with self._group():

                    def block1():
                        self._digit_()
                    self._positive_closure(block1)
                    self.name_last_node('num')
                    with self._group():
                        with self._choice():
                            with self._option():
                                with self._group():
                                    self._token('.')
                                    self._cut()
                                    with self._group():
                                        with self._choice():
                                            with self._option():

                                                def block3():
                                                    self._digit_()
                                                self._positive_closure(block3)
                                            with self._option():
                                                self._constant('0')
                                            self._error('no available options')
                                    self.name_last_node('frac')
                                    with self._optional():
                                        self._exp_()
                                    self.name_last_node('exp')
                            with self._option():
                                self._constant('0')
                                self.name_last_node('frac')
                                self._exp_()
                                self.name_last_node('exp')
                            self._error('no available options')
            with self._option():
                with self._group():
                    self._constant('0')
                    self.name_last_node('num')
                    self._token('.')
                    self._cut()

                    def block11():
                        self._digit_()
                    self._positive_closure(block11)
                    self.name_last_node('frac')
                    with self._optional():
                        self._exp_()
                    self.name_last_node('exp')
            self._error('no available options')
        self.ast._define(
            ['exp', 'frac', 'num'],
            []
        )

    @tatsumasu('Integer')
    def _t_dec_literal_(self):  # noqa
        self._constant(10)
        self.name_last_node('base')

        def block2():
            self._digit_()
        self._positive_closure(block2)
        self.name_last_node('num')
        self.ast._define(
            ['base', 'num'],
            []
        )

    @tatsumasu('Integer')
    def _t_hex_literal_(self):  # noqa
        self._pattern('0x')
        self._cut()
        self._constant(16)
        self.name_last_node('base')

        def block2():
            self._hex_digit_()
        self._positive_closure(block2)
        self.name_last_node('num')
        self.ast._define(
            ['base', 'num'],
            []
        )

    @tatsumasu('Integer')
    def _t_oct_literal_(self):  # noqa
        self._pattern('0o')
        self._cut()
        self._constant(8)
        self.name_last_node('base')

        def block2():
            self._oct_digit_()
        self._positive_closure(block2)
        self.name_last_node('num')
        self.ast._define(
            ['base', 'num'],
            []
        )

    @tatsumasu('Integer')
    def _t_bin_literal_(self):  # noqa
        self._pattern('0b')
        self._cut()
        self._constant(2)
        self.name_last_node('base')

        def block2():
            self._bin_digit_()
        self._positive_closure(block2)
        self.name_last_node('num')
        self.ast._define(
            ['base', 'num'],
            []
        )

    @tatsumasu()
    def _t_int_literal_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._t_hex_literal_()
                with self._option():
                    self._t_bin_literal_()
                with self._option():
                    self._t_oct_literal_()
                with self._option():
                    self._t_dec_literal_()
                self._error('no available options')

    @tatsumasu()
    def _t_num_lit_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._t_float_literal_()
                with self._option():
                    self._t_int_literal_()
                self._error('no available options')

    @tatsumasu()
    def _ESC_CHAR_(self):  # noqa
        self._pattern('[abfnrtv\\\\\'\\\\"0]')
        self.add_last_node_to_name('@')

    @tatsumasu()
    def _ESC_SEQ_(self):  # noqa
        with self._choice():
            with self._option():
                with self._group():
                    self._pattern('x')
                    self._cut()
                    self._hex_digit_()
                    self._hex_digit_()
            with self._option():
                with self._group():
                    self._pattern('u')
                    self._cut()
                    self._hex_digit_()
                    self._hex_digit_()
                    self._hex_digit_()
                    self._hex_digit_()
            with self._option():
                with self._group():
                    self._pattern('U')
                    self._cut()
                    self._hex_digit_()
                    self._hex_digit_()
                    self._hex_digit_()
                    self._hex_digit_()
                    self._hex_digit_()
                    self._hex_digit_()
                    self._hex_digit_()
                    self._hex_digit_()
            with self._option():
                self._cut()
                self._ESC_CHAR_()
            self._error('no available options')

    @tatsumasu()
    def _T_CHAR_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    with self._group():
                        self._pattern('\\\\')
                        self._cut()
                        self._ESC_SEQ_()
                        self.name_last_node('@')
                with self._option():
                    self._pattern('[^\\0\\x7f\\x80"\\\\]+')
                self._error('no available options')

    @tatsumasu()
    def _T_CHAR_S_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    with self._group():
                        self._pattern('\\\\')
                        self._cut()
                        self._ESC_SEQ_()
                        self.name_last_node('@')
                with self._option():
                    self._pattern("[^\\0\\x7f\\x80'\\\\]")
                self._error('no available options')

    @tatsumasu('Char')
    def _T_CHAR_LIT_(self):  # noqa
        self._token("'")
        self._T_CHAR_S_()
        self.name_last_node('@')
        self._cut()
        self._token("'")

    @tatsumasu('String')
    def _T_STRING_LIT_(self):  # noqa
        self._token('"')

        def block1():
            self._T_CHAR_()
        self._closure(block1)
        self.name_last_node('@')
        self._cut()
        self._token('"')

    @tatsumasu()
    def _t_ident_(self):  # noqa
        self._pattern('(?!\\d)\\w+')
        self._check_name()

    @tatsumasu('Identifier')
    def _identifier_(self):  # noqa
        with self._optional():
            self._token('::')
            self.name_last_node('root')

        def sep2():
            self._token('::')

        def block2():
            self._t_ident_()
        self._positive_gather(block2, sep2)
        self.name_last_node('ident')
        self.ast._define(
            ['ident', 'root'],
            []
        )

    @tatsumasu()
    def _t_bool_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('true')
                self._constant(True)
                self.name_last_node('@')
            with self._option():
                self._token('false')
                self._constant(False)
                self.name_last_node('@')
            self._error('no available options')

    @tatsumasu('Boolean')
    def _t_bool_lit_(self):  # noqa
        self._t_bool_()
        self.name_last_node('@')

    @tatsumasu('Null')
    def _t_null_(self):  # noqa
        self._token('null')
        self._void()
        self.name_last_node('@')

    @tatsumasu()
    def _array_element_(self):  # noqa
        self._n__()
        self._expression_call_()
        self.name_last_node('@')
        self._n__()

    @tatsumasu('Array')
    def _array_lit_(self):  # noqa
        self._token('[')
        self._n__()

        def sep1():
            self._token(',')

        def block1():
            self._array_element_()
        self._gather(block1, sep1)
        self.name_last_node('@')
        self._cut()
        self._token(']')

    @tatsumasu()
    def _literal_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._array_lit_()
                with self._option():
                    self._t_num_lit_()
                with self._option():
                    self._t_bool_lit_()
                with self._option():
                    self._t_null_()
                with self._option():
                    self._T_CHAR_LIT_()
                with self._option():
                    self._T_STRING_LIT_()
                self._error('no available options')

    @tatsumasu()
    def _value_(self):  # noqa
        with self._choice():
            with self._option():
                self._literal_()
            with self._option():
                self._identifier_()
            self._error('no available options')

    @tatsumasu('StructArg')
    def _struct_arg_named_(self):  # noqa
        self._n__()
        self._identifier_()
        self.name_last_node('name')
        self._token('=')
        self._expression_call_()
        self.name_last_node('value')
        self.ast._define(
            ['name', 'value'],
            []
        )

    @tatsumasu('StructArg')
    def _struct_arg_(self):  # noqa
        self._n__()
        self._expression_call_()
        self.name_last_node('value')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu('StructInit')
    def _struct_lit_(self):  # noqa
        self._token('{')

        def sep1():
            self._token(',')

        def block1():
            with self._choice():
                with self._option():
                    self._struct_arg_named_()
                with self._option():
                    self._struct_arg_()
                self._error('no available options')
        self._gather(block1, sep1)
        self.name_last_node('args')
        self._n__()
        self._cut()
        self._token('}')
        self.ast._define(
            ['args'],
            []
        )

    @tatsumasu('StructInit')
    def _struct_lit_typed_(self):  # noqa
        self._token('{')

        def sep1():
            self._token(',')

        def block1():
            with self._choice():
                with self._option():
                    self._struct_arg_named_()
                with self._option():
                    self._struct_arg_()
                self._error('no available options')
        self._gather(block1, sep1)
        self.name_last_node('args')
        self._n__()
        self._cut()
        self._token('}')

        with self._optional():
            self._token('!')
            self._cut()
            self._type_()
            self.name_last_node('type')
        self.ast._define(
            ['args', 'type'],
            []
        )

    @tatsumasu('StructuralT')
    def _type_structural_(self):  # noqa
        self._token('{')
        self._n__()
        with self._ifnot():
            self._void()
        self._cut()
        self._token('}')

    @tatsumasu('Else')
    def _stmt_struct_else_(self):  # noqa
        self._token('else')
        self._n__()
        self._cut()
        self._struct_body_()
        self.name_last_node('body')
        self.ast._define(
            ['body'],
            []
        )

    @tatsumasu('ElseIf')
    def _stmt_struct_else_if_(self):  # noqa
        self._token('else')
        self._n__()
        self._token('if')
        self._n__()
        self._cut()
        self._expression_()
        self.name_last_node('cond')
        self._n__()
        self._struct_body_()
        self.name_last_node('body')
        self.ast._define(
            ['body', 'cond'],
            []
        )

    @tatsumasu('If')
    def _stmt_struct_if_(self):  # noqa
        self._token('#if')
        self._n__()
        self._cut()
        self._expression_()
        self.name_last_node('cond')
        self._n__()
        self._struct_body_()
        self.name_last_node('body')

        def block3():
            self._stmt_struct_else_if_()
        self._closure(block3)
        self.name_last_node('else_if')
        with self._optional():
            self._n__()
            self._stmt_struct_else_()
            self.name_last_node('else_')
        self.ast._define(
            ['body', 'cond', 'else_', 'else_if'],
            []
        )

    @tatsumasu('IdDeclStruct')
    def _struct_iddecl_(self):  # noqa
        self._n__()
        self._identifier_()
        self.name_last_node('name')
        with self._optional():
            self._token(':')
            self._n__()
            self._type_()
            self.name_last_node('type')
        self.ast._define(
            ['name', 'type'],
            []
        )

    @tatsumasu()
    def _struct_def_(self):  # noqa
        with self._choice():
            with self._option():
                self._void()
                self.name_last_node('@')
                self._t_term_()
            with self._option():
                self._struct_def_noterm_()
                self.name_last_node('@')
                self._t_term_()
            self._error('no available options')

    @tatsumasu()
    def _struct_def_noterm_(self):  # noqa
        with self._choice():
            with self._option():
                self._t_oparen_()
                with self._group():
                    with self._choice():
                        with self._option():
                            self._void()
                            self.name_last_node('@')
                            with self._if():
                                self._token(')')
                        with self._option():
                            self._struct_def_noterm_()
                            self.name_last_node('@')
                        self._error('no available options')
                self._t_cparen_()
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._type_struct_()
                        with self._option():
                            self._stmt_struct_if_()
                        with self._option():
                            self._struct_iddecl_()
                        self._error('no available options')
                self.name_last_node('@')
            self._error('no available options')

    @tatsumasu('StructBody')
    def _struct_body_(self):  # noqa
        self._token('{')
        self._n__()

        def block1():
            self._struct_def_()
        self._closure(block1)
        self.name_last_node('@')
        self._n__()
        self._token('}')

    @tatsumasu()
    def _struct_pragmas_(self):  # noqa
        self._token('#union')
        self.name_last_node('@')
        self._n__()

    @tatsumasu('Struct')
    def _type_struct_(self):  # noqa
        self._token('struct')
        self._n__()

        def block1():
            self._struct_pragmas_()
        self._closure(block1)
        self.name_last_node('pragma')
        self._n__()
        self._struct_body_()
        self.name_last_node('body')
        self.ast._define(
            ['body', 'pragma'],
            []
        )

    @tatsumasu('Else')
    def _stmt_enum_else_(self):  # noqa
        self._token('else')
        self._n__()
        self._cut()
        self._enum_body_()
        self.name_last_node('body')
        self.ast._define(
            ['body'],
            []
        )

    @tatsumasu('ElseIf')
    def _stmt_enum_else_if_(self):  # noqa
        self._token('else')
        self._n__()
        self._token('if')
        self._n__()
        self._cut()
        self._expression_()
        self.name_last_node('cond')
        self._n__()
        self._enum_body_()
        self.name_last_node('body')
        self.ast._define(
            ['body', 'cond'],
            []
        )

    @tatsumasu('If')
    def _stmt_enum_if_(self):  # noqa
        self._token('#if')
        self._n__()
        self._cut()
        self._expression_()
        self.name_last_node('cond')
        self._n__()
        self._enum_body_()
        self.name_last_node('body')

        def block3():
            self._stmt_enum_else_if_()
        self._closure(block3)
        self.name_last_node('else_if')
        with self._optional():
            self._n__()
            self._stmt_enum_else_()
            self.name_last_node('else_')
        self.ast._define(
            ['body', 'cond', 'else_', 'else_if'],
            []
        )

    @tatsumasu('IdDeclEnum')
    def _enum_iddecl_(self):  # noqa
        self._n__()
        self._identifier_()
        self.name_last_node('name')
        with self._optional():
            self._token('=')
            self._n__()
            self._expression_()
            self.name_last_node('value')
        self.ast._define(
            ['name', 'value'],
            []
        )

    @tatsumasu()
    def _enum_def_(self):  # noqa
        with self._choice():
            with self._option():
                self._void()
                self.name_last_node('@')
                self._t_term_()
            with self._option():
                self._enum_def_noterm_()
                self.name_last_node('@')
                self._t_term_()
            self._error('no available options')

    @tatsumasu()
    def _enum_def_noterm_(self):  # noqa
        with self._choice():
            with self._option():
                self._t_oparen_()
                with self._group():
                    with self._choice():
                        with self._option():
                            self._void()
                            self.name_last_node('@')
                            with self._if():
                                self._token(')')
                        with self._option():
                            self._enum_def_noterm_()
                            self.name_last_node('@')
                        self._error('no available options')
                self._t_cparen_()
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._stmt_enum_if_()
                        with self._option():
                            self._enum_iddecl_()
                        self._error('no available options')
                self.name_last_node('@')
            self._error('no available options')

    @tatsumasu('EnumBody')
    def _enum_body_(self):  # noqa
        self._token('{')
        self._n__()

        def block1():
            self._enum_def_()
        self._closure(block1)
        self.name_last_node('@')
        self._n__()
        self._token('}')

    @tatsumasu('TEnum')
    def _type_enum_(self):  # noqa
        self._token('enum')
        self._n__()
        with self._optional():
            self._token(':')
            self._n__()
            self._type_()
            self.name_last_node('type')
            self._n__()
        self._n__()
        self._enum_body_()
        self.name_last_node('body')
        self.ast._define(
            ['body', 'type'],
            []
        )

    @tatsumasu('PtrT')
    def _type_ptr_(self):  # noqa
        self._token('*')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('var')
                with self._option():
                    self._token('let')
                with self._option():
                    self._constant('var')
                self._error('no available options')
        self.name_last_node('keyword')
        with self._optional():
            self._type_1_()
            self.name_last_node('type')
        self.ast._define(
            ['keyword', 'type'],
            []
        )

    @tatsumasu('RefT')
    def _type_ref_(self):  # noqa
        self._token('&')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('var')
                with self._option():
                    self._token('let')
                with self._option():
                    self._constant('var')
                self._error('no available options')
        self.name_last_node('keyword')
        with self._optional():
            self._type_1_()
            self.name_last_node('type')
        self.ast._define(
            ['keyword', 'type'],
            []
        )

    @tatsumasu('ArrayT')
    def _type_array_dyn_(self):  # noqa
        self._token('[')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('var')
                with self._option():
                    self._token('let')
                with self._option():
                    self._constant('var')
                self._error('no available options')
        self.name_last_node('keyword')
        with self._optional():
            self._type_()
            self.name_last_node('type')
        self._token(']')
        self.ast._define(
            ['keyword', 'type'],
            []
        )

    @tatsumasu('ArrayT')
    def _type_array_static_(self):  # noqa
        self._token('[')
        self._cut()
        with self._group():
            with self._choice():
                with self._option():
                    self._token('?')
                with self._option():
                    self._expression_()
                self._error('no available options')
        self.name_last_node('n')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('var')
                with self._option():
                    self._token('let')
                with self._option():
                    self._constant('var')
                self._error('no available options')
        self.name_last_node('keyword')
        with self._optional():
            self._type_()
            self.name_last_node('type')
        self._token(']')
        self.ast._define(
            ['keyword', 'n', 'type'],
            []
        )

    @tatsumasu()
    def _type_array_(self):  # noqa
        with self._choice():
            with self._option():
                self._type_array_dyn_()
            with self._option():
                self._type_array_static_()
            self._error('no available options')

    @tatsumasu()
    @nomemo
    def _type_list_elem_(self):  # noqa
        self._type_()
        self.name_last_node('@')

    @tatsumasu()
    @nomemo
    def _type_list_(self):  # noqa
        with self._choice():
            with self._option():
                with self._group():
                    self._t_oparen_()
                    self._cut()

                    def sep1():
                        self._token(',')

                    def block1():
                        self._type_list_elem_()
                    self._gather(block1, sep1)
                    self.name_last_node('@')
                    self._t_cparen_()
            with self._option():
                self._type_()
                self.add_last_node_to_name('@')
            self._error('no available options')

    @tatsumasu('FunctionT')
    @nomemo
    def _type_function_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('->')
                with self._optional():
                    self._type_list_()
                    self.name_last_node('right')
            with self._option():
                self._type_list_()
                self.name_last_node('left')
                self._token('->')
                with self._optional():
                    self._type_list_()
                    self.name_last_node('right')
            self._error('no available options')
        self.ast._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('Unsigned')
    def _type_unsigned_(self):  # noqa
        self._token('unsigned')
        self._type_2_()
        self.name_last_node('@')

    @tatsumasu('Word')
    def _type_word_(self):  # noqa
        self._token('word')
        self._t_oparen_()
        self._t_int_literal_()
        self.name_last_node('@')
        self._t_cparen_()

    @tatsumasu()
    def _type_3_(self):  # noqa
        with self._choice():
            with self._option():
                self._t_oparen_()
                self._type_()
                self.name_last_node('@')
                self._t_cparen_()
            with self._option():
                self._type_word_()
            with self._option():
                self._identifier_()
            self._error('no available options')

    @tatsumasu()
    @leftrec
    def _type_2_(self):  # noqa
        with self._choice():
            with self._option():
                self._expr_type_call_()
            with self._option():
                self._type_3_()
            self._error('no available options')

    @tatsumasu()
    @nomemo
    def _type_1_(self):  # noqa
        with self._choice():
            with self._option():
                self._type_struct_()
            with self._option():
                self._type_enum_()
            with self._option():
                self._type_unsigned_()
            with self._option():
                self._type_structural_()
            with self._option():
                self._type_ptr_()
            with self._option():
                self._type_ref_()
            with self._option():
                self._type_array_()
            with self._option():
                self._type_2_()
            self._error('no available options')

    @tatsumasu()
    @leftrec
    def _type_(self):  # noqa
        with self._choice():
            with self._option():
                self._type_function_()
            with self._option():
                self._type_1_()
            self._error('no available options')

    @tatsumasu('CallArg')
    def _call_arg_named_(self):  # noqa
        self._identifier_()
        self.name_last_node('name')
        self._token('=')
        self._expression_call_()
        self.name_last_node('value')
        self.ast._define(
            ['name', 'value'],
            []
        )

    @tatsumasu('CallArg')
    def _call_arg_(self):  # noqa
        self._expression_call_()
        self.name_last_node('value')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu()
    def _call_args_(self):  # noqa
        self._t_oparen_()

        def sep1():
            self._token(',')

        def block1():
            with self._choice():
                with self._option():
                    self._call_arg_named_()
                with self._option():
                    self._call_arg_()
                self._error('no available options')
        self._gather(block1, sep1)
        self.name_last_node('@')
        self._cut()
        self._t_cparen_()

    @tatsumasu('Call')
    @nomemo
    def _expr_call_(self):  # noqa
        self._expr_10_()
        self.name_last_node('left')
        self._call_args_()
        self.name_last_node('args')
        self.ast._define(
            ['args', 'left'],
            []
        )

    @tatsumasu('Call')
    @nomemo
    def _expr_type_call_(self):  # noqa
        self._type_2_()
        self.name_last_node('left')
        self._call_args_()
        self.name_last_node('args')
        self.ast._define(
            ['args', 'left'],
            []
        )

    @tatsumasu('ArrayIndex')
    @nomemo
    def _expr_array_index_(self):  # noqa
        self._expr_10_()
        self.name_last_node('left')
        self._token('[')
        self._n__()
        self._expression_()
        self.name_last_node('right')
        self._n__()
        self._cut()
        self._token(']')
        self.ast._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('MemberAccess')
    @nomemo
    def _expr_member_access_(self):  # noqa
        self._expr_10_()
        self.name_last_node('left')
        self._token('.')
        self._value_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'right'],
            []
        )

    @tatsumasu()
    def _expr_type_(self):  # noqa
        self._token('type')
        self._type_()
        self.name_last_node('@')

    @tatsumasu()
    def _post_lh_(self):  # noqa
        self._pattern('[\\d\\w\\(]')

    @tatsumasu('PostInc')
    @nomemo
    def _expr_postinc_(self):  # noqa
        self._expr_10_()
        self.name_last_node('left')
        self._token('++')
        with self._ifnot():
            self._post_lh_()
        self.ast._define(
            ['left'],
            []
        )

    @tatsumasu('PostDec')
    @nomemo
    def _expr_postdec_(self):  # noqa
        self._expr_10_()
        self.name_last_node('left')
        self._token('--')
        with self._ifnot():
            self._post_lh_()
        self.ast._define(
            ['left'],
            []
        )

    @tatsumasu('Cast')
    @nomemo
    def _expr_cast_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._struct_lit_()
                with self._option():
                    self._expr_9_()
                self._error('no available options')
        self.name_last_node('left')
        self._token('!')
        with self._ifnot():
            self._token('=')
        self._cut()
        self._type_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('Cast')
    @nomemo
    def _expr_autocast_(self):  # noqa
        self._expr_10_()
        self.name_last_node('left')
        self._token('!!')
        self.ast._define(
            ['left'],
            []
        )

    @tatsumasu('PreInc')
    def _expr_preinc_(self):  # noqa
        self._token('++')
        self._cut()
        self._expr_9_()
        self.name_last_node('right')
        self.ast._define(
            ['right'],
            []
        )

    @tatsumasu('PreDec')
    def _expr_predec_(self):  # noqa
        self._token('--')
        self._cut()
        self._expr_9_()
        self.name_last_node('right')
        self.ast._define(
            ['right'],
            []
        )

    @tatsumasu('UMinus')
    def _expr_uminus_(self):  # noqa
        self._token('-')
        self._cut()
        self._expr_9_()
        self.name_last_node('right')
        self.ast._define(
            ['right'],
            []
        )

    @tatsumasu('Deref')
    def _expr_deref_(self):  # noqa
        self._token('@')
        self._cut()
        self._expr_9_()
        self.name_last_node('right')
        self.ast._define(
            ['right'],
            []
        )

    @tatsumasu('Ptr')
    def _expr_ptr_(self):  # noqa
        self._token('*')
        self._cut()
        self._expr_9_()
        self.name_last_node('right')
        self.ast._define(
            ['right'],
            []
        )

    @tatsumasu('Invert')
    def _expr_invert_(self):  # noqa
        self._token('~')
        self._cut()
        self._expr_9_()
        self.name_last_node('right')
        self.ast._define(
            ['right'],
            []
        )

    @tatsumasu('Not')
    def _expr_not_(self):  # noqa
        self._token('not')
        self._cut()
        self._expr_9_()
        self.name_last_node('right')
        self.ast._define(
            ['right'],
            []
        )

    @tatsumasu('Shr')
    @nomemo
    def _expr_shr_(self):  # noqa
        self._expr_7_()
        self.name_last_node('left')
        self._token('>>')
        self._n__()
        self._cut()
        self._expr_8_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('Shl')
    @nomemo
    def _expr_shl_(self):  # noqa
        self._expr_7_()
        self.name_last_node('left')
        self._token('<<')
        self._n__()
        self._cut()
        self._expr_8_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('BAnd')
    @nomemo
    def _expr_band_(self):  # noqa
        self._expr_7_()
        self.name_last_node('left')
        self._token('&')
        self._n__()
        self._cut()
        self._expr_8_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('BOr')
    @nomemo
    def _expr_bor_(self):  # noqa
        self._expr_7_()
        self.name_last_node('left')
        self._token('|')
        self._n__()
        self._cut()
        self._expr_8_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('Xor')
    @nomemo
    def _expr_xor_(self):  # noqa
        self._expr_7_()
        self.name_last_node('left')
        self._token('^')
        self._n__()
        self._cut()
        self._expr_8_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('Mul')
    @nomemo
    def _expr_mul_(self):  # noqa
        self._expr_6_()
        self.name_last_node('left')
        self._token('*')
        self._n__()
        self._cut()
        self._expr_7_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('Div')
    @nomemo
    def _expr_div_(self):  # noqa
        self._expr_6_()
        self.name_last_node('left')
        self._token('/')
        self._n__()
        self._cut()
        self._expr_7_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('Mod')
    @nomemo
    def _expr_mod_(self):  # noqa
        self._expr_6_()
        self.name_last_node('left')
        self._token('%')
        self._n__()
        self._cut()
        self._expr_7_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('PAdd')
    @nomemo
    def _expr_padd_(self):  # noqa
        self._expr_5_()
        self.name_last_node('left')
        self._token('++')
        self._n__()
        self._cut()
        self._expr_6_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('PSub')
    @nomemo
    def _expr_psub_(self):  # noqa
        self._expr_5_()
        self.name_last_node('left')
        self._token('--')
        self._n__()
        self._cut()
        self._expr_6_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('Add')
    @nomemo
    def _expr_add_(self):  # noqa
        self._expr_5_()
        self.name_last_node('left')
        self._token('+')
        self._n__()
        self._cut()
        self._expr_6_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('Sub')
    @nomemo
    def _expr_sub_(self):  # noqa
        self._expr_5_()
        self.name_last_node('left')
        self._token('-')
        self._n__()
        self._cut()
        self._expr_6_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('CompareOp')
    def _cmp_op_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._token('<=')
                with self._option():
                    self._token('>=')
                with self._option():
                    self._token('<')
                with self._option():
                    self._token('>')
                with self._option():
                    self._token('==')
                with self._option():
                    self._token('!=')
                self._error('no available options')

    @tatsumasu()
    def _expr_cmp_(self):  # noqa
        self._cmp_op_()
        self.name_last_node('op')
        self._n__()
        self._cut()
        self._expr_5_()
        self.name_last_node('right')
        self.ast._define(
            ['op', 'right'],
            []
        )

    @tatsumasu('Compare')
    @nomemo
    def _expr_cmp_start_(self):  # noqa
        self._expr_5_()
        self.name_last_node('left')

        def block2():
            self._expr_cmp_()
        self._positive_closure(block2)
        self.name_last_node('right')
        self.ast._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('And')
    @nomemo
    def _expr_and_(self):  # noqa
        self._expr_3_()
        self.name_last_node('left')
        self._token('and')
        self._cut()
        self._expr_4_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('Or')
    @nomemo
    def _expr_or_(self):  # noqa
        self._expr_2_()
        self.name_last_node('left')
        self._token('or')
        self._cut()
        self._expr_3_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('AssignOp')
    def _assign_op_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._token('++=')
                with self._option():
                    self._token('--=')
                with self._option():
                    self._token('+=')
                with self._option():
                    self._token('-=')
                with self._option():
                    self._token('*=')
                with self._option():
                    self._token('/=')
                with self._option():
                    self._token('%=')
                with self._option():
                    self._token('|=')
                with self._option():
                    self._token('&=')
                with self._option():
                    self._token('^=')
                with self._option():
                    self._token('>>=')
                with self._option():
                    self._token('<<=')
                self._error('no available options')

    @tatsumasu('AssignAndOp')
    @nomemo
    def _expr_assign_op_(self):  # noqa
        self._expr_2_()
        self.name_last_node('left')
        self._assign_op_()
        self.name_last_node('op')
        self._n__()
        self._cut()
        self._expr_1_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu()
    def _expr_assign_lhs_(self):  # noqa
        self._expr_2_()
        self.name_last_node('@')

    @tatsumasu()
    def _expr_assign_rhs_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._struct_lit_typed_()
                with self._option():
                    self._expr_1_()
                self._error('no available options')
        self.name_last_node('@')

    @tatsumasu('Assign')
    def _expr_assign_(self):  # noqa

        def sep1():
            self._token(',')

        def block1():
            self._expr_assign_lhs_()
        self._positive_gather(block1, sep1)
        self.name_last_node('left')
        self._token('=')
        self._n__()
        self._cut()

        def sep3():
            self._token(',')

        def block3():
            self._expr_assign_rhs_()
        self._positive_gather(block3, sep3)
        self.name_last_node('right')
        self.ast._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('IfExpr')
    def _expr_if_(self):  # noqa
        self._expr_2_()
        self.name_last_node('if_true')
        with self._group():
            self._token('if')
        self._n__()
        self._cut()
        self._expr_1_()
        self.name_last_node('cond')
        self._n__()
        with self._group():
            self._token('else')
        self._n__()
        self._expr_1_()
        self.name_last_node('if_false')
        self.ast._define(
            ['cond', 'if_false', 'if_true'],
            []
        )

    @tatsumasu('Do')
    def _expr_do_(self):  # noqa
        self._token('do')
        self._n__()
        self._cut()
        self._code_body_()
        self.name_last_node('@')

    @tatsumasu('SizeOf')
    def _expr_size_of_(self):  # noqa
        self._token('size_of')
        self._n__()
        self._cut()
        self._expression_no_assign_()
        self.name_last_node('@')

    @tatsumasu('Range')
    @nomemo
    def _expr_range_(self):  # noqa
        with self._optional():
            self._expr_1_()
            self.name_last_node('from_')
        self._token(':')
        with self._optional():
            self._n__()
            self._expr_1_()
            self.name_last_node('to')
            with self._optional():
                self._token(':')
                self._n__()
                self._expr_1_()
                self.name_last_node('step')
        self.ast._define(
            ['from_', 'step', 'to'],
            []
        )

    @tatsumasu('Range')
    def _expr_rangec_(self):  # noqa
        with self._optional():
            self._expr_1c_()
            self.name_last_node('from_')
        self._token(':')
        with self._optional():
            self._n__()
            self._expr_1c_()
            self.name_last_node('to')
            with self._optional():
                self._token(':')
                self._n__()
                self._expr_1c_()
                self.name_last_node('step')
        self.ast._define(
            ['from_', 'step', 'to'],
            []
        )

    @tatsumasu()
    def _expr_11_(self):  # noqa
        with self._choice():
            with self._option():
                self._t_oparen_()
                self._cut()
                self._expression_()
                self.name_last_node('@')
                self._t_cparen_()
            with self._option():
                self._value_()
            self._error('no available options')

    @tatsumasu()
    @leftrec
    def _expr_10_(self):  # noqa
        with self._choice():
            with self._option():
                self._expr_type_()
            with self._option():
                self._expr_call_()
            with self._option():
                self._expr_array_index_()
            with self._option():
                self._expr_member_access_()
            with self._option():
                self._expr_autocast_()
            with self._option():
                self._expr_postinc_()
            with self._option():
                self._expr_postdec_()
            with self._option():
                self._expr_11_()
            self._error('no available options')

    @tatsumasu()
    @nomemo
    def _expr_9_(self):  # noqa
        with self._choice():
            with self._option():
                self._expr_preinc_()
            with self._option():
                self._expr_predec_()
            with self._option():
                self._expr_uminus_()
            with self._option():
                self._expr_deref_()
            with self._option():
                self._expr_ptr_()
            with self._option():
                self._expr_invert_()
            with self._option():
                self._expr_not_()
            with self._option():
                self._expr_10_()
            self._error('no available options')

    @tatsumasu()
    @nomemo
    def _expr_8_(self):  # noqa
        with self._choice():
            with self._option():
                self._expr_cast_()
            with self._option():
                self._expr_9_()
            self._error('no available options')

    @tatsumasu()
    @leftrec
    def _expr_7_(self):  # noqa
        with self._choice():
            with self._option():
                self._expr_shr_()
            with self._option():
                self._expr_shl_()
            with self._option():
                self._expr_band_()
            with self._option():
                self._expr_bor_()
            with self._option():
                self._expr_xor_()
            with self._option():
                self._expr_8_()
            self._error('no available options')

    @tatsumasu()
    @leftrec
    def _expr_6_(self):  # noqa
        with self._choice():
            with self._option():
                self._expr_mul_()
            with self._option():
                self._expr_div_()
            with self._option():
                self._expr_mod_()
            with self._option():
                self._expr_7_()
            self._error('no available options')

    @tatsumasu()
    @leftrec
    def _expr_5_(self):  # noqa
        with self._choice():
            with self._option():
                self._expr_padd_()
            with self._option():
                self._expr_psub_()
            with self._option():
                self._expr_add_()
            with self._option():
                self._expr_sub_()
            with self._option():
                self._expr_6_()
            self._error('no available options')

    @tatsumasu()
    @nomemo
    def _expr_4_(self):  # noqa
        with self._choice():
            with self._option():
                self._expr_cmp_start_()
            with self._option():
                self._expr_5_()
            self._error('no available options')

    @tatsumasu()
    @leftrec
    def _expr_3_(self):  # noqa
        with self._choice():
            with self._option():
                self._expr_and_()
            with self._option():
                self._expr_4_()
            self._error('no available options')

    @tatsumasu()
    @leftrec
    def _expr_2_(self):  # noqa
        with self._choice():
            with self._option():
                self._expr_or_()
            with self._option():
                self._expr_3_()
            self._error('no available options')

    @tatsumasu()
    @nomemo
    def _expr_1_(self):  # noqa
        with self._choice():
            with self._option():
                self._expr_do_()
            with self._option():
                self._expr_size_of_()
            with self._option():
                self._expr_assign_op_()
            with self._option():
                self._expr_assign_()
            with self._option():
                self._expr_if_()
            with self._option():
                self._expr_2_()
            self._error('no available options')

    @tatsumasu()
    @nomemo
    def _expr_0_(self):  # noqa
        with self._choice():
            with self._option():
                self._expr_range_()
            with self._option():
                self._expr_1_()
            self._error('no available options')

    @tatsumasu()
    @nomemo
    def _expression_(self):  # noqa
        self._expr_0_()

    @tatsumasu()
    def _expr_1c_(self):  # noqa
        with self._choice():
            with self._option():
                self._expr_do_()
            with self._option():
                self._expr_size_of_()
            with self._option():
                self._expr_if_()
            with self._option():
                self._expr_2_()
            self._error('no available options')

    @tatsumasu()
    def _expression_no_assign_(self):  # noqa
        with self._choice():
            with self._option():
                self._expr_rangec_()
            with self._option():
                self._expr_1c_()
            self._error('no available options')

    @tatsumasu()
    def _expression_call_(self):  # noqa
        with self._choice():
            with self._option():
                self._struct_lit_typed_()
            with self._option():
                self._expression_no_assign_()
            self._error('no available options')

    @tatsumasu('Share')
    def _import_marker_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('export')
                self._constant(2)
                self.name_last_node('@')
            with self._option():
                self._constant(0)
            self._error('no available options')

    @tatsumasu('ImportModule')
    def _stmt_import_module_(self):  # noqa
        self._n__()
        self._identifier_()
        self.name_last_node('name')
        with self._optional():
            self._token('as')
            self._n__()
            self._identifier_()
            self.name_last_node('alias')
        self.ast._define(
            ['alias', 'name'],
            []
        )

    @tatsumasu('Import')
    def _stmt_import_(self):  # noqa
        with self._optional():
            self._import_marker_()
            self.name_last_node('share')
            self._n__()
        self._token('import')

        def sep2():
            self._token(',')

        def block2():
            self._stmt_import_module_()
        self._positive_gather(block2, sep2)
        self.name_last_node('modules')
        self.ast._define(
            ['modules', 'share'],
            []
        )

    @tatsumasu('IdDecl')
    def _var_iddecl_(self):  # noqa
        self._n__()
        self._identifier_()
        self.name_last_node('name')
        with self._optional():
            self._token(':')
            self._n__()
            self._type_()
            self.name_last_node('type')
        self.ast._define(
            ['name', 'type'],
            []
        )

    @tatsumasu('IdAssign')
    def _var_idassign_(self):  # noqa
        self._n__()
        self._t_oparen_()
        self._n__()
        self._expression_()
        self.name_last_node('@')
        self._n__()
        self._t_cparen_()

    @tatsumasu()
    def _stmt_vardecl_rhs_(self):  # noqa
        self._n__()
        with self._group():
            with self._choice():
                with self._option():
                    self._struct_lit_typed_()
                with self._option():
                    self._expression_()
                self._error('no available options')
        self.name_last_node('@')

    @tatsumasu('VarDecl')
    def _stmt_vardecl_(self):  # noqa
        with self._optional():
            self._share_marker_()
            self.name_last_node('share')
            self._n__()
        with self._group():
            with self._choice():
                with self._option():
                    self._token('var')
                with self._option():
                    self._token('let')
                with self._option():
                    self._token('const')
                self._error('no available options')
        self.name_last_node('keyword')
        self._n__()
        self._cut()

        def sep4():
            self._token(',')

        def block4():
            with self._choice():
                with self._option():
                    self._var_idassign_()
                with self._option():
                    self._var_iddecl_()
                self._error('no available options')
        self._positive_gather(block4, sep4)
        self.name_last_node('left')
        with self._optional():
            self._token('=')
            self._n__()

            def sep7():
                self._token(',')

            def block7():
                self._stmt_vardecl_rhs_()
            self._positive_gather(block7, sep7)
            self.name_last_node('right')
        self.ast._define(
            ['keyword', 'left', 'right', 'share'],
            []
        )

    @tatsumasu()
    def _stmt_typedecl_lhs_(self):  # noqa
        self._n__()
        self._identifier_()
        self.name_last_node('@')

    @tatsumasu()
    def _stmt_typedecl_rhs_(self):  # noqa
        self._n__()
        self._type_()
        self.name_last_node('@')

    @tatsumasu('TypeDecl')
    def _stmt_typedecl_(self):  # noqa
        with self._optional():
            self._share_marker_()
            self.name_last_node('share')
            self._n__()
        self._token('type')
        self._n__()

        def sep2():
            self._token(',')

        def block2():
            self._stmt_typedecl_lhs_()
        self._positive_gather(block2, sep2)
        self.name_last_node('name')
        self._n__()
        self._token('=')
        self._n__()

        def sep4():
            self._token(',')

        def block4():
            self._stmt_typedecl_rhs_()
        self._positive_gather(block4, sep4)
        self.name_last_node('value')
        self.ast._define(
            ['name', 'share', 'value'],
            []
        )

    @tatsumasu('Else')
    def _stmt_else_(self):  # noqa
        self._token('else')
        self._n__()
        self._cut()
        self._code_body_()
        self.name_last_node('body')
        self.ast._define(
            ['body'],
            []
        )

    @tatsumasu('ElseIf')
    def _stmt_else_if_(self):  # noqa
        self._token('else')
        self._n__()
        self._token('if')
        self._n__()
        self._cut()
        self._expression_()
        self.name_last_node('cond')
        self._n__()
        self._code_body_()
        self.name_last_node('body')
        self.ast._define(
            ['body', 'cond'],
            []
        )

    @tatsumasu('If')
    def _stmt_if_(self):  # noqa
        self._token('if')
        self._n__()
        self._cut()
        self._expression_()
        self.name_last_node('cond')
        self._n__()
        self._code_body_()
        self.name_last_node('body')

        def block3():
            self._stmt_else_if_()
        self._closure(block3)
        self.name_last_node('else_if')
        with self._optional():
            self._n__()
            self._stmt_else_()
            self.name_last_node('else_')
        self.ast._define(
            ['body', 'cond', 'else_', 'else_if'],
            []
        )

    @tatsumasu('Switch')
    def _stmt_switch_(self):  # noqa
        self._token('switch')
        self._n__()
        self._expression_()
        self.name_last_node('value')
        self._n__()
        self._code_body_()
        self.name_last_node('body')
        self.ast._define(
            ['body', 'value'],
            []
        )

    @tatsumasu('StaticIf')
    def _stmt_static_if_(self):  # noqa
        self._token('#')
        with self._ifnot():
            self._token(' ')
        self._token('if')
        self._n__()
        self._cut()
        self._expression_()
        self.name_last_node('cond')
        self._n__()
        self._code_body_()
        self.name_last_node('body')

        def block3():
            self._stmt_else_if_()
        self._closure(block3)
        self.name_last_node('else_if')
        with self._optional():
            self._n__()
            self._stmt_else_()
            self.name_last_node('else_')
        self.ast._define(
            ['body', 'cond', 'else_', 'else_if'],
            []
        )

    @tatsumasu('While')
    def _stmt_while_loop_(self):  # noqa
        self._token('while')
        self._n__()
        self._cut()
        self._expression_()
        self.name_last_node('cond')
        self._n__()
        self._code_body_()
        self.name_last_node('body')
        self.ast._define(
            ['body', 'cond'],
            []
        )

    @tatsumasu('While')
    def _stmt_loop_(self):  # noqa
        self._token('loop')
        self._n__()
        self._cut()
        self._code_body_()
        self.name_last_node('body')
        self.ast._define(
            ['body'],
            []
        )

    @tatsumasu('Continue')
    def _stmt_continue_(self):  # noqa
        self._token('continue')
        self._void()
        self.name_last_node('@')

    @tatsumasu('Break')
    def _stmt_break_(self):  # noqa
        self._token('break')
        self._void()
        self.name_last_node('@')

    @tatsumasu()
    def _ret_arg_(self):  # noqa
        self._n__()
        self._expression_no_assign_()
        self.name_last_node('@')

    @tatsumasu('Return')
    def _stmt_return_(self):  # noqa
        self._token('return')

        def sep1():
            self._token(',')

        def block1():
            self._ret_arg_()
        self._gather(block1, sep1)
        self.name_last_node('@')

    @tatsumasu('IdAssign')
    def _expr_in_assign_(self):  # noqa
        self._n__()
        self._identifier_()
        self.name_last_node('@')

    @tatsumasu('In')
    def _expr_in_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token('var')
                            with self._option():
                                self._token('let')
                            self._error('no available options')
                    self.name_last_node('keyword')

                    def sep3():
                        self._token(',')

                    def block3():
                        with self._choice():
                            with self._option():
                                self._var_idassign_()
                            with self._option():
                                self._var_iddecl_()
                            self._error('no available options')
                    self._positive_gather(block3, sep3)
                    self.name_last_node('left')
                with self._option():

                    def sep6():
                        self._token(',')

                    def block6():
                        self._expr_in_assign_()
                    self._positive_gather(block6, sep6)
                    self.name_last_node('left')
                self._error('no available options')
        self._token('in')
        self._n__()

        def sep9():
            self._token(',')

        def block9():
            self._stmt_vardecl_rhs_()
        self._positive_gather(block9, sep9)
        self.name_last_node('right')
        self.ast._define(
            ['keyword', 'left', 'right'],
            []
        )

    @tatsumasu('For')
    def _stmt_for_loop_(self):  # noqa
        self._token('for')
        self._n__()
        self._expr_in_()
        self.name_last_node('iterator')
        self._n__()
        self._code_body_()
        self.name_last_node('body')
        self.ast._define(
            ['body', 'iterator'],
            []
        )

    @tatsumasu()
    def _pragma_ident_(self):  # noqa
        self._pattern('[#]{1,2}(?!\\d)\\w+')

    @tatsumasu('Pragma')
    def _stmt_pragma_(self):  # noqa
        self._pragma_ident_()
        self.name_last_node('name')
        with self._optional():
            self._call_args_()
            self.name_last_node('args')
        self.ast._define(
            ['args', 'name'],
            []
        )

    @tatsumasu()
    def _stmt_case_rhs_(self):  # noqa
        self._n__()
        self._value_()
        self.name_last_node('@')

    @tatsumasu('Case')
    def _stmt_case_(self):  # noqa
        self._token('case')
        self._n__()
        self._cut()
        with self._optional():

            def sep1():
                self._token(',')

            def block1():
                self._stmt_case_rhs_()
            self._positive_gather(block1, sep1)
            self.name_last_node('value')
            self._n__()
        self._token(':')
        self._n__()
        with self._group():
            with self._choice():
                with self._option():
                    self._statement_noterm_()
                with self._option():
                    self._expression_()
                self._error('no available options')
        self.name_last_node('statement')
        self.ast._define(
            ['statement', 'value'],
            []
        )

    @tatsumasu('Label')
    def _stmt_label_(self):  # noqa
        self._token('label')
        self._n__()
        self._cut()
        self._identifier_()
        self.name_last_node('name')
        self._n__()
        self._token(':')
        self._n__()
        with self._group():
            with self._choice():
                with self._option():
                    self._statement_noterm_()
                with self._option():
                    self._expression_()
                self._error('no available options')
        self.name_last_node('statement')
        self.ast._define(
            ['name', 'statement'],
            []
        )

    @tatsumasu('Goto')
    def _stmt_goto_(self):  # noqa
        self._token('go_to')
        self._n__()
        self._cut()
        self._identifier_()
        self.name_last_node('@')

    @tatsumasu()
    def _return_type_(self):  # noqa
        self._n__()
        self._type_()
        self.name_last_node('@')

    @tatsumasu('DefArg')
    def _def_arg_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._token('let')
                with self._option():
                    self._token('var')
                with self._option():
                    self._token('type')
                with self._option():
                    self._constant('var')
                self._error('no available options')
        self.name_last_node('keyword')
        self._identifier_()
        self.name_last_node('name')
        with self._optional():
            self._token(':')
            self._type_()
            self.name_last_node('type')
        with self._optional():
            self._token('=')
            self._expression_call_()
            self.name_last_node('value')
        self.ast._define(
            ['keyword', 'name', 'type', 'value'],
            []
        )

    @tatsumasu()
    def _def_body_(self):  # noqa
        with self._choice():
            with self._option():
                self._code_body_()
                self.name_last_node('@')
            with self._option():
                self._token('=')
                self._n__()
                self._expression_()
                self.name_last_node('@')
            self._error('no available options')

    @tatsumasu('Share')
    def _share_marker_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('export')
                self._n__()
                self._token('import')
                self._constant(3)
                self.name_last_node('@')
            with self._option():
                self._token('export')
                self._constant(2)
                self.name_last_node('@')
            with self._option():
                self._token('import')
                self._constant(1)
                self.name_last_node('@')
            with self._option():
                self._constant(0)
                self.name_last_node('@')
            self._error('no available options')

    @tatsumasu('Def')
    def _stmt_def_(self):  # noqa
        with self._optional():
            self._share_marker_()
            self.name_last_node('share')
            self._n__()
        self._token('def')
        self._n__()
        self._cut()
        self._identifier_()
        self.name_last_node('name')
        with self._optional():
            self._t_oparen_()
            self._cut()

            def sep3():
                self._token(',')

            def block3():
                self._def_arg_()
            self._gather(block3, sep3)
            self.name_last_node('args')
            self._t_cparen_()
        with self._optional():
            self._token('->')

            def sep5():
                self._token(',')

            def block5():
                self._return_type_()
            self._gather(block5, sep5)
            self.name_last_node('returns')
        with self._optional():
            self._def_body_()
            self.name_last_node('body')
        self.ast._define(
            ['args', 'body', 'name', 'returns', 'share'],
            []
        )

    @tatsumasu()
    def _stmt_(self):  # noqa
        with self._choice():
            with self._option():
                self._stmt_vardecl_()
            with self._option():
                self._stmt_typedecl_()
            with self._option():
                self._stmt_if_()
            with self._option():
                self._stmt_def_()
            with self._option():
                self._stmt_import_()
            with self._option():
                self._stmt_static_if_()
            with self._option():
                self._stmt_pragma_()
            with self._option():
                self._stmt_for_loop_()
            with self._option():
                self._stmt_while_loop_()
            with self._option():
                self._stmt_loop_()
            with self._option():
                self._stmt_switch_()
            with self._option():
                self._stmt_return_()
            with self._option():
                self._stmt_continue_()
            with self._option():
                self._stmt_break_()
            with self._option():
                self._stmt_goto_()
            self._error('no available options')

    @tatsumasu()
    @nomemo
    def _statement_(self):  # noqa
        with self._choice():
            with self._option():
                self._void()
                self.name_last_node('@')
                self._t_term_()
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._stmt_label_()
                        with self._option():
                            self._stmt_case_()
                        self._error('no available options')
                self.name_last_node('@')
                self._t_term_()
            with self._option():
                self._statement_noterm_()
                self.name_last_node('@')
                self._t_term_()
            with self._option():
                self._expression_()
                self.name_last_node('@')
                self._t_term_()
            self._error('no available options')

    @tatsumasu()
    def _statement_noterm_(self):  # noqa
        with self._choice():
            with self._option():
                self._t_oparen_()
                with self._group():
                    with self._choice():
                        with self._option():
                            self._void()
                            self.name_last_node('@')
                            with self._if():
                                self._token(')')
                        with self._option():
                            self._statement_noterm_()
                            self.name_last_node('@')
                        self._error('no available options')
                self._t_cparen_()
            with self._option():
                self._stmt_()
                self.name_last_node('@')
            self._error('no available options')


class PrincessSemantics(object):
    def code_body(self, ast):  # noqa
        return ast

    def program(self, ast):  # noqa
        return ast

    def t_newline(self, ast):  # noqa
        return ast

    def t_term(self, ast):  # noqa
        return ast

    def n_(self, ast):  # noqa
        return ast

    def t_oparen(self, ast):  # noqa
        return ast

    def t_cparen(self, ast):  # noqa
        return ast

    def digit(self, ast):  # noqa
        return ast

    def hex_digit(self, ast):  # noqa
        return ast

    def oct_digit(self, ast):  # noqa
        return ast

    def bin_digit(self, ast):  # noqa
        return ast

    def sign(self, ast):  # noqa
        return ast

    def exp(self, ast):  # noqa
        return ast

    def t_float_literal(self, ast):  # noqa
        return ast

    def t_dec_literal(self, ast):  # noqa
        return ast

    def t_hex_literal(self, ast):  # noqa
        return ast

    def t_oct_literal(self, ast):  # noqa
        return ast

    def t_bin_literal(self, ast):  # noqa
        return ast

    def t_int_literal(self, ast):  # noqa
        return ast

    def t_num_lit(self, ast):  # noqa
        return ast

    def ESC_CHAR(self, ast):  # noqa
        return ast

    def ESC_SEQ(self, ast):  # noqa
        return ast

    def T_CHAR(self, ast):  # noqa
        return ast

    def T_CHAR_S(self, ast):  # noqa
        return ast

    def T_CHAR_LIT(self, ast):  # noqa
        return ast

    def T_STRING_LIT(self, ast):  # noqa
        return ast

    def t_ident(self, ast):  # noqa
        return ast

    def identifier(self, ast):  # noqa
        return ast

    def t_bool(self, ast):  # noqa
        return ast

    def t_bool_lit(self, ast):  # noqa
        return ast

    def t_null(self, ast):  # noqa
        return ast

    def array_element(self, ast):  # noqa
        return ast

    def array_lit(self, ast):  # noqa
        return ast

    def literal(self, ast):  # noqa
        return ast

    def value(self, ast):  # noqa
        return ast

    def struct_arg_named(self, ast):  # noqa
        return ast

    def struct_arg(self, ast):  # noqa
        return ast

    def struct_lit(self, ast):  # noqa
        return ast

    def struct_lit_typed(self, ast):  # noqa
        return ast

    def type_structural(self, ast):  # noqa
        return ast

    def stmt_struct_else(self, ast):  # noqa
        return ast

    def stmt_struct_else_if(self, ast):  # noqa
        return ast

    def stmt_struct_if(self, ast):  # noqa
        return ast

    def struct_iddecl(self, ast):  # noqa
        return ast

    def struct_def(self, ast):  # noqa
        return ast

    def struct_def_noterm(self, ast):  # noqa
        return ast

    def struct_body(self, ast):  # noqa
        return ast

    def struct_pragmas(self, ast):  # noqa
        return ast

    def type_struct(self, ast):  # noqa
        return ast

    def stmt_enum_else(self, ast):  # noqa
        return ast

    def stmt_enum_else_if(self, ast):  # noqa
        return ast

    def stmt_enum_if(self, ast):  # noqa
        return ast

    def enum_iddecl(self, ast):  # noqa
        return ast

    def enum_def(self, ast):  # noqa
        return ast

    def enum_def_noterm(self, ast):  # noqa
        return ast

    def enum_body(self, ast):  # noqa
        return ast

    def type_enum(self, ast):  # noqa
        return ast

    def type_ptr(self, ast):  # noqa
        return ast

    def type_ref(self, ast):  # noqa
        return ast

    def type_array_dyn(self, ast):  # noqa
        return ast

    def type_array_static(self, ast):  # noqa
        return ast

    def type_array(self, ast):  # noqa
        return ast

    def type_list_elem(self, ast):  # noqa
        return ast

    def type_list(self, ast):  # noqa
        return ast

    def type_function(self, ast):  # noqa
        return ast

    def type_unsigned(self, ast):  # noqa
        return ast

    def type_word(self, ast):  # noqa
        return ast

    def type_3(self, ast):  # noqa
        return ast

    def type_2(self, ast):  # noqa
        return ast

    def type_1(self, ast):  # noqa
        return ast

    def type(self, ast):  # noqa
        return ast

    def call_arg_named(self, ast):  # noqa
        return ast

    def call_arg(self, ast):  # noqa
        return ast

    def call_args(self, ast):  # noqa
        return ast

    def expr_call(self, ast):  # noqa
        return ast

    def expr_type_call(self, ast):  # noqa
        return ast

    def expr_array_index(self, ast):  # noqa
        return ast

    def expr_member_access(self, ast):  # noqa
        return ast

    def expr_type(self, ast):  # noqa
        return ast

    def post_lh(self, ast):  # noqa
        return ast

    def expr_postinc(self, ast):  # noqa
        return ast

    def expr_postdec(self, ast):  # noqa
        return ast

    def expr_cast(self, ast):  # noqa
        return ast

    def expr_autocast(self, ast):  # noqa
        return ast

    def expr_preinc(self, ast):  # noqa
        return ast

    def expr_predec(self, ast):  # noqa
        return ast

    def expr_uminus(self, ast):  # noqa
        return ast

    def expr_deref(self, ast):  # noqa
        return ast

    def expr_ptr(self, ast):  # noqa
        return ast

    def expr_invert(self, ast):  # noqa
        return ast

    def expr_not(self, ast):  # noqa
        return ast

    def expr_shr(self, ast):  # noqa
        return ast

    def expr_shl(self, ast):  # noqa
        return ast

    def expr_band(self, ast):  # noqa
        return ast

    def expr_bor(self, ast):  # noqa
        return ast

    def expr_xor(self, ast):  # noqa
        return ast

    def expr_mul(self, ast):  # noqa
        return ast

    def expr_div(self, ast):  # noqa
        return ast

    def expr_mod(self, ast):  # noqa
        return ast

    def expr_padd(self, ast):  # noqa
        return ast

    def expr_psub(self, ast):  # noqa
        return ast

    def expr_add(self, ast):  # noqa
        return ast

    def expr_sub(self, ast):  # noqa
        return ast

    def cmp_op(self, ast):  # noqa
        return ast

    def expr_cmp(self, ast):  # noqa
        return ast

    def expr_cmp_start(self, ast):  # noqa
        return ast

    def expr_and(self, ast):  # noqa
        return ast

    def expr_or(self, ast):  # noqa
        return ast

    def assign_op(self, ast):  # noqa
        return ast

    def expr_assign_op(self, ast):  # noqa
        return ast

    def expr_assign_lhs(self, ast):  # noqa
        return ast

    def expr_assign_rhs(self, ast):  # noqa
        return ast

    def expr_assign(self, ast):  # noqa
        return ast

    def expr_if(self, ast):  # noqa
        return ast

    def expr_do(self, ast):  # noqa
        return ast

    def expr_size_of(self, ast):  # noqa
        return ast

    def expr_range(self, ast):  # noqa
        return ast

    def expr_rangec(self, ast):  # noqa
        return ast

    def expr_11(self, ast):  # noqa
        return ast

    def expr_10(self, ast):  # noqa
        return ast

    def expr_9(self, ast):  # noqa
        return ast

    def expr_8(self, ast):  # noqa
        return ast

    def expr_7(self, ast):  # noqa
        return ast

    def expr_6(self, ast):  # noqa
        return ast

    def expr_5(self, ast):  # noqa
        return ast

    def expr_4(self, ast):  # noqa
        return ast

    def expr_3(self, ast):  # noqa
        return ast

    def expr_2(self, ast):  # noqa
        return ast

    def expr_1(self, ast):  # noqa
        return ast

    def expr_0(self, ast):  # noqa
        return ast

    def expression(self, ast):  # noqa
        return ast

    def expr_1c(self, ast):  # noqa
        return ast

    def expression_no_assign(self, ast):  # noqa
        return ast

    def expression_call(self, ast):  # noqa
        return ast

    def import_marker(self, ast):  # noqa
        return ast

    def stmt_import_module(self, ast):  # noqa
        return ast

    def stmt_import(self, ast):  # noqa
        return ast

    def var_iddecl(self, ast):  # noqa
        return ast

    def var_idassign(self, ast):  # noqa
        return ast

    def stmt_vardecl_rhs(self, ast):  # noqa
        return ast

    def stmt_vardecl(self, ast):  # noqa
        return ast

    def stmt_typedecl_lhs(self, ast):  # noqa
        return ast

    def stmt_typedecl_rhs(self, ast):  # noqa
        return ast

    def stmt_typedecl(self, ast):  # noqa
        return ast

    def stmt_else(self, ast):  # noqa
        return ast

    def stmt_else_if(self, ast):  # noqa
        return ast

    def stmt_if(self, ast):  # noqa
        return ast

    def stmt_switch(self, ast):  # noqa
        return ast

    def stmt_static_if(self, ast):  # noqa
        return ast

    def stmt_while_loop(self, ast):  # noqa
        return ast

    def stmt_loop(self, ast):  # noqa
        return ast

    def stmt_continue(self, ast):  # noqa
        return ast

    def stmt_break(self, ast):  # noqa
        return ast

    def ret_arg(self, ast):  # noqa
        return ast

    def stmt_return(self, ast):  # noqa
        return ast

    def expr_in_assign(self, ast):  # noqa
        return ast

    def expr_in(self, ast):  # noqa
        return ast

    def stmt_for_loop(self, ast):  # noqa
        return ast

    def pragma_ident(self, ast):  # noqa
        return ast

    def stmt_pragma(self, ast):  # noqa
        return ast

    def stmt_case_rhs(self, ast):  # noqa
        return ast

    def stmt_case(self, ast):  # noqa
        return ast

    def stmt_label(self, ast):  # noqa
        return ast

    def stmt_goto(self, ast):  # noqa
        return ast

    def return_type(self, ast):  # noqa
        return ast

    def def_arg(self, ast):  # noqa
        return ast

    def def_body(self, ast):  # noqa
        return ast

    def share_marker(self, ast):  # noqa
        return ast

    def stmt_def(self, ast):  # noqa
        return ast

    def stmt(self, ast):  # noqa
        return ast

    def statement(self, ast):  # noqa
        return ast

    def statement_noterm(self, ast):  # noqa
        return ast


def main(filename, start=None, **kwargs):
    if start is None:
        start = 'code_body'
    if not filename or filename == '-':
        text = sys.stdin.read()
    else:
        with open(filename) as f:
            text = f.read()
    parser = PrincessParser()
    return parser.parse(text, rule_name=start, filename=filename, **kwargs)


if __name__ == '__main__':
    import json
    from tatsu.util import asjson

    ast = generic_main(main, PrincessParser, name='Princess')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(asjson(ast), indent=2))
    print()
