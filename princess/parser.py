#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals

import sys

from tatsu.buffering import Buffer
from tatsu.parsing import Parser
from tatsu.parsing import tatsumasu
from tatsu.util import re, generic_main  # noqa


KEYWORDS = {}  # type: ignore


class PrincessBuffer(Buffer):
    def __init__(
        self,
        text,
        whitespace=re.compile('(?!)'),
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        namechars='',
        **kwargs
    ):
        super(PrincessBuffer, self).__init__(
            text,
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            namechars=namechars,
            **kwargs
        )


class PrincessParser(Parser):
    def __init__(
        self,
        whitespace=re.compile('(?!)'),
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        left_recursion=True,
        parseinfo=True,
        keywords=None,
        namechars='',
        buffer_class=PrincessBuffer,
        **kwargs
    ):
        if keywords is None:
            keywords = KEYWORDS
        super(PrincessParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            parseinfo=parseinfo,
            keywords=keywords,
            namechars=namechars,
            buffer_class=buffer_class,
            **kwargs
        )

    @tatsumasu('Program')
    def _program_(self):  # noqa

        def block1():
            self._statement_()
        self._closure(block1)
        self.name_last_node('LIST')
        self.ast._define(
            ['LIST'],
            []
        )

    @tatsumasu()
    def _t_newline_(self):  # noqa
        with self._choice():
            with self._option():
                self._pattern(r'[\n]+')
            with self._option():
                self._t_eol_comment_()
            self._error('no available options')

    @tatsumasu()
    def _t_ws_(self):  # noqa
        self._pattern(r'[\t ]+')

    @tatsumasu()
    def ___(self):  # noqa

        def block0():
            with self._choice():
                with self._option():
                    self._t_ws_()
                with self._option():
                    self._t_comment_()
                self._error('no available options')
        self._closure(block0)

    @tatsumasu()
    def __n_(self):  # noqa

        def block0():
            with self._choice():
                with self._option():
                    self._t_newline_()
                with self._option():
                    self.___()
                self._error('no available options')
        self._closure(block0)

    @tatsumasu()
    def _k_if_(self):  # noqa
        self._token('if')

    @tatsumasu()
    def _k_else_(self):  # noqa
        self._token('else')

    @tatsumasu()
    def _t_keyword_(self):  # noqa
        with self._choice():
            with self._option():
                self._k_if_()
            with self._option():
                self._k_else_()
            self._error('no available options')

    @tatsumasu()
    def _t_term_(self):  # noqa
        with self._choice():
            with self._option():
                self._token(';')
            with self._option():
                self._check_eof()
            with self._option():
                self._t_newline_()
            self._error('no available options')

    @tatsumasu()
    def _digit_(self):  # noqa
        self._pattern(r'[0-9]')

    @tatsumasu()
    def _hex_digit_(self):  # noqa
        self._pattern(r'[a-fA-F0-9]')

    @tatsumasu()
    def _oct_digit_(self):  # noqa
        self._pattern(r'[0-8]')

    @tatsumasu()
    def _bin_digit_(self):  # noqa
        self._pattern(r'[01]')

    @tatsumasu()
    def _sign_(self):  # noqa
        with self._choice():
            with self._option():
                self._pattern(r'[+-]')
            with self._option():
                self._constant('+')
            self._error('no available options')

    @tatsumasu()
    def _exp_(self):  # noqa
        self._pattern(r'[Ee]')
        self._sign_()
        self.name_last_node('sign')
        self._cut()

        def block2():
            self._digit_()
        self._positive_closure(block2)
        self.name_last_node('num')
        self.ast._define(
            ['num', 'sign'],
            []
        )

    @tatsumasu()
    def _float_frac_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():

                    def block1():
                        self._digit_()
                    self._positive_closure(block1)
                with self._option():
                    self._constant('0')
                self._error('no available options')
        self.name_last_node('frac')
        with self._optional():
            self._exp_()
        self.name_last_node('exp')
        self.ast._define(
            ['exp', 'frac'],
            []
        )

    @tatsumasu('Float')
    def _t_float_literal_(self):  # noqa
        with self._choice():
            with self._option():
                with self._group():

                    def block1():
                        self._digit_()
                    self._positive_closure(block1)
                    self.name_last_node('num')
                    with self._group():
                        with self._choice():
                            with self._option():
                                with self._group():
                                    self._token('.')
                                    self._cut()
                                    with self._group():
                                        with self._choice():
                                            with self._option():

                                                def block3():
                                                    self._digit_()
                                                self._positive_closure(block3)
                                            with self._option():
                                                self._constant('0')
                                            self._error('no available options')
                                    self.name_last_node('frac')
                                    with self._optional():
                                        self._exp_()
                                    self.name_last_node('exp')
                            with self._option():
                                self._constant('0')
                                self.name_last_node('frac')
                                self._exp_()
                                self.name_last_node('exp')
                            self._error('no available options')
            with self._option():
                with self._group():
                    self._constant('0')
                    self.name_last_node('num')
                    self._token('.')
                    self._cut()
                    with self._group():
                        with self._choice():
                            with self._option():

                                def block11():
                                    self._digit_()
                                self._positive_closure(block11)
                            with self._option():
                                self._constant('0')
                            self._error('no available options')
                    self.name_last_node('frac')
                    with self._optional():
                        self._exp_()
                    self.name_last_node('exp')
            self._error('no available options')
        self.ast._define(
            ['exp', 'frac', 'num'],
            []
        )

    @tatsumasu('Integer')
    def _t_dec_literal_(self):  # noqa
        self._constant(10)
        self.name_last_node('base')

        def block2():
            self._digit_()
        self._positive_closure(block2)
        self.name_last_node('num')
        self.ast._define(
            ['base', 'num'],
            []
        )

    @tatsumasu('Integer')
    def _t_hex_literal_(self):  # noqa
        self._token('0x')
        self._cut()
        self._constant(16)
        self.name_last_node('base')

        def block2():
            self._hex_digit_()
        self._positive_closure(block2)
        self.name_last_node('num')
        self.ast._define(
            ['base', 'num'],
            []
        )

    @tatsumasu('Integer')
    def _t_oct_literal_(self):  # noqa
        self._token('0o')
        self._cut()
        self._constant(8)
        self.name_last_node('base')

        def block2():
            self._oct_digit_()
        self._positive_closure(block2)
        self.name_last_node('num')
        self.ast._define(
            ['base', 'num'],
            []
        )

    @tatsumasu('Integer')
    def _t_bin_literal_(self):  # noqa
        self._token('0b')
        self._cut()
        self._constant(2)
        self.name_last_node('base')

        def block2():
            self._bin_digit_()
        self._positive_closure(block2)
        self.name_last_node('num')
        self.ast._define(
            ['base', 'num'],
            []
        )

    @tatsumasu()
    def _t_num_lit_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._t_hex_literal_()
                with self._option():
                    self._t_bin_literal_()
                with self._option():
                    self._t_oct_literal_()
                with self._option():
                    self._t_float_literal_()
                with self._option():
                    self._t_dec_literal_()
                self._error('no available options')

    @tatsumasu()
    def _esc_seq_(self):  # noqa
        self._token('\\')
        self._cut()
        with self._group():
            with self._choice():
                with self._option():
                    self._pattern(r'[abfnrtv\\\'"0]')
                with self._option():
                    with self._group():
                        self._pattern(r'x')
                        self._cut()
                        self._hex_digit_()
                        self._hex_digit_()
                with self._option():
                    with self._group():
                        self._pattern(r'u')
                        self._cut()
                        self._hex_digit_()
                        self._hex_digit_()
                        self._hex_digit_()
                        self._hex_digit_()
                with self._option():
                    with self._group():
                        self._pattern(r'U')
                        self._cut()
                        self._hex_digit_()
                        self._hex_digit_()
                        self._hex_digit_()
                        self._hex_digit_()
                        self._hex_digit_()
                        self._hex_digit_()
                        self._hex_digit_()
                        self._hex_digit_()
                self._error('no available options')

    @tatsumasu()
    def _t_char_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._esc_seq_()
                with self._option():
                    self._pattern(r'[^\0\x7f\x80"\\]+')
                self._error('no available options')

    @tatsumasu('Char')
    def _t_char_lit_(self):  # noqa
        self._token("'")
        self._t_char_()
        self.name_last_node('VALUE')
        self._cut()
        self._token("'")
        self.ast._define(
            ['VALUE'],
            []
        )

    @tatsumasu('String')
    def _t_string_lit_(self):  # noqa
        self._token('"')

        def block1():
            self._t_char_()
        self._closure(block1)
        self.name_last_node('VALUE')
        self._cut()
        self._token('"')
        self.ast._define(
            ['VALUE'],
            []
        )

    @tatsumasu('Identifier')
    def _t_ident_(self):  # noqa
        with self._ifnot():
            self._t_keyword_()
        self._pattern(r'(?!\d)\w+')
        self.name_last_node('VALUE')
        self.ast._define(
            ['VALUE'],
            []
        )

    @tatsumasu()
    def _literal_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._t_num_lit_()
                with self._option():
                    self._t_char_lit_()
                with self._option():
                    self._t_string_lit_()
                self._error('no available options')

    @tatsumasu()
    def _value_(self):  # noqa
        with self._choice():
            with self._option():
                self._t_ident_()
            with self._option():
                self._literal_()
            self._error('no available options')

    @tatsumasu()
    def _t_comment_start_(self):  # noqa
        self._token('/*')

    @tatsumasu()
    def _t_comment_end_(self):  # noqa
        self._token('*/')

    @tatsumasu()
    def _t_comment_(self):  # noqa
        self._t_comment_start_()

        def block0():
            with self._choice():
                with self._option():
                    with self._group():
                        with self._ifnot():
                            self._t_comment_end_()
                        with self._ifnot():
                            self._t_comment_start_()
                        self._pattern(r'.|\n')
                with self._option():
                    self._t_comment_()
                self._error('no available options')
        self._closure(block0)
        self._cut()
        self._t_comment_end_()

    @tatsumasu()
    def _t_eol_comment_(self):  # noqa
        self._token('//')
        self._pattern(r'[^\n]+')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('\n')
                with self._option():
                    self._check_eof()
                self._error('no available options')

    @tatsumasu('UnaryPreOp')
    def _expr_pre_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._token('++')
                with self._option():
                    self._token('+')
                with self._option():
                    self._token('--')
                with self._option():
                    self._token('-')
                with self._option():
                    self._token('@')
                with self._option():
                    self._token('*')
                self._error('no available options')
        self.name_last_node('op')
        self.__n_()
        self._cut()
        self._expr_2_()
        self.name_last_node('right')
        self.ast._define(
            ['op', 'right'],
            []
        )

    @tatsumasu('BinaryOp')
    def _expr_mul_(self):  # noqa
        self._expr_1_()
        self.name_last_node('left')
        self.___()
        with self._group():
            with self._choice():
                with self._option():
                    self._token('*')
                with self._option():
                    self._token('/')
                with self._option():
                    self._token('%')
                self._error('no available options')
        self.name_last_node('op')
        self.__n_()
        self._cut()
        self._expr_2_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu('BinaryOp')
    def _expr_add_(self):  # noqa
        self._expr_0_()
        self.name_last_node('left')
        self.___()
        with self._group():
            with self._choice():
                with self._option():
                    self._token('+')
                with self._option():
                    self._token('-')
                self._error('no available options')
        self.name_last_node('op')
        self.__n_()
        self._cut()
        self._expr_1_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu()
    def _expr_3_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('(')
                self._cut()
                self.__n_()
                self._expression_()
                self.name_last_node('@')
                self.__n_()
                self._token(')')
            with self._option():
                self._value_()
            self._error('no available options')

    @tatsumasu()
    def _expr_2_(self):  # noqa
        with self._choice():
            with self._option():
                self._expr_pre_()
            with self._option():
                self._expr_3_()
            self._error('no available options')

    @tatsumasu()
    def _expr_1_(self):  # noqa
        with self._choice():
            with self._option():
                self._expr_mul_()
            with self._option():
                self._expr_2_()
            self._error('no available options')

    @tatsumasu()
    def _expr_0_(self):  # noqa
        with self._choice():
            with self._option():
                self._expr_add_()
            with self._option():
                self._expr_1_()
            self._error('no available options')

    @tatsumasu('Expression')
    def _expression_(self):  # noqa
        self._expr_0_()
        self.name_last_node('VALUE')
        self.ast._define(
            ['VALUE'],
            []
        )

    @tatsumasu()
    def _statement_(self):  # noqa
        with self._choice():
            with self._option():
                self.___()
                self._void()
                self.name_last_node('@')
                self._t_term_()
            with self._option():
                self._cut()
                self.___()
                self._expression_()
                self.name_last_node('@')
                self.___()
                self._t_term_()
            self._error('no available options')


class PrincessSemantics(object):
    def program(self, ast):  # noqa
        return ast

    def t_newline(self, ast):  # noqa
        return ast

    def t_ws(self, ast):  # noqa
        return ast

    def _(self, ast):  # noqa
        return ast

    def _n(self, ast):  # noqa
        return ast

    def k_if(self, ast):  # noqa
        return ast

    def k_else(self, ast):  # noqa
        return ast

    def t_keyword(self, ast):  # noqa
        return ast

    def t_term(self, ast):  # noqa
        return ast

    def digit(self, ast):  # noqa
        return ast

    def hex_digit(self, ast):  # noqa
        return ast

    def oct_digit(self, ast):  # noqa
        return ast

    def bin_digit(self, ast):  # noqa
        return ast

    def sign(self, ast):  # noqa
        return ast

    def exp(self, ast):  # noqa
        return ast

    def float_frac(self, ast):  # noqa
        return ast

    def t_float_literal(self, ast):  # noqa
        return ast

    def t_dec_literal(self, ast):  # noqa
        return ast

    def t_hex_literal(self, ast):  # noqa
        return ast

    def t_oct_literal(self, ast):  # noqa
        return ast

    def t_bin_literal(self, ast):  # noqa
        return ast

    def t_num_lit(self, ast):  # noqa
        return ast

    def esc_seq(self, ast):  # noqa
        return ast

    def t_char(self, ast):  # noqa
        return ast

    def t_char_lit(self, ast):  # noqa
        return ast

    def t_string_lit(self, ast):  # noqa
        return ast

    def t_ident(self, ast):  # noqa
        return ast

    def literal(self, ast):  # noqa
        return ast

    def value(self, ast):  # noqa
        return ast

    def t_comment_start(self, ast):  # noqa
        return ast

    def t_comment_end(self, ast):  # noqa
        return ast

    def t_comment(self, ast):  # noqa
        return ast

    def t_eol_comment(self, ast):  # noqa
        return ast

    def expr_pre(self, ast):  # noqa
        return ast

    def expr_mul(self, ast):  # noqa
        return ast

    def expr_add(self, ast):  # noqa
        return ast

    def expr_3(self, ast):  # noqa
        return ast

    def expr_2(self, ast):  # noqa
        return ast

    def expr_1(self, ast):  # noqa
        return ast

    def expr_0(self, ast):  # noqa
        return ast

    def expression(self, ast):  # noqa
        return ast

    def statement(self, ast):  # noqa
        return ast


def main(filename, start=None, **kwargs):
    if start is None:
        start = 'program'
    if not filename or filename == '-':
        text = sys.stdin.read()
    else:
        with open(filename) as f:
            text = f.read()
    parser = PrincessParser()
    return parser.parse(text, rule_name=start, filename=filename, **kwargs)


if __name__ == '__main__':
    import json
    from tatsu.util import asjson

    ast = generic_main(main, PrincessParser, name='Princess')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(asjson(ast), indent=2))
    print()
