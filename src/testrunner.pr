import getopt
import shared
import vector
import util
import stdio

#if defined WIN32 {
    import windows
} else {
    import linux
}

let options = [
    option('f', "--filter", "*").set_help("Filter test cases, wildcards * and ? are allowed"),
    option('r', "--recursive", false).set_help("Run directories recursively"),
    option("--runner", false),
    option("--runner-file", ""),
    option("--runner-test", ""),
    option_repeat("files").set_metavar("FILE...").set_help("Run tests in file or directory")
]

let parser = *getopt::make_parser(options, "Princess Test Runner")
let res = parser.parse(args)
if not res { exit(1) }

def assertion_handler(result: bool, msg: *char) {
    if not result {
        fprint(stdio::stdout_orig, "x")
        if msg {
            fprint(stdio::stderr_orig, "\nAssertion failure: ", msg, "\n")
        }
        abort()
    }
    fprint(stdio::stdout_orig, ".")
    fflush(stdio::stdout_orig)
}

var stdout_file: &string
var stderr_file: &string

def get_stdout() -> &string {
    let fh = open(stdout_file, "r")
    let res = util::read_all(fh)
    close(fh)
    return res
}

def get_stderr() -> &string {
    let fh = open(stderr_file, "r")
    let res = util::read_all(fh)
    close(fh)
    return res
}

var runner = parser.get_value("--runner").b
if runner {
    let file = parser.get_value("--runner-file").str
    let test = parser.get_value("--runner-test").str

    // Test runner process, we launch tests from here
    let lib = shared::load(file)
    for var symbol in @lib.symbols {
        if symbol.name != test { continue }
        
        print(">", symbol.name)
        let tmpfolder = util::tmpfolder("princess")
        stdout_file = tmpfolder + "/stdout.txt"
        stderr_file = tmpfolder + "/stderr.txt"
        stdio::redirect_stdout_to_file(stdout_file)
        stdio::redirect_stderr_to_file(stderr_file)

        var test_env: runtime::TestEnvironment
        test_env.out = *get_stdout
        test_env.err = *get_stderr
        test_env.assertion_handler = *assertion_handler

        let test = symbol.value !def (*runtime::TestEnvironment) -> ()
        test(*test_env)

        stdio::restore_stdout()
        stdio::restore_stderr()
    }

    shared::close(*lib)
    exit(0)
}

var filter_str = parser.get_value("--filter").str
var recursive = parser.get_value("--recursive").b
var files_to_test = parser.get_value_as_vec("files")

#if defined WIN32 {
    const dll_ext = ".dll"
    const dev_null = "nul"
} else {
    const dll_ext = ".so"
    const dev_null = "/dev/null"
}

let files = vector::make(type &string)
for var i in 0..files_to_test.length {
    let file = files_to_test[i]
    enumerate_dir(file.str, "*.pr", recursive, files)
}

print("Collected " + files.length + " test files\n")
for var i in 0..files.length {
    let file = files[i]
    let dll_file = file.substring(0, file.length - 3) + dll_ext

    print("Compiling ", file, "\n")
    // TODO It needs to be incremental in the future
    if system(runtime::executable + " " + file + " --no-incremental -o " + dll_file + " > " + dev_null) {
        abort("Failed to compile test file, aborting\n")
    }
    
    let tests_to_run = vector::make(type &string)

    let lib = shared::load(dll_file, init = false) // We only want the symbol information
    for var symbol in @lib.symbols {
        if symbol.name.starts_with("__test::") {
            tests_to_run.push(symbol.name)
        }
    }
    shared::close(*lib, finalize = false)

    for var i in 0..tests_to_run.length {
        let test_function = tests_to_run[i]
        let exit_code = system(executable_file() + " --runner --runner-file=\"" + dll_file + "\" --runner-test=\"" + test_function + "\"")
        if exit_code {
            print(" [FAILED] (", exit_code, ")\n")
        } else {
            print(" [SUCCES]\n")
        }
    }
}

const FILE_ATTRIBUTE_DIRECTORY = 0x10
const INVALID_HANDLE_VALUE = -1 !uint64

// TODO Use a generator and move it to std
def enumerate_dir(file_or_dir: &string, pattern: &string, recursive: bool, res: &Vector(&string)) {
    #if defined WIN32 {
        let attrib = windows::GetFileAttributesA(file_or_dir.value)
        if not (attrib & FILE_ATTRIBUTE_DIRECTORY) {
            res.push(file_or_dir)
            return
        }

        var full_pattern = file_or_dir + "\\*"
        var find_data: windows::WIN32_FIND_DATAA
        var handle: *

        if recursive {
            handle = windows::FindFirstFileA(full_pattern.value, *find_data)
            if handle != INVALID_HANDLE_VALUE !* {
                loop {
                    let folder = make_string(find_data.cFileName.value)
                    if folder != "." and folder != ".." and find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY {
                        enumerate_dir(file_or_dir + "\\" + folder, pattern, recursive, res)
                    }
                    if not windows::FindNextFileA(handle, *find_data) { break }
                }
            }
            windows::FindClose(handle)
        }

        full_pattern = file_or_dir + "\\" + pattern
        handle = windows::FindFirstFileA(full_pattern.value, *find_data)

        if handle != INVALID_HANDLE_VALUE !* {
            loop {
                if not (find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    res.push(file_or_dir + "\\" + make_string(find_data.cFileName.value))
                }
                if not windows::FindNextFileA(handle, *find_data) { break }
            }
        }
        windows::FindClose(handle)
    } else {
        // TODO
    }
}