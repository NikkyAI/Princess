
let INITIAL_SIZE = 8

export type Vector = struct {
    length: size_t
    allocated: size_t
    data: **
}

def roundup(n: size_t) -> size_t {
    if n == 0 {
        return 0
    }
    var r: size_t = 1
    while n > r {
        r *= 2
    }
    return r
}

export def make -> *Vector {
    let vec = allocate(Vector)
    (@vec).length = 0
    (@vec).allocated = INITIAL_SIZE
    (@vec).data = allocate((size_of type *) * INITIAL_SIZE) !**
    return vec
}

def extend(vec: *Vector, delta: int) {
    if (@vec).length + delta < (@vec).allocated {
        return
    }
    let nelem = max(roundup((@vec).length + delta), INITIAL_SIZE) !int
    (@vec).data = reallocate((@vec).data, (size_of type *) * nelem)
    (@vec).allocated = nelem
}

export def length(vec: *Vector) -> size_t {
    return (@vec).length
}

export def get(vec: *Vector, index: size_t) -> * {
    assert(index >= 0 and index < (@vec).length)
    return (@vec).data[index]
}

export def set(vec: *Vector, index: size_t, val: *) {
    assert(index >= 0 and index < (@vec).length)
    (@vec).data[index] = val
}

export def push(vec: *Vector, elem: *) {
    extend(vec, 1)
    (@vec).data[(@vec).length] = elem
    (@vec).length += 1
}

export def peek(vec: *Vector) -> * {
    if (@vec).length > 0 {
        return (@vec).data[(@vec).length - 1]
    }
    return null
}

export def pop(vec: *Vector) -> * {
    var v = peek(vec)
    (@vec).length -= 1
    return v
}

export def head(vec: *Vector) -> * {
    if length(vec) < 1 { return null }
    return get(vec, 0)
}

export def head_vec(vec: *Vector) -> *Vector {
    let elem = head(vec)
    let new = make()
    push(new, elem)
    return new
}

export def tail(vec: *Vector) -> *Vector {
    let new = make()
    if length(vec) < 2 { return new }
    for var i in 1..length(vec) {
        push(new, get(vec, i))
    }
    return new
}
