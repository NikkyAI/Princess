import typechecking
import toolchain
import parser
import debug
import vector
import map
import set
import scope
import compiler
import consteval
import scope

type TypeEntry = struct {
    index: int64
    _hash: size_t   // Hash of the node for this type
    tpe: &typechecking::Type
}

type Serialize = struct {
    module: weak_ref(toolchain::Module)
    types: &SMap(TypeEntry)
    dependencies: &Set(scope::Ident)
}

const MAGIC = "PRNCSVI"

def add_type(tpe: &typechecking::Type, state: &Serialize) -> TypeEntry {
    if not tpe { return {} !TypeEntry }
    assert tpe.kind != typechecking::TypeKind::TYPE and
        tpe.kind != typechecking::TypeKind::TYPE_DEF and 
        tpe.kind != typechecking::TypeKind::GENERIC

    let name = debug::type_to_str(tpe, full_name = true)
    if state.types.contains(name) { return state.types[name] }
    let entry = {
        state.types.size + 1, // Offset by one, 0 means no type
        _hash = tpe.node._hash if tpe.node else 0,
        tpe = tpe
    } !TypeEntry
    
    state.types[name] = entry

    if typechecking::is_box(tpe) or typechecking::is_enum(tpe) {
        add_type(tpe.tpe, state)
    } else if typechecking::is_struct(tpe) {
        for var field in @tpe.fields {
            add_type(field.tpe, state)
        }
    } else if tpe.kind == typechecking::TypeKind::FUNCTION or
        tpe.kind == typechecking::TypeKind::CLOSURE {
        for var i in 0..tpe.parameter_t.length {
            let np = tpe.parameter_t[i]
            add_type(np.tpe, state)
        }
        for var i in 0..tpe.return_t.length {
            add_type(tpe.return_t[i], state)
        }
    } else if tpe.kind == typechecking::TypeKind::STRUCTURAL {
        for var i in 0..tpe.members.length {
            let member = tpe.members[i]
            for var i in 0..member.parameter_t.length {
                let np = member.parameter_t[i]
                add_type(np.tpe, state)
            }
            for var i in 0..member.return_t.length {
                add_type(member.return_t[i], state)
            }
        }
    }

    return entry
}

let TYPE_MOD: byte = -1
let TYPE_REF: byte = -2

def add_type_or_serialize(fp: File, tpe: &typechecking::Type, state: &Serialize, force_serialize: bool) {
    if force_serialize {
        serialize_type(fp, { tpe = tpe } !TypeEntry, state, true)
    } else {
        let mtpe = add_type(tpe, state)
        fp.write(*TYPE_REF)
        fp.write(*mtpe.index)
    }
}

def serialize_type(fp: File, entry: TypeEntry, state: &Serialize, force_serialize: bool = false) {
    let tpe = entry.tpe
    if tpe.module != state.module and tpe.name {
        // Type reference
        fp.write(*TYPE_MOD)
        fp.write_str(tpe.module.module if tpe.module else null)
        fp.write_str(tpe.name)
    } else {
        let id = tpe.kind !byte
        fp.write(*id)
        fp.write(*entry._hash)
        fp.write_str(tpe.name)
        fp.write_str(tpe.type_name)

        if tpe.kind == typechecking::TypeKind::WORD {
            fp.write(*tpe.unsig)
            fp.write(*tpe.size)
        } else if tpe.kind == typechecking::TypeKind::STATIC_ARRAY {
            let len = tpe.length
            fp.write(*len)
            add_type_or_serialize(fp, tpe.tpe, state, force_serialize)
        } else if typechecking::is_box(tpe) or tpe.kind == typechecking::TypeKind::TYPE or
            tpe.kind == typechecking::TypeKind::TYPE_DEF {

            add_type_or_serialize(fp, tpe.tpe, state, force_serialize)
        } else if typechecking::is_struct(tpe) {
            let sz = tpe.fields.size
            fp.write(*sz)
            for var field in @tpe.fields {
                add_type_or_serialize(fp, field.tpe, state, force_serialize)
                fp.write(*field.line)
                fp.write(*field.is_bitfield)
                fp.write(*field.bit_size)
                fp.write_str(field.name)
            }
        } else if tpe.kind == typechecking::TypeKind::FUNCTION or
            tpe.kind == typechecking::TypeKind::CLOSURE {
            fp.write(*tpe.parameter_t.length)
            for var i in 0..tpe.parameter_t.length {
                let np = tpe.parameter_t[i]
                add_type_or_serialize(fp, np.tpe, state, force_serialize)
                fp.write_str(np.name)
            }
            fp.write(*tpe.return_t.length)
            for var i in 0..tpe.return_t.length {
                let mtpe = add_type(tpe.return_t[i], state)
                fp.write(*mtpe.index)
            }
        } else if tpe.kind == typechecking::TypeKind::STRUCTURAL {
            fp.write(*tpe.members.length)
            for var i in 0..tpe.members.length {
                let member = tpe.members[i]
                fp.write_str(member.name)
                fp.write(*member.parameter_t.length)
                for var i in 0..member.parameter_t.length {
                    let np = member.parameter_t[i]
                    add_type_or_serialize(fp, np.tpe, state, force_serialize)
                    fp.write_str(np.name)
                }
                fp.write(*member.return_t.length)
                for var i in 0..member.return_t.length {
                    add_type_or_serialize(fp, member.return_t[i], state, force_serialize)
                }
            }
        } else if tpe.kind == typechecking::TypeKind::STUB {
            // nothing here
        } else if tpe.kind == typechecking::TypeKind::ENUM {
            let mtpe = add_type(tpe.tpe, state)
            fp.write(*mtpe.index)

            let scpe = tpe.scope
            let ekeys = scpe.fields.keys()
            let sz = ekeys.size
            fp.write(*sz)
            for var key in @ekeys {
                let value = scpe.fields[key]
                assert value.modifier == parser::VarDecl::CONST
                fp.write(*value.value.i)
            }
        } else if tpe.kind == typechecking::TypeKind::TYPE_CONSTRUCTOR {
            fp.write(*tpe.parameter_t.length)
            for var i in 0..tpe.parameter_t.length {
                let np = tpe.parameter_t[i]
                fp.write_str(np.name)
            }
            let loc = tpe.tc_node.loc
            fp.write(*loc.line)
            fp.write(*loc.column)
            fp.write(*loc.end_line)
            fp.write(*loc.end_column)
        } else if tpe.kind == typechecking::TypeKind::GENERIC {
            fp.write(*tpe.tc_args.length)
            for var arg in 0..tpe.tc_args.length {
                let tc_arg = tpe.tc_args[0]
                add_type_or_serialize(fp, tc_arg, state, tpe.tc_incomplete or force_serialize)
            }
        } else {
            error(tpe.kind, "\n")
            assert
        }
    }
}

def write_type(fp: File, tpe: &typechecking::Type, state: &Serialize) {
    var type_kind: byte = tpe.kind !byte
    let generic = typechecking::get_generic(tpe) 
    let serialize = generic and generic.tc_incomplete or
        tpe.kind == typechecking::TypeKind::TYPE or
        tpe.kind == typechecking::TypeKind::TYPE_DEF

    add_type_or_serialize(fp, tpe, state, serialize)
}

def serialize_function(fp: File, value: &scope::Value, state: &Serialize) {
    let tpe = value.tpe
    let hash = value.node.signature_hash if value.node else 0
    let share = value.share !byte
    fp.write(*hash)
    fp.write(*share)
    fp.write(*value.extern)
    // TODO Get Function object with dllexport and dllimport
    fp.write_str(value.name)
    fp.write_str(tpe.type_name)

    state.dependencies.add_all(value.dependencies)

    fp.write(*tpe.parameter_t.length)
    for var i in 0..tpe.parameter_t.length {
        let np = tpe.parameter_t[i]
        if not np.tpe and np.varargs {
            let varargs: byte = -2
            fp.write(*varargs)
        } else {
            let has_value = np.value !bool
            write_type(fp, np.tpe, state)
            fp.write(*has_value)
            if has_value {
                serialize_value(fp, np.value, state)
            }
        }
        fp.write_str(np.name)
    }
    fp.write(*tpe.return_t.length)
    for var i in 0..tpe.return_t.length {
        let tpe = tpe.return_t[i]
        let entry = add_type(tpe, state)
        fp.write(*entry.index)
    }
    let is_polymorph = typechecking::is_polymorph(tpe)
    fp.write(*is_polymorph)
    if is_polymorph {
        let loc = value.node.loc
        fp.write(*loc.line)
        fp.write(*loc.column)
        fp.write(*loc.end_line)
        fp.write(*loc.end_column)
    }
}

def serialize_variable(fp: File, value: &scope::Value, state: &Serialize) {
    let hash = value.node._hash if value.node else 0
    let share = value.share !byte
    let is_constant = value.modifier == typechecking::VarDecl::CONST

    fp.write(*hash)
    fp.write(*share)
    fp.write(*value.extern)
    fp.write(*value.dllimport)
    fp.write(*value.dllexport)
    fp.write_str(value.name)

    state.dependencies.add_all(value.dependencies)

    let mtpe = add_type(value.tpe, state)
    fp.write(*mtpe.index)
    fp.write(*is_constant)
    if is_constant {
        serialize_value(fp, value.value, state)
    }
}

def serialize_value(fp: File, value: &compiler::Value, state: &Serialize) {

}

export def serialize(module: &toolchain::Module) {
    let cache_file = module.filename.substring(0, module.filename.length - 3) + ".prc"

    let fp = open(@cache_file, "w")
    defer close(fp)
    fp.write(MAGIC)

    let state = {
        types = map::make(TypeEntry),
        module = module,
        dependencies = set::make(scope::Ident)
    } !&Serialize

    // Write imports
    let imports = module.scope.imports
    if imports {
        fp.write(*imports.length)
        for var i in 0..imports.length {
            let imp = imports[i]
            fp.write_str(parser::identifier_to_str(imp.alias))
            fp.write_str(imp.module.module)
            fp.write_str(imp.module.filename)
        }
    } else {
        let zero: uint64 = 0
        fp.write(*zero)
    }
    
    let functions = scope::all_functions(module.scope)
    let exported_functions = vector::make(type &scope::Value)
    for var i in 0..functions.length {
        let value = functions[i]
        if value.share !int & parser::ShareMarker::EXPORT !int { 
            exported_functions.push(value)
        }
    }

    fp.write(*exported_functions.length) // Number of functions
    for var i in 0..exported_functions.length {
        let value = exported_functions[i]
        serialize_function(fp, value, state)
    }

    let variables = vector::make(type &scope::Value)
    for var key in @module.scope.fields.keys() {
        let value = module.scope.fields[key]
        if value.share !int & parser::ShareMarker::EXPORT !int {
            if value.modifier == parser::VarDecl::TYPE {
                add_type(value.value.value_tpe, state)
                state.dependencies.add_all(value.dependencies)
            } else if value.modifier == parser::VarDecl::CONST {
                if value.tpe.kind != typechecking::TypeKind::FUNCTION {
                    variables.push(value)
                }
            } else {
                variables.push(value)
            }
        }
    }


    fp.write(*state.types.size) // Number of types
    for var key in @state.types.keys() {
        serialize_type(fp, state.types[key], state)
    }

    fp.write(*variables.length)
    for var i in 0..variables.length {
        serialize_variable(fp, variables[i], state)
    }

    // Filter out local stuff
    let dependencies = set::make(scope::Ident)
    for var ident in @state.dependencies.keys() {
        if ident.module != module {
            dependencies.add(ident)
        }
    }

    fp.write(*dependencies.size)
    for var ident in @dependencies.keys() {
        fp.write(*ident._hash)
        fp.write_str(ident.name)
        fp.write_str(ident.signature)
        fp.write_str(ident.module.module if ident.module else null)
    }
}

export type Deserialize = struct {
    module: weak_ref(toolchain::Module)
    types: &Vector(&typechecking::Type)
    dependencies: &[scope::Ident]
}

export def resolver_pass(module: &toolchain::Module) {
    if module.is_dirty { return }
    if module.stage !int >= toolchain::Stage::READ_CACHE { return }
    let cache_file = module.filename.substring(0, module.filename.length - 3) + ".prc"

    let deserialize = {
        module = module
    } !&Deserialize

    module.deserialize = deserialize

    let fp = open(@cache_file, "rb")
    if not fp { module.is_dirty = true; return }
    defer close(fp)

    let source_fp = open(@module.filename, "rb")
    defer close(source_fp)

    if modified_time(source_fp) > modified_time(fp) {
        module.is_dirty = true
        return
    }
    
    var magic: [8; char] // TODO use MAGIC.size here
    fp.read(magic)
    if magic != MAGIC { module.is_dirty = true; return }

    var imported_size: size_t
    fp.read(*imported_size)
    for var i in 0..imported_size {
        let ident = parser::identifier_from_str(fp.read_str())
        let modulename = fp.read_str()
        let filename = fp.read_str()

        let imprt = toolchain::create_module_if_absent(modulename, filename)
        scope::insert_module(module.scope, ident, imprt)
    }

    module.is_dirty = true // TODO Remove
}

export def dependency_pass(module: &toolchain::Module) {
    if module.stage !int >= toolchain::Stage::RESOLVE_DEPENDENCIES !int { return } 
    module.stage = toolchain::Stage::RESOLVE_DEPENDENCIES
    
    if module.is_dirty { return }
    if module.node {
        let node = module.node
        assert node.kind == parser::NodeKind::PROGRAM
        for var i in 0..node.body.length {
            let n = node.body[i]
            if not n or n.kind != parser::NodeKind::IMPORT { continue }
            // IMPORT
            let imports = n.value.body
            for var i in 0..vector::length(imports) {
                let imprt = imports[i]
                var name = (@imprt).value.import_module.name
                if not name { continue }
                toolchain::resolve_dependencies(name, module)
            }
        }
        return
    }

    let deserialize = module.deserialize

    let imports = module.scope.imports
    for var i in 0..imports.length {
        let imprt = imports[i]
        dependency_pass(imprt.module)
    }

    // Check if any of the dependencies are out of date
    for var dep in @deserialize.dependencies {
        let value = scope::find(dep)
        if not value or value.ident._hash != dep._hash { 
            module.is_dirty = true
            break 
        }
    }

    if module.is_dirty and module.stage !int < toolchain::Stage::PREPROCESS !int {
        module.stage = toolchain::Stage::PREPROCESS
        consteval::consteval(module)
    }
}