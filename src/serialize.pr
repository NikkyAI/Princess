import typechecking
import toolchain
import lexer
import parser
import debug
import vector
import map
import set
import scope
import compiler
import consteval
import scope
import util
import builtins

type TypeEntry = struct {
    index: int64
    _hash: size_t   // Hash of the node for this type
    tpe: &typechecking::Type
}

type Serialize = struct {
    module: weak_ref(toolchain::Module)
    types: &SMap(TypeEntry)
    dependencies: &Set(scope::Ident)
}

const MAGIC = "PRNCSVI"

def add_type(tpe: &typechecking::Type, state: &Serialize) -> TypeEntry {
    if not tpe { return {} !TypeEntry }
    assert tpe.kind != typechecking::TypeKind::TYPE and
        tpe.kind != typechecking::TypeKind::TYPE_DEF and 
        tpe.kind != typechecking::TypeKind::GENERIC

    let name = debug::type_to_str(tpe, full_name = true)
    if state.types.contains(name) { return state.types[name] }
    let entry = {
        state.types.size + 1, // Offset by one, 0 means no type
        _hash = tpe.node._hash if tpe.node else 0,
        tpe = tpe
    } !TypeEntry
    
    state.types[name] = entry

    if typechecking::is_box(tpe) or typechecking::is_enum(tpe) {
        add_type(tpe.tpe, state)
    } else if typechecking::is_struct(tpe) {
        for var field in @tpe.fields {
            add_type(field.tpe, state)
        }
    } else if tpe.kind == typechecking::TypeKind::FUNCTION or
        tpe.kind == typechecking::TypeKind::CLOSURE {
        for var i in 0..tpe.parameter_t.length {
            let np = tpe.parameter_t[i]
            add_type(np.tpe, state)
        }
        for var i in 0..tpe.return_t.length {
            add_type(tpe.return_t[i], state)
        }
    } else if tpe.kind == typechecking::TypeKind::STRUCTURAL {
        for var i in 0..tpe.members.length {
            let member = tpe.members[i]
            for var i in 0..member.parameter_t.length {
                let np = member.parameter_t[i]
                add_type(np.tpe, state)
            }
            for var i in 0..member.return_t.length {
                add_type(member.return_t[i], state)
            }
        }
    }

    return entry
}

let TYPE_MOD: byte = -1
let TYPE_REF: byte = -2
let VARARGS: byte = -3
let NO_TYPE: byte = -4

def add_type_or_serialize(fp: File, tpe: &typechecking::Type, state: &Serialize, force_serialize: bool) {
    if force_serialize {
        serialize_type(fp, { tpe = tpe } !TypeEntry, state, true)
    } else if tpe {
        let mtpe = add_type(tpe, state)
        fp.write(*TYPE_REF)
        fp.write(*mtpe.index)
    } else {
        fp.write(*NO_TYPE)
    }
}

def serialize_type(fp: File, entry: TypeEntry, state: &Serialize, force_serialize: bool = false) {
    var tpe = entry.tpe
    if not tpe {
        fp.write(*NO_TYPE)
        return
    }
    if tpe.kind == typechecking::TypeKind::BOX {
        tpe = tpe.weak
    }
    if tpe.module and tpe.module != state.module and tpe.name {
        // Type reference
        fp.write(*TYPE_MOD)
        if tpe.module !* == builtins::builtins_module !* {
            fp.write_str("builtins")
        } else {
            assert tpe.module.filename != null
            fp.write_str(tpe.module.filename if tpe.module else null)
        }
        fp.write_str(tpe.name)
    } else {
        let id = tpe.kind !byte
        fp.write(*id)
        fp.write(*entry._hash)
        fp.write_str(tpe.name)
        fp.write_str(tpe.type_name)

        if tpe.kind == typechecking::TypeKind::WORD {
            fp.write(*tpe.unsig)
            fp.write(*tpe.size)
        } else if tpe.kind == typechecking::TypeKind::STATIC_ARRAY {
            let len = tpe.length
            fp.write(*len)
            add_type_or_serialize(fp, tpe.tpe, state, force_serialize)
        } else if typechecking::is_box(tpe) or tpe.kind == typechecking::TypeKind::TYPE or
            tpe.kind == typechecking::TypeKind::TYPE_DEF {

            add_type_or_serialize(fp, tpe.tpe, state, force_serialize)
        } else if typechecking::is_struct(tpe) {
            let sz = tpe.fields.size
            fp.write(*sz)
            for var field in @tpe.fields {
                add_type_or_serialize(fp, field.tpe, state, force_serialize)
                fp.write(*field.line)
                fp.write(*field.is_bitfield)
                fp.write(*field.bit_size)
                fp.write_str(field.name)
            }
        } else if tpe.kind == typechecking::TypeKind::FUNCTION or
            tpe.kind == typechecking::TypeKind::CLOSURE {
            fp.write(*tpe.parameter_t.length)
            for var i in 0..tpe.parameter_t.length {
                let np = tpe.parameter_t[i]
                add_type_or_serialize(fp, np.tpe, state, force_serialize)
                fp.write_str(np.name)
            }
            fp.write(*tpe.return_t.length)
            for var i in 0..tpe.return_t.length {
                add_type_or_serialize(fp, tpe.return_t[i], state, force_serialize)
            }
        } else if tpe.kind == typechecking::TypeKind::STRUCTURAL {
            fp.write(*tpe.members.length)
            for var i in 0..tpe.members.length {
                let member = tpe.members[i]
                fp.write_str(member.name)
                fp.write(*member.parameter_t.length)
                for var i in 0..member.parameter_t.length {
                    let np = member.parameter_t[i]
                    add_type_or_serialize(fp, np.tpe, state, force_serialize)
                    fp.write_str(np.name)
                }
                fp.write(*member.return_t.length)
                for var i in 0..member.return_t.length {
                    add_type_or_serialize(fp, member.return_t[i], state, force_serialize)
                }
            }
        } else if tpe.kind == typechecking::TypeKind::STUB {
            // nothing here
        } else if tpe.kind == typechecking::TypeKind::ENUM {
            add_type_or_serialize(fp, tpe.tpe, state, force_serialize)

            let scpe = tpe.scope
            let ekeys = scpe.fields.keys()
            let sz = ekeys.size
            fp.write(*sz)
            for var key in @ekeys {
                let value = scpe.fields[key]
                assert value.modifier == parser::VarDecl::CONST
                fp.write(*value)
                fp.write(*value.value.i)
            }
        } else if tpe.kind == typechecking::TypeKind::TYPE_CONSTRUCTOR {
            fp.write(*tpe.parameter_t.length)
            for var i in 0..tpe.parameter_t.length {
                let np = tpe.parameter_t[i]
                fp.write_str(np.name)
            }
            let loc = tpe.tc_node.loc
            fp.write(*loc.line)
            fp.write(*loc.column)
            fp.write(*loc.end_line)
            fp.write(*loc.end_column)
        } else if tpe.kind == typechecking::TypeKind::GENERIC {
            assert tpe.tpe != null
            add_type_or_serialize(fp, tpe.tpe, state, force_serialize)
            fp.write(*tpe.tc_args.length)
            for var arg in 0..tpe.tc_args.length {
                let tc_arg = tpe.tc_args[0]
                add_type_or_serialize(fp, tc_arg, state, tpe.tc_incomplete or force_serialize)
            }
        } else {
            error(tpe.kind, "\n")
            assert
        }
    }
}

def write_type(fp: File, tpe: &typechecking::Type, state: &Serialize) {
    var type_kind: byte = tpe.kind !byte
    let generic = typechecking::get_generic(tpe) 
    let serialize = generic and generic.tc_incomplete or
        tpe.kind == typechecking::TypeKind::TYPE or
        tpe.kind == typechecking::TypeKind::TYPE_DEF

    add_type_or_serialize(fp, tpe, state, serialize)
}

def serialize_function(fp: File, value: &scope::Value, state: &Serialize) {
    let tpe = value.tpe
    let hash = value.node.signature_hash if value.node else 0
    let share = value.share !byte
    fp.write(*hash)
    fp.write(*share)
    fp.write(*value.extern)
    // TODO Get Function object with dllexport and dllimport
    fp.write_str(value.name)
    fp.write_str(tpe.type_name)

    state.dependencies.add_all(value.dependencies)

    fp.write(*tpe.parameter_t.length)
    for var i in 0..tpe.parameter_t.length {
        let np = tpe.parameter_t[i]
        fp.write_str(np.name)
        fp.write(*np.varargs)
        if not np.tpe and np.varargs {
            fp.write(*VARARGS)
            let f = false
            fp.write(*f) // has_value
        } else {
            let has_value = np.value !bool
            write_type(fp, np.tpe, state)
            fp.write(*has_value)
            if has_value {
                serialize_value(fp, np.value, state)
            }
        }
    }
    fp.write(*tpe.return_t.length)
    for var i in 0..tpe.return_t.length {
        let tpe = tpe.return_t[i]
        write_type(fp, tpe, state)
    }
    let is_polymorph = typechecking::is_polymorph(tpe)
    fp.write(*is_polymorph)
    if is_polymorph {
        let loc = value.node.loc
        fp.write(*loc.line)
        fp.write(*loc.column)
        fp.write(*loc.end_line)
        fp.write(*loc.end_column)
    }
}

def create_type_if_absent(module: &toolchain::Module, name: &string) -> &typechecking::Type {
    let ident = parser::make_identifier(name)
    var value = scope::get(module.scope, ident, force_compile = false, dry_run = true)
    if value and value.modifier == parser::VarDecl::TYPE {
        return value.value.value_tpe
    }
    let tpe = typechecking::make_stub_type(ident, module.state)
    value = scope::create_type(module.scope, ident, parser::ShareMarker::EXPORT, tpe, scope::Phase::DEFINED, null, module.state)
    value.identifier = ident
    return tpe
}

def deserialize_node(deserialize: &Deserialize, loc: parser::SourceLoc) -> &parser::Node {
    let tokens = lexer::lex(deserialize.module.text, loc.line, loc.column, loc.end_line, loc.end_column)
    let node = parser::parse(tokens, deserialize.module.lines, deserialize.module.filename, deserialize.module.module, deserialize.module.display_name)
    delete(tokens)

    deserialize.nodes.push(node)
    return node
}

def deserialize_type_node(deserialize: &Deserialize, loc: parser::SourceLoc) -> &parser::Node {
    let tokens = lexer::lex(deserialize.module.text, loc.line, loc.column, loc.end_line, loc.end_column)
    let parse_state = parser::make_state(deserialize.module.filename, deserialize.module.display_name, deserialize.module.module, deserialize.module.lines, tokens)
    let node = parser::parse_type(parse_state)
    delete(tokens)

    deserialize.nodes.push(node)
    return node
}

def deserialize_type(deserialize: &Deserialize, fp: File) -> &typechecking::Type {
    var kind: byte
    fp.read(*kind)
    if kind == NO_TYPE { return null }
    if kind == VARARGS { return null }
    if kind == TYPE_MOD {
        let module = fp.read_str()
        let name = fp.read_str()
        if module == "builtins" {
            return builtins::builtins_module.scope.get_type(parser::make_identifier(name))
        }
        return create_type_if_absent(toolchain::modules[module], name)
    } else if kind == TYPE_REF {
        var index: int64
        fp.read(*index)

        if index < deserialize.types.length {
            return deserialize.types[index]
        }

        let tpe = { kind = typechecking::TypeKind::STUB, is_in_type_cache = true } !&typechecking::Type
        deserialize.types.resize(index + 1)
        vector::set_item(deserialize.types, index, tpe) // TODO Why do we have to do this??

        return tpe
    } else {
        var tpekind = kind !typechecking::TypeKind

        var hash: uint64
        fp.read(*hash)
        var name = fp.read_str()
        var type_name = fp.read_str()

        var tpe = { 
            kind = tpekind, 
            name = name, 
            type_name = type_name,
            _hash = hash
        } !&typechecking::Type

        switch tpekind !int {
        case typechecking::TypeKind::WORD:
            fp.read(*tpe.unsig)
            fp.read(*tpe.size)
        case typechecking::TypeKind::STATIC_ARRAY:
            fp.read(*tpe.length)
            tpe._tpe = deserialize_type(deserialize, fp)
        case typechecking::TypeKind::TYPE, 
            typechecking::TypeKind::TYPE_DEF,
            typechecking::TypeKind::POINTER,
            typechecking::TypeKind::REFERENCE,
            typechecking::TypeKind::WEAK_REF,
            typechecking::TypeKind::ARRAY:

            let ptpe = deserialize_type(deserialize, fp)
            if ptpe and ptpe.is_in_type_cache {
                tpe._tpe = typechecking::box(ptpe)
            } else {
                tpe._tpe = ptpe
            }
        case typechecking::TypeKind::STRUCT,
            typechecking::TypeKind::UNION:
            
            var sz: size_t
            fp.read(*sz)

            let fields = allocate_ref(typechecking::StructMember, sz)
            for var i in 0..sz {
                var np = {} !typechecking::StructMember
                np.tpe = deserialize_type(deserialize, fp)
                fp.read(*np.line)
                fp.read(*np.is_bitfield)
                fp.read(*np.bit_size)
                np.name = fp.read_str()
                fields[i] = np
            }
            tpe.fields = fields
            
            if tpekind == typechecking::TypeKind::STRUCT {
                tpe = typechecking::make_struct_type(fields)
            } else {
                var size: size_t = 0
                var align: size_t = 1

                var biggest_type: &typechecking::Type
                for var field in @fields {
                    if field.tpe.size > size {
                        biggest_type = field.tpe
                        size = field.tpe.size
                    } 

                    align = max(field.tpe.align, align) !size_t
                }

                let field_types = vector::make(typechecking::TypeMember)
                let type_member = { biggest_type, 0 } !typechecking::TypeMember
                field_types.push(type_member)

                tpe.size = size
                tpe.align = align
                tpe.field_types = field_types
            }
        case typechecking::TypeKind::FUNCTION,
            typechecking::TypeKind::CLOSURE:

            let parameter_t = vector::make(typechecking::NamedParameter)
            var size: size_t
            fp.read(*size)
            for var i in 0..size {
                var np: typechecking::NamedParameter
                np._tpe =  deserialize_type(deserialize, fp)
                np.name = fp.read_str()
                parameter_t.push(np)
            }

            let return_t = vector::make(type &typechecking::Type)
            fp.read(*size)
            for var i in 0..size {
                return_t.push(deserialize_type(deserialize, fp))
            }
        case typechecking::TypeKind::STRUCTURAL:
            let members = vector::make(typechecking::StructuralTypeMember)
            var size: size_t
            fp.read(*size)
            for var i in 0..size {
                var member: typechecking::StructuralTypeMember
                member.name = fp.read_str()

                var size: size_t
                member.parameter_t = vector::make(typechecking::NamedParameter)
                fp.read(*size)
                for var i in 0..size {
                    var np: typechecking::NamedParameter
                    let ftpe = deserialize_type(deserialize, fp)
                    if ftpe and ftpe.is_in_type_cache {
                        np._tpe =  typechecking::box(ftpe)
                    } else {
                        np._tpe =  ftpe
                    }
                    np.name = fp.read_str()
                    member.parameter_t.push(np)
                }
                member.return_t = vector::make(type &typechecking::Type)
                fp.read(*size)
                for var i in 0..size {
                    member.return_t.push(deserialize_type(deserialize, fp))
                }
                members.push(member)
            }
        case typechecking::TypeKind::STUB:
            // nothing here
        case typechecking::TypeKind::ENUM:
            tpe._tpe = deserialize_type(deserialize, fp)

            let scpe = scope::enter_scope(deserialize.module.scope)
            deserialize.scopes.push(scpe)
            var size: size_t
            fp.read(*size)
            for var i in 0..size {
                let name = parser::make_identifier(fp.read_str())
                var value: int64
                fp.read(*value)
                let v = scope::create_variable(scpe,
                    name, parser::ShareMarker::EXPORT, parser::VarDecl::CONST, tpe.tpe, 
                    { kind = compiler::ValueKind::INT, tpe = tpe.tpe, i = value } !compiler::Value
                )
                v.identifier = name
            }
            tpe.scope = scpe
        case typechecking::TypeKind::TYPE_CONSTRUCTOR:
            tpe.parameter_t = vector::make(typechecking::NamedParameter)

            var size: size_t
            fp.read(*size)
            for var i in 0..size {
                let name = fp.read_str()
                var np: typechecking::NamedParameter
                np._tpe =  builtins::type_
                np.name = name
                tpe.parameter_t.push(np)
            }

            var loc: parser::SourceLoc
            fp.read(*loc.line)
            fp.read(*loc.column)
            fp.read(*loc.end_line)
            fp.read(*loc.end_column)
            let node = deserialize_type_node(deserialize, loc)
            tpe.tc_node = node
        case typechecking::TypeKind::GENERIC:
            var size: size_t
            tpe._tpe = deserialize_type(deserialize, fp)
            fp.read(*size)
            tpe.tc_args = vector::make(type &typechecking::Type)
            for var arg in 0..size {
                tpe.tc_args.push(deserialize_type(deserialize, fp))
            }
        case typechecking::TypeKind::BOOL:
            return builtins::bool_
        case:
            error(tpe.kind, "\n")
            assert
        }

        return tpe
    }
}

def deserialize_function(deserialize: &Deserialize, fp: File) {
    var hash: uint64
    var share: bool
    var extern: bool
    var name: &string
    var type_name: &string

    fp.read(*hash)
    fp.read(*share)
    fp.read(*extern)
    name = fp.read_str()
    type_name = fp.read_str()

    debug::trace("Deserializing function ", type_name)

    var size: size_t
    fp.read(*size)

    let parameter_t = vector::make(typechecking::NamedParameter)
    for var i in 0..size {
        var name = fp.read_str()
        var varargs: bool
        fp.read(*varargs)
        let tpe = deserialize_type(deserialize, fp)
        var has_value: bool
        fp.read(*has_value)
        if has_value {
            let value = deserialize_value(deserialize, fp)
        }
        parameter_t.push({ name = name, _tpe = tpe, varargs = varargs } !typechecking::NamedParameter)
    }

    let return_t = vector::make(type &typechecking::Type)
    fp.read(*size)
    for var i in 0..size {
        return_t.push(deserialize_type(deserialize, fp))
    }

    var node: &parser::Node
    var state: &typechecking::State

    let ftpe = typechecking::make_function_type()
    ftpe.type_name = type_name
    ftpe.name = name
    ftpe.module = deserialize.module
    ftpe.parameter_t = parameter_t
    ftpe.return_t = return_t

    var is_polymorph: bool
    fp.read(*is_polymorph)
    if is_polymorph {
        var loc: parser::SourceLoc
        fp.read(*loc.line)
        fp.read(*loc.column)
        fp.read(*loc.end_line)
        fp.read(*loc.end_column)
        node = deserialize_node(deserialize, loc)
        state = deserialize.module.state
        deserialize.nodes.push(node)

        node.value.def_.function = {
            is_global = true,
            module = deserialize.module,
            name = ftpe.type_name,
            unmangled = ftpe.name
        } !&compiler::Function
    }

    let name_node = parser::make_identifier(name)
    let value = scope::create_function(deserialize.module.scope, name_node, parser::ShareMarker::EXPORT, ftpe, scope::Phase::COMPILED, node, state)
    value.identifier = name_node
}

def serialize_variable(fp: File, value: &scope::Value, state: &Serialize) {
    let hash = value.node._hash if value.node else 0
    let share = value.share !byte
    let is_constant = value.modifier == typechecking::VarDecl::CONST

    fp.write(*hash)
    fp.write(*share)
    fp.write(*value.extern)
    fp.write(*value.dllimport)
    fp.write(*value.dllexport)
    fp.write_str(value.name)

    state.dependencies.add_all(value.dependencies)

    let mtpe = add_type(value.tpe, state)
    fp.write(*mtpe.index)
    fp.write(*is_constant)
    if is_constant {
        serialize_value(fp, value.value, state)
    }
}

def serialize_value(fp: File, value: &compiler::Value, state: &Serialize) {

}

def deserialize_value(deserialize: &Deserialize, fp: File) -> &compiler::Value {
    return null
}

export def serialize(module: &toolchain::Module) {
    let cache_file = module.filename.substring(0, module.filename.length - 3) + ".prc"

    let fp = open(@cache_file, "wb")
    defer close(fp)
    fp.write(MAGIC)

    let state = {
        types = map::make(TypeEntry),
        module = module,
        dependencies = set::make(scope::Ident)
    } !&Serialize

    // Write imports
    let imports = module.scope.imports
    if imports {
        fp.write(*imports.length)
        for var i in 0..imports.length {
            let imp = imports[i]
            fp.write_str(parser::identifier_to_str(imp.alias))
            fp.write_str(imp.module.module)
            fp.write_str(imp.module.filename)
        }
    } else {
        let zero: uint64 = 0
        fp.write(*zero)
    }
    
    let functions = scope::all_functions(module.scope)
    let exported_functions = vector::make(type &scope::Value)
    for var i in 0..functions.length {
        let value = functions[i]
        if value.share !int & parser::ShareMarker::EXPORT !int { 
            exported_functions.push(value)
        }
    }

    fp.write(*exported_functions.length) // Number of functions
    for var i in 0..exported_functions.length {
        let value = exported_functions[i]
        serialize_function(fp, value, state)
    }

    let variables = vector::make(type &scope::Value)
    for var key in @module.scope.fields.keys() {
        let value = module.scope.fields[key]
        if value.share !int & parser::ShareMarker::EXPORT !int {
            if value.modifier == parser::VarDecl::TYPE {
                add_type(value.value.value_tpe, state)
                state.dependencies.add_all(value.dependencies)
            } else if value.modifier == parser::VarDecl::CONST {
                if value.tpe.kind != typechecking::TypeKind::FUNCTION {
                    variables.push(value)
                }
            } else {
                variables.push(value)
            }
        }
    }


    fp.write(*state.types.size) // Number of types
    for var key in @state.types.keys() {
        serialize_type(fp, state.types[key], state)
    }

    fp.write(*variables.length)
    for var i in 0..variables.length {
        serialize_variable(fp, variables[i], state)
    }

    // Filter out local stuff
    let dependencies = set::make(scope::Ident)
    for var ident in @state.dependencies.keys() {
        if ident.module != module {
            dependencies.add(ident)
        }
    }

    fp.write(*dependencies.size)
    for var ident in @dependencies.keys() {
        fp.write(*ident._hash)
        fp.write_str(ident.name)
        fp.write_str(ident.signature)
        fp.write_str(ident.module.module if ident.module else null)
    }
}

export type Deserialize = struct {
    module: weak_ref(toolchain::Module)
    types: &Vector(&typechecking::Type)
    nodes: &Vector(&parser::Node) // Strong references to nodes
    scopes: &Vector(&scope::Scope) // Strong references to enum scopes
    dependencies: &[scope::Ident]
}

export def resolver_pass(module: &toolchain::Module) {
    if module.is_dirty { return }
    if module.stage !int >= toolchain::Stage::READ_CACHE { return }
    let cache_file = module.filename.substring(0, module.filename.length - 3) + ".prc"

    if not util::exists(toolchain::outfolder + "/" + module.module + ".o") {
        module.is_dirty = true
        return
    }

    debug::trace("Deserializing module ", module.module)

    let deserialize = {
        module = module,
        types = vector::make(type &typechecking::Type),
        nodes = vector::make(type &parser::Node),
        scopes = vector::make(type &scope::Scope)
    } !&Deserialize

    module.deserialize = deserialize

    let fp = open(@cache_file, "rb")
    if not fp { module.is_dirty = true; return }
    defer close(fp)

    let source_fp = open(@module.filename, "rb")
    defer close(source_fp)

    if modified_time(source_fp) > modified_time(fp) {
        module.is_dirty = true
        return
    }
    
    var magic: [8; char] // TODO use MAGIC.size here
    fp.read(magic)
    if magic != MAGIC { module.is_dirty = true; return }

    var imported_size: size_t
    fp.read(*imported_size)
    for var i in 0..imported_size {
        let ident = parser::identifier_from_str(fp.read_str())
        let modulename = fp.read_str()
        let filename = fp.read_str()

        let imprt = toolchain::create_module_if_absent(filename, modulename)
        scope::insert_module(module.scope, ident, imprt)
    }
    
    var functions_size: size_t
    fp.read(*functions_size)
    for var i in 0..functions_size {
        deserialize_function(deserialize, fp)
    }

    //module.is_dirty = true // TODO Remove
}

export def dependency_pass(module: &toolchain::Module) {
    if module.stage !int >= toolchain::Stage::RESOLVE_DEPENDENCIES !int { return } 
    module.stage = toolchain::Stage::RESOLVE_DEPENDENCIES
    
    if module.is_dirty { return }
    if module.node {
        let node = module.node
        assert node.kind == parser::NodeKind::PROGRAM
        for var i in 0..node.body.length {
            let n = node.body[i]
            if not n or n.kind != parser::NodeKind::IMPORT { continue }
            // IMPORT
            let imports = n.value.body
            for var i in 0..vector::length(imports) {
                let imprt = imports[i]
                var name = (@imprt).value.import_module.name
                if not name { continue }
                toolchain::resolve_dependencies(name, module)
            }
        }
        return
    }

    let deserialize = module.deserialize

    let imports = module.scope.imports
    for var i in 0..imports.length {
        let imprt = imports[i]
        dependency_pass(imprt.module)
    }

    // Check if any of the dependencies are out of date
    for var dep in @deserialize.dependencies {
        let value = scope::find(dep)
        if not value or value.ident._hash != dep._hash { 
            module.is_dirty = true
            break
        }
    }

    if module.is_dirty and module.stage !int < toolchain::Stage::PREPROCESS !int {
        module.stage = toolchain::Stage::PREPROCESS
        toolchain::consteval_module(module)
    }
}