import vector
import map
import compiler
import typechecking
import preprocess
import scope

export type StackFrame = struct {
    // Map of compiler::Value
    locals: *map::Map
    function_name: string
}

export type State = struct {
    // Map of compiler::Block
    jump_table: *map::Map
    // Vector of StackFrame
    stack: *vector::Vector

    next: *compiler::Block
}

def errorv(msg: string) {
    error("error: [eval] ")
    error(msg)
}

export def get_stack_frame(state: *State) -> *StackFrame {
    return vector::peek(state.stack) !*StackFrame
}

export def get_value(value: compiler::Value, state: *State) -> compiler::Value {
    switch value.kind !int {
        case compiler::ValueKind::LOCAL:
            return @(map::get(get_stack_frame(state).locals, value.name) !*compiler::Value)
        case compiler::ValueKind::GLOBAL:
            let global = map::get(preprocess::compiler_state.result.constants, value.name) !*compiler::Global
            if not global {
                errorv("Unknown value \"")
                error(value.name, "\"\n")
                return compiler::NO_VALUE
            }
            return @global.value
        case: return value
    }
}

def set_value(addr: compiler::Value, value: compiler::Value, state: *State) {
    let valuep = allocate(compiler::Value)
    @valuep = value
    switch addr.kind !int {
        case compiler::ValueKind::LOCAL:
            map::put(get_stack_frame(state).locals, addr.name, valuep)
        case compiler::ValueKind::GLOBAL:
            let global = map::get(preprocess::compiler_state.result.constants, addr.name) !*compiler::Global
            if not global {
                errorv("Unknown value \"")
                error(value.name, "\"\n")
                return
            }
            global.value = valuep
        case: assert(false)
    }
}

def eval_Load(insn: *compiler::Insn, state: *State) {
    let loc = insn.value.load.loc
    let value = get_value(loc, state)
    set_value(insn.value.load.value, value, state)
}

def eval_Store(insn: *compiler::Insn, state: *State) {
    let loc = insn.value.store.loc
    let value = get_value(insn.value.store.value, state)
    set_value(loc, value, state)
}

def eval_Alloca(insn: *compiler::Insn, state: *State) {
    set_value(insn.value.alloca.ret, compiler::NO_VALUE, state)
}

def eval_Add(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i + right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

// TODO This is slow af with all the string comparisons
// possibly use an integer value even tho that makes codegen slightly more complicated
def eval_Icmp(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.cmp.left, state)
    let right = get_value(insn.value.cmp.right, state)
    let ret = insn.value.cmp.ret
    let op = insn.value.cmp.op

    var result = false
    if op == compiler::i_eq {
        result = left.i == right.i
    } else if op == compiler::i_ne {
        result = left.i != right.i
    } else if op == compiler::i_ugt {
        result = left.i !uint64 > right.i !uint64
    } else if op == compiler::i_uge {
        result = left.i !uint64 >= right.i !uint64
    } else if op == compiler::i_ult {
        result = left.i !uint64 < right.i !uint64
    } else if op == compiler::i_ule {
        result = left.i !uint64 <= right.i !uint64
    } else if op == compiler::i_sgt {
        result = left.i > right.i
    } else if op == compiler::i_sge {
        result = left.i >= right.i
    } else if op == compiler::i_slt {
        result = left.i < right.i
    } else if op == compiler::i_sle {
        result = left.i <= right.i
    } else {
        assert(false)
    }

    set_value(ret, { kind = ValueKind::BOOL, tpe = ret.tpe, i = result !int64 } !compiler::Value, state)
}

def eval_insn(insn: *compiler::Insn, state: *State) {
    switch insn.kind !int {
        case compiler::InsnKind::ADD:
            eval_Add(insn, state)
        case compiler::InsnKind::ICMP:
            eval_Icmp(insn, state)
        case compiler::InsnKind::ALLOCA:
            eval_Alloca(insn, state)
        case compiler::InsnKind::STORE:
            eval_Store(insn, state)
        case compiler::InsnKind::LOAD:
            eval_Load(insn, state)
        case:
            error(insn.kind, "\n") 
            assert(false)
    }
}

def eval_block(block: *compiler::Block, state: *State) {
    state.next = block.next
    for var i in 0..vector::length(block.insn) {
        let insn = vector::get(block.insn, i) !*compiler::Insn
        eval_insn(insn, state)
    }
}

def eval(block: *compiler::Block, state: *State) {
    while block {
        eval_block(block, state)
        block = state.next
    }
}

export def eval(block: *compiler::Block) -> *State {
    let start = block

    let stack_frame = allocate(StackFrame)
    @stack_frame = {
        locals = map::make(),
        function_name = "<inline>"
    }

    let state = allocate(State)
    @state = {
        jump_table = map::make(),
        stack = vector::make()
    } !State

    vector::push(state.stack, stack_frame)

    while block {
        map::put(state.jump_table, block.label_, block)
        block = block.next
    }

    eval(start, state)
    return state
}