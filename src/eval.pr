import vector
import map
import compiler
import typechecking
import preprocess
import scope

export type StackFrame = struct {
    jump_table: *map::Map
    locals: *map::Map
    function_name: string
    ret: compiler::Value
}

export type State = struct {
    cstate: *compiler::State
    globals: *map::Map
    // Map of compiler::Block
    // Vector of StackFrame
    stack: *vector::Vector

    next: *compiler::Block
}

def errorv(msg: string) {
    error("error: [eval] ")
    error(msg)
}

def push_stack_frame(stack_frame: *StackFrame, state: *State) {
    vector::push(state.stack, stack_frame)
}

def pop_stack_frame(state: *State) {
    vector::pop(state.stack)
}

export def get_stack_frame(state: *State) -> *StackFrame {
    return vector::peek(state.stack) !*StackFrame
}

def make_stack_frame(block: *compiler::Block, name: string) -> *StackFrame {
    let stack_frame = allocate(StackFrame)
    @stack_frame = {
        locals = map::make(),
        function_name = name,
        jump_table = map::make()
    } !StackFrame

    while block {
        map::put(stack_frame.jump_table, block.label_, block)
        block = block.next
    }

    return stack_frame
}

def get(mem: *, tpe: *typechecking::Type) -> compiler::Value {
    switch tpe.kind !int {
        case typechecking::TypeKind::WORD:
            let size = tpe.size
            var result: int64 = 0
            for var i in 0..size {
                result |= (@((mem !*uint8) ++ i) !uint64 << (i * 8))
            }
            if not tpe.unsig {
                let sign = (result >> ((size - 1) * 8)) & 0x80
                if sign {
                    for var i in size..(size_of int64) {
                        result |= 0xFF !int64 << (i * 8)
                    }
                }
            }
            return { kind = compiler::ValueKind::INT, tpe = tpe, i = result } !compiler::Value
        case typechecking::TypeKind::FLOAT:
            var result: double
            if tpe.size == (size_of float) {
                result = @(mem !*float) !double
            } else if tpe.size == (size_of double) {
                result = @(mem !*double)
            } else {
                assert(false)
            }
            return { kind = compiler::ValueKind::FLOAT, tpe = tpe, f = result } !compiler::Value
        case typechecking::TypeKind::BOOL:
            return { kind = compiler::ValueKind::BOOL, tpe = tpe, i = (@(mem !*bool)) !int64 } !compiler::Value
        case typechecking::TypeKind::POINTER:
            return { kind = compiler::ValueKind::POINTER, tpe = tpe, i = @(mem !*int64) }
        case: assert(false)
    }
}

export def get_value(loc: compiler::Value, state: *State) -> compiler::Value {
    if loc.kind == compiler::ValueKind::LOCAL {
        let mem = map::get(get_stack_frame(state).locals, loc.name)
        assert(mem != null)
        return get(mem, loc.tpe)
    } else if loc.kind == compiler::ValueKind::GLOBAL {
        assert(typechecking::is_pointer(loc.tpe))
        var mem = map::get(state.globals, loc.name)
        if not mem {
            mem = allocate(loc.tpe.size)
            let global = map::get(state.cstate.result.globals, loc.name) !*compiler::Global
            if global.value {
                set(mem, loc.tpe.tpe, @global.value)
            }
            map::put(state.globals, loc.name, mem)
        }
        return { kind = compiler::ValueKind::POINTER, tpe = loc.tpe, i = mem !int64 }
    } else {
        return loc
    }
}

def set(mem: *, tpe: *typechecking::Type, value: compiler::Value) {
    switch tpe.kind !int {
        case typechecking::TypeKind::WORD:
            var v = value.i
            let size = tpe.size
            for var i in 0..size {
                @(mem !*uint8 ++ i) = (v >> (i * 8)) !uint8
            }
        case typechecking::TypeKind::FLOAT:
            if tpe.size == (size_of float) {
                @(mem !*float) = value.f !float
            } else if tpe.size == (size_of double) {
                @(mem !*double) = value.f
            } else {
                assert(false)
            }
        case typechecking::TypeKind::POINTER:
            (@(mem !*int64)) = value.i
        case typechecking::TypeKind::BOOL:
            (@(mem !*int8)) = value.i !int8
        case: assert(false)
    }
}

export def set_value(loc: compiler::Value, value: compiler::Value, state: *State) {
    if loc.kind == compiler::ValueKind::LOCAL {
        var mem = map::get(get_stack_frame(state).locals, loc.name)
        if not mem {
            mem = allocate(loc.tpe.size)
            map::put(get_stack_frame(state).locals, loc.name, mem)
        }
        set(mem, loc.tpe, value)
    } else {
        assert(false)
    }
}

def eval_Convert(insn: *compiler::Insn, state: *State) {
    // This is basically a noop
    let ret = insn.value.convert.ret
    let value = get_value(insn.value.convert.value, state)
    set_value(ret, value, state)
}

def eval_Load(insn: *compiler::Insn, state: *State) {
    let loc = insn.value.load.loc
    let mem = get_value(loc, state).i !*
    set_value(insn.value.load.value, get(mem, loc.tpe.tpe), state)
}

def eval_Store(insn: *compiler::Insn, state: *State) {
    let loc = insn.value.store.loc
    let mem = get_value(loc, state).i !*
    let value = get_value(insn.value.store.value, state)
    set(mem, value.tpe, value)
}

def eval_Alloca(insn: *compiler::Insn, state: *State) {
    let ret = insn.value.alloca.ret
    ret.tpe = typechecking::pointer(ret.tpe)
    let mem = allocate(ret.tpe.size)
    let ptr = { kind = compiler::ValueKind::POINTER, tpe = ret.tpe, i = mem !int64 } !compiler::Value
    set_value(ret, ptr, state)
}

def eval_FAdd(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret 

    var result = left.f + right.f
    set_value(ret, { kind = ValueKind::FLOAT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_FSub(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret 

    var result = left.f - right.f
    set_value(ret, { kind = ValueKind::FLOAT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_FMul(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret 

    var result = left.f * right.f
    set_value(ret, { kind = ValueKind::FLOAT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_FRem(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret 

    var result = left.f % right.f
    set_value(ret, { kind = ValueKind::FLOAT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_FDiv(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret 

    var result = left.f / right.f
    set_value(ret, { kind = ValueKind::FLOAT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_FAdd(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret 

    var result = left.f + right.f
    set_value(ret, { kind = ValueKind::FLOAT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_SRem(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i % right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_URem(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = (left.i !uint64 % right.i !uint64) !int64
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_Add(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i + right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_Sub(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i - right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_And(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = (left.i !bool and right.i !bool) !int64
    set_value(ret, { kind = ValueKind::BOOL, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_Mul(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i * right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_SDiv(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i / right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_UDiv(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i !uint64 / right.i !uint64
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_Icmp(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.icmp.left, state)
    let right = get_value(insn.value.icmp.right, state)
    let ret = insn.value.icmp.ret
    let op = insn.value.icmp.op

    var result = false
    if op == compiler::CompareInt::eq {
        result = left.i == right.i
    } else if op == compiler::CompareInt::ne {
        result = left.i != right.i
    } else if op == compiler::CompareInt::ugt {
        result = left.i !uint64 > right.i !uint64
    } else if op == compiler::CompareInt::uge {
        result = left.i !uint64 >= right.i !uint64
    } else if op == compiler::CompareInt::ult {
        result = left.i !uint64 < right.i !uint64
    } else if op == compiler::CompareInt::ule {
        result = left.i !uint64 <= right.i !uint64
    } else if op == compiler::CompareInt::sgt {
        result = left.i > right.i
    } else if op == compiler::CompareInt::sge {
        result = left.i >= right.i
    } else if op == compiler::CompareInt::slt {
        result = left.i < right.i
    } else if op == compiler::CompareInt::sle {
        result = left.i <= right.i
    } else {
        assert(false)
    }

    set_value(ret, { kind = ValueKind::BOOL, tpe = ret.tpe, i = result !int64 } !compiler::Value, state)
}

def eval_Call(insn: *compiler::Insn, state: *State) {
    let name = insn.value.call.name.name 
    let args = insn.value.call.args
    let ret = insn.value.call.ret

    let function = map::get(state.cstate.result.functions, name) !*compiler::Function
    if not function {
        errorv("Function \"")
        error(name, "\" not found\n")
        return
    }

    let stack_frame = make_stack_frame(function.block, name)

    for var i in 0..args.size {
        let arg = args[i]
        let np = vector::get(function.args, i) !*typechecking::NamedParameter
        let arg_value = get_value(arg, state)
        let mem = allocate(arg.tpe.size)
        map::put(stack_frame.locals, np.name, mem)
        set(mem, arg.tpe, arg_value)
    }

    push_stack_frame(stack_frame, state)
    eval(function.block, state)
    let ret_value = get_value(stack_frame.ret, state)
    pop_stack_frame(state)

    set_value(ret, ret_value, state)
}

def eval_Ret(insn: *compiler::Insn, state: *State) {
    let ret = insn.value.ret.value
    get_stack_frame(state).ret = get_value(ret, state)
    state.next = null
}

def eval_BrUnc(insn: *compiler::Insn, state: *State) {
    let label_ = insn.value.br_unc.label_
    state.next = map::get(get_stack_frame(state).jump_table, label_.name) !*compiler::Block
}

def eval_Br(insn: *compiler::Insn, state: *State) {
    let if_true = insn.value.br.if_true
    let if_false = insn.value.br.if_false
    
    let cond = get_value(insn.value.br.cond, state)
    assert(cond.kind == compiler::ValueKind::BOOL)
    
    if cond.i {
        state.next = map::get(get_stack_frame(state).jump_table, if_true.name) !*compiler::Block
    } else {
        state.next = map::get(get_stack_frame(state).jump_table, if_false.name) !*compiler::Block
    }
}

def eval_Fptoui(insn: *compiler::Insn, state: *State) {
    let ret = insn.value.convert.ret
    let value = get_value(insn.value.convert.value, state)
    let result = (value.f !uint64) !int64
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_Fptosi(insn: *compiler::Insn, state: *State) {
    let ret = insn.value.convert.ret
    let value = get_value(insn.value.convert.value, state)
    let result = value.f !int64
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_Uitofp(insn: *compiler::Insn, state: *State) {
    let ret = insn.value.convert.ret
    let value = get_value(insn.value.convert.value, state)
    let result = (value.i !uint64) !double
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_Sitofp(insn: *compiler::Insn, state: *State) {
    let ret = insn.value.convert.ret
    let value = get_value(insn.value.convert.value, state)
    let result = value.i !double
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_insn(insn: *compiler::Insn, state: *State) {
    switch insn.kind !int {
        case compiler::InsnKind::TRUNC, compiler::InsnKind::SEXT, compiler::InsnKind::FPTRUNC, compiler::InsnKind::FPEXT:
            eval_Convert(insn, state)
        case compiler::InsnKind::FPTOUI:
            eval_Fptoui(insn, state)
        case compiler::InsnKind::FPTOSI:
            eval_Fptosi(insn, state)
        case compiler::InsnKind::UITOFP:
            eval_Uitofp(insn, state)
        case compiler::InsnKind::SITOFP:
            eval_Sitofp(insn, state)
        case compiler::InsnKind::SREM:
            eval_SRem(insn, state)
        case compiler::InsnKind::UREM:
            eval_URem(insn, state)
        case compiler::InsnKind::AND:
            eval_And(insn, state)
        case compiler::InsnKind::ADD:
            eval_Add(insn, state)
        case compiler::InsnKind::SUB:
            eval_Sub(insn, state)
        case compiler::InsnKind::MUL:
            eval_Mul(insn, state)
        case compiler::InsnKind::SDIV:
            eval_SDiv(insn, state)
        case compiler::InsnKind::UDIV:
            eval_UDiv(insn, state)
        case compiler::InsnKind::FADD:
            eval_FAdd(insn, state)
        case compiler::InsnKind::FSUB:
            eval_FSub(insn, state) 
        case compiler::InsnKind::FMUL:
            eval_FMul(insn, state)
        case compiler::InsnKind::FREM:
            eval_FRem(insn, state)
        case compiler::InsnKind::FDIV:
            eval_FDiv(insn, state)
        case compiler::InsnKind::ICMP:
            eval_Icmp(insn, state)
        case compiler::InsnKind::ALLOCA:
            eval_Alloca(insn, state)
        case compiler::InsnKind::STORE:
            eval_Store(insn, state)
        case compiler::InsnKind::LOAD:
            eval_Load(insn, state)
        case compiler::InsnKind::CALL:
            eval_Call(insn, state)
        case compiler::InsnKind::RET:
            eval_Ret(insn, state)
        case compiler::InsnKind::BR_UNC:
            eval_BrUnc(insn, state)
        case compiler::InsnKind::BR:
            eval_Br(insn, state)
        case:
            error(insn.kind, "\n") 
            assert(false)
    }
}

def eval_block(block: *compiler::Block, state: *State) {
    /*for var i in 0..vector::length(block.insn) {
        let insn = vector::get(block.insn, i) !*compiler::Insn
        print(insn.kind, "\n")
    }
    print("\n")*/

    state.next = block.next
    for var i in 0..vector::length(block.insn) {
        let insn = vector::get(block.insn, i) !*compiler::Insn
        eval_insn(insn, state)
    }
}

def eval(block: *compiler::Block, state: *State) {
    while block {
        eval_block(block, state)
        block = state.next
    }
}

export def eval(cstate: *compiler::State) -> *State {
    var block = cstate.current_function.block
    vector::insert(block.insn, 0, cstate.current_function.allocas)

    let stack_frame = make_stack_frame(block, "<inline>")

    let state = allocate(State)
    @state = {
        cstate = cstate,
        globals = map::make(),
        stack = vector::make()
    } !State

    vector::push(state.stack, stack_frame)

    eval(block, state)

    let global_keys = map::keys(state.globals)
    for var i in 0..global_keys.size {
        let key = global_keys[i]
        let mem = map::get(state.globals, key)
        let global = map::get(state.cstate.result.globals, key) !*compiler::Global
        let valuep = allocate(compiler::Value)
        @valuep = get(mem, global.tpe)
        global.value = valuep
    }

    return state
}