import buffer
import vector
import map
import util
import compiler
import typechecking
import scope
import builtins
import preprocess
import toolchain
import debug
import errors

export type StackFrame = struct {
    next: *compiler::Block
    jump_table: *map::Map
    locals: *map::Map
    function_name: string
    line: int
    ret: compiler::Value
}

export type State = struct {
    cstate: *compiler::State
    // Vector of StackFrame
    stack: *vector::Vector
}

type FfiFunction = struct {
    name: string
    ptr: ->
    initialized: bool
    ffi_cif: cstd::ffi_cif
}

type FfiGlobal = struct {
    name: string
    ptr: *
}

export type FunctionPtr = struct {
    is_fp: bool
    struct #union {
        fp: ->
        function: *compiler::Function
    }
}

// Map of FfiVariable
var FFI_GLOBALS = map::make()
// Map of FfiFunction
var FFI_FUNCTIONS = map::make()
load_ffi(cstd::__DEF_NAMES, cstd::__DEFS, cstd::__VAR_NAMES, cstd::__VARS)

export def load_ffi(def_names: [string], defs: [type () -> ()], var_names: [string], vars: [*]) {
    assert(def_names.size == defs.size)
    for var i in 0..def_names.size {
        let name = def_names[i]
        let value = defs[i]
        let ffi_function = allocate(FfiFunction)
        @ffi_function = {
            name = name,
            ptr = value,
            initialized = false
        } !FfiFunction
        map::put(FFI_FUNCTIONS, name, ffi_function)

        let ffi_global = allocate(FfiGlobal)
        @ffi_global = {
            name = name,
            ptr = value !*
        } !FfiGlobal
        map::put(FFI_GLOBALS, name, ffi_global)
    }

    assert(var_names.size == vars.size)
    for var i in 0..var_names.size {
        let name = var_names[i]
        let value = vars[i]
        let ffi_global = allocate(FfiGlobal)
        @ffi_global = {
            name = name,
            ptr = value
        } !FfiGlobal
        map::put(FFI_GLOBALS, name, ffi_global)
    }
}

export def push_stack_frame(stack_frame: *StackFrame, state: *State) {
    vector::push(state.stack, stack_frame)
}

export def pop_stack_frame(state: *State) {
    vector::pop(state.stack)
}

export def get_stack_frame(state: *State) -> *StackFrame {
    return vector::peek(state.stack) !*StackFrame
}

export def make_stack_frame(block: *compiler::Block, name: string, line: int) -> *StackFrame {
    let stack_frame = allocate(StackFrame)
    @stack_frame = {
        locals = map::make(),
        function_name = name,
        line = line,
        jump_table = map::make()
    } !StackFrame

    while block {
        map::put(stack_frame.jump_table, block.label_, block)
        block = block.next
    }

    return stack_frame
}

export def get(mem: *, tpe: *typechecking::Type) -> compiler::Value {
    if not mem { return NO_VALUE }
    switch tpe.kind !int {
        case typechecking::TypeKind::WORD:
            let size = tpe.size
            var result: int64 = 0
            for var i in 0..size {
                result |= (@((mem !*uint8) ++ i) !uint64 << (i * 8))
            }
            if not tpe.unsig {
                let sign = (result >> ((size - 1) * 8)) & 0x80
                if sign {
                    for var i in size..(size_of int64) {
                        result |= 0xFF !int64 << (i * 8)
                    }
                }
            }
            return { kind = compiler::ValueKind::INT, tpe = tpe, i = result } !compiler::Value
        case typechecking::TypeKind::FLOAT:
            var result: double
            if tpe.size == (size_of float) {
                result = @(mem !*float) !double
            } else if tpe.size == (size_of double) {
                result = @(mem !*double)
            } else {
                assert(false)
            }
            return { kind = compiler::ValueKind::FLOAT, tpe = tpe, f = result } !compiler::Value
        case typechecking::TypeKind::BOOL:
            return { kind = compiler::ValueKind::BOOL, tpe = tpe, i = (@(mem !*bool)) !int64 } !compiler::Value
        case typechecking::TypeKind::POINTER:
            return { kind = compiler::ValueKind::POINTER, tpe = tpe, i = @(mem !*int64) } !compiler::Value
        case typechecking::TypeKind::UNION:
            let field = tpe.biggest_field
            let values = allocate(compiler::Value, 1)
            values[0] = get(mem, field.tpe)
            return { kind = compiler::ValueKind::STRUCT, tpe = tpe, values = values } !compiler::Value
        case typechecking::TypeKind::STRUCT:
            let values = allocate(compiler::Value, tpe.fields.size)
            for var i in 0..tpe.fields.size {
                let field = tpe.fields[i]
                values[i] = get(mem ++ field.offset, field.tpe)
            }
            return { kind = compiler::ValueKind::STRUCT, tpe = tpe, values = values } !compiler::Value
        case typechecking::TypeKind::STATIC_ARRAY:
            if typechecking::equals(tpe.tpe, builtins::char_) {
                let str = allocate(char, tpe.size)
                memcopy(mem, str.value, tpe.size)
                return { kind = compiler::ValueKind::STRING, tpe = tpe, s = str } !compiler::Value
            } else {
                let values = allocate(compiler::Value, tpe.size / tpe.tpe.size)
                for var i in 0..values.size {
                    values[i] = get(mem, tpe.tpe)
                    mem = mem ++ tpe.tpe.size
                }
                return { kind = compiler::ValueKind::ARRAY, tpe = tpe, values = values } !compiler::Value
            }
        case typechecking::TypeKind::ARRAY:
            let values = allocate(compiler::Value, 2)
            values[0] = { kind = compiler::ValueKind::INT, tpe = builtins::size_t_, i = @(mem !*int64) } !compiler::Value
            values[1] = { kind = compiler::ValueKind::POINTER, tpe = typechecking::pointer(tpe.tpe), i = @((mem ++ (size_of size_t)) !*int64) } !compiler::Value
            return { kind = compiler::ValueKind::STRUCT, tpe = tpe, values = values } !compiler::Value
        case typechecking::TypeKind::FUNCTION:
            return { kind = compiler::ValueKind::FUNCTION, tpe = tpe, function = mem !*FunctionPtr } !compiler::Value
        case typechecking::TypeKind::ENUM:
            let value = get(mem, tpe.tpe)
            value.tpe = tpe
            return value
        case: assert(false)
    }
}

export def get_address(loc: compiler::Value, state: *State) -> * {
    if loc.kind == compiler::ValueKind::LOCAL {
        let mem = map::get(get_stack_frame(state).locals, loc.name)
        return mem
    } else if loc.kind == compiler::ValueKind::GLOBAL {
        assert(typechecking::is_pointer(loc.tpe))
        var mem = map::get(state.cstate.globals, loc.name)
        if not mem {
            var ptr: *

            let function = map::get(state.cstate.result.functions, loc.name) !*compiler::Function
            if function {
                ptr = allocate(FunctionPtr)
                (ptr !*FunctionPtr).function = function
                set(ptr, loc.tpe.tpe, { kind = compiler::ValueKind::FUNCTION, tpe = loc.tpe.tpe, function = (ptr !*FunctionPtr) } !compiler::Value)
            } else {
                let ffi_global = map::get(FFI_GLOBALS, loc.name) !*FfiGlobal
                if ffi_global {
                    ptr = ffi_global.ptr
                } else {
                    var global = map::get(preprocess::compiler_state.module.result.globals, loc.name) !*compiler::Global
                    if not global {
                        global = map::get(state.cstate.result.globals, loc.name) !*compiler::Global
                    }
                    if not global {
                        errors::errorv("Global by the name of `", loc.name, "` not found")
                        return null
                    } else {
                        ptr = allocate(loc.tpe.tpe.size)
                        if global.value {
                            set(ptr, loc.tpe.tpe, @global.value)
                        }
                    }
                }
            }

            mem = allocate(loc.tpe.size)
            let value = { kind = compiler::ValueKind::POINTER, tpe = loc.tpe, i = ptr !int64 } !compiler::Value
            set(mem, loc.tpe, value)
            map::put(state.cstate.globals, loc.name, mem)
        }
        return mem
    }
    return null
}

export def get_value(loc: compiler::Value, state: *State) -> compiler::Value {
    if loc.kind == compiler::ValueKind::LOCAL or loc.kind == compiler::ValueKind::GLOBAL {
        let mem = get_address(loc, state)
        return get(mem, loc.tpe)
    } else {
        return loc
    }
}

def set(mem: *, tpe: *typechecking::Type, value: compiler::Value) {
    if not mem { 
        errors::errorv("Tried to assign a null pointer")
        return
    }
    if not tpe { return }
    if value.kind == compiler::ValueKind::UNDEF { return }
    if value.kind == compiler::ValueKind::ZEROINITIALIZER {
        cstd::memset(mem, 0, tpe.size)
        return
    }
    switch tpe.kind !int {
        case typechecking::TypeKind::WORD:
            var v = value.i
            let size = tpe.size
            for var i in 0..size {
                @(mem !*uint8 ++ i) = (v >> (i * 8)) !uint8
            }
        case typechecking::TypeKind::FLOAT:
            if tpe.size == (size_of float) {
                @(mem !*float) = value.f !float
            } else if tpe.size == (size_of double) {
                @(mem !*double) = value.f
            } else {
                assert(false)
            }
        case typechecking::TypeKind::POINTER:
            (@(mem !*int64)) = value.i
        case typechecking::TypeKind::BOOL:
            (@(mem !*int8)) = value.i !int8
        case typechecking::TypeKind::STRUCT:
            for var i in 0..tpe.fields.size {
                let field = tpe.fields[i]
                set(mem ++ field.offset, field.tpe, value.values[i])
            }
        case typechecking::TypeKind::UNION:
            let v = value.values[0]
            set(mem, v.tpe, v)
        case typechecking::TypeKind::STATIC_ARRAY:
            if typechecking::equals(tpe.tpe, builtins::char_) and value.kind == compiler::ValueKind::STRING {
                memcopy(value.s.value, mem, tpe.length)
            } else {
                for var i in 0..value.values.size {
                    let value = value.values[i]
                    set(mem, tpe.tpe, value)
                    mem = mem ++ tpe.tpe.size
                }
            }
        case typechecking::TypeKind::ARRAY:
            // TODO Implementation specific
            @(mem !*size_t) = value.values[0].i !size_t
            @((mem ++ (size_of size_t)) !*int64) = value.values[1].i
        case typechecking::TypeKind::FUNCTION:
            @(mem !*FunctionPtr) = @value.function
        case typechecking::TypeKind::ENUM:
            set(mem, tpe.tpe, value)
        case:
            error(tpe.kind, "\n") 
            assert(false)
    }
}

export def set_value(loc: compiler::Value, value: compiler::Value, state: *State) {
    if loc.kind == compiler::ValueKind::LOCAL {
        var mem = map::get(get_stack_frame(state).locals, loc.name)
        if not mem {
            // TODO This shouldn't need to be initialized, we seem to have a bug elsewhere
            mem = zero_allocate(loc.tpe.size)
            map::put(get_stack_frame(state).locals, loc.name, mem)
        }
        set(mem, loc.tpe, value)
    } else if loc.kind == compiler::ValueKind::GLOBAL {
        var mem = map::get(state.cstate.globals, loc.name)
        var ptr: * = null
        if not mem {
            mem = allocate(loc.tpe.size)
            map::put(state.cstate.globals, loc.name, mem)
            ptr = allocate(loc.tpe.tpe.size)
            set(mem, loc.tpe, { kind = compiler::ValueKind::POINTER, tpe = loc.tpe, i = ptr !int64 } !compiler::Value)
        } else {
            ptr = get(mem, loc.tpe).i !*
        }
        set(ptr, loc.tpe.tpe, value)
    } else {
        assert(false)
    }
}

def unwrap_undef(value: compiler::Value) -> compiler::Value {
    if value.kind == compiler::ValueKind::UNDEF {
        if value.tpe.kind == typechecking::TypeKind::STRUCT {
            let values = allocate(compiler::Value, value.tpe.fields.size)
            for var i in 0..value.tpe.fields.size {
                let field = value.tpe.fields[i]
                values[i] = unwrap_undef({ kind = compiler::ValueKind::UNDEF, tpe = field.tpe } !compiler::Value)
            }
            value = { kind = compiler::ValueKind::STRUCT, tpe = value.tpe, values = values } !compiler::Value
        } else if value.tpe.kind == typechecking::TypeKind::UNION {
            let values = allocate(compiler::Value, 1)
            values[0] = unwrap_undef({ kind = compiler::ValueKind::UNDEF, tpe = value.tpe.biggest_field.tpe } !compiler::Value)
            value = { kind = compiler::ValueKind::STRUCT, tpe = value.tpe, values = values } !compiler::Value
        } else if value.tpe.kind == typechecking::TypeKind::ARRAY {
            let values = allocate(compiler::Value, 2)
            values[0] = { kind = compiler::ValueKind::UNDEF, tpe = builtins::size_t_ } !compiler::Value
            values[1] = { kind = compiler::ValueKind::UNDEF, tpe = value.tpe.tpe } !compiler::Value
            value = { kind = compiler::ValueKind::ARRAY, tpe = value.tpe, values = values } !compiler::Value
        }
    }
    return value
}

def eval_InsertValue(insn: *compiler::Insn, state: *State) {
    // We need a deep copy here because we don't want to modify the operand,
    // if we didn't do this, the operation would fail when executed multiple times
    let value = unwrap_undef(compiler::copy(get_value(insn.value.insert_value.value, state)))
    let element = get_value(insn.value.insert_value.element, state)
    let ret = insn.value.insert_value.ret
    let index = insn.value.insert_value.index

    var to_set = *value
    for var i in 0..index.size {
        let j = index[i]
        if typechecking::is_struct(to_set.tpe) or to_set.tpe.kind == typechecking::TypeKind::ARRAY {
            to_set = *value.values[j]
        } else if to_set.tpe.kind == typechecking::TypeKind::STATIC_ARRAY {
            if typechecking::equals(to_set.tpe.tpe, builtins::char_) {
                to_set.s[j] = element.i !char
            } else {
                to_set = *value.values[j]
            }
        } else {
            assert(false)
        }
    }
    @to_set = element

    set_value(ret, value, state)
}

def eval_ExtractValue(insn: *compiler::Insn, state: *State) {
    let value = get_value(insn.value.extract_value.value, state)
    let ret = insn.value.extract_value.ret
    let index = insn.value.extract_value.index

    var to_get = value
    for var i in 0..index.size {
        let j = index[i]
        if typechecking::is_struct(to_get.tpe) or to_get.tpe.kind == typechecking::TypeKind::ARRAY {
            to_get = to_get.values[j]
        } else if to_get.tpe.kind == typechecking::TypeKind::STATIC_ARRAY {
            if typechecking::equals(to_get.tpe.tpe, builtins::char_) {
                to_get = { kind = compiler::ValueKind::INT, tpe = builtins::char_, i = to_get.s[j] !int64 } !compiler::Value
            } else {
                to_get = to_get.values[j]
            }
        } else {
            assert(false)
        }
    }

    set_value(ret, to_get, state)
}

def eval_GetElementPtr(insn: *compiler::Insn, state: *State) {
    let ret = insn.value.gep.ret
    let value = insn.value.gep.value
    let index = insn.value.gep.index

    var tpe =  insn.value.gep.tpe
    var addr = get(get_address(value, state), value.tpe).i !* ++ (get_value(index[0], state).i * tpe.size)

    for var i in 1..index.size {
        let index = get_value(index[i], state).i
        if tpe.kind == typechecking::TypeKind::STRUCT {
            assert(index < tpe.fields.size)
            let field = tpe.fields[index]
            addr = addr ++ field.offset
            tpe = field.tpe
        } else if tpe.kind == typechecking::TypeKind::UNION {
            assert(index == 0)
            tpe = tpe.fields[0].tpe
        } else if tpe.kind == typechecking::TypeKind::STATIC_ARRAY {
            assert(index < tpe.length)
            addr = addr ++ tpe.tpe.size * index
            tpe = tpe.tpe
        } else if tpe.kind == typechecking::TypeKind::ARRAY {
            if index == 0 {
                tpe = builtins::size_t_
            } else if index == 1 {
                addr = addr ++ (size_of size_t)
                tpe = tpe.tpe
            } else {
                assert(false)
            }
        } else {
            assert(false)
        }
    }

    //assert(ret.kind == compiler::ValueKind::LOCAL)
    //map::put(get_stack_frame(state).locals, ret.name, addr)
    set_value(ret, { kind = compiler::ValueKind::POINTER, tpe = typechecking::pointer(tpe), i = addr !int64 } !compiler::Value, state)
}

def eval_Convert(insn: *compiler::Insn, state: *State) {
    // This is basically a noop
    let ret = insn.value.convert.ret
    let value = get_value(insn.value.convert.value, state)
    set_value(ret, value, state)
}

// TODO These functions should be made faster by directly working with the memory
def eval_Load(insn: *compiler::Insn, state: *State) {
    let loc = insn.value.load.loc
    let mem = get_address(loc, state)
    let ptr = get(mem, loc.tpe).i !*
    let value = get(ptr, loc.tpe.tpe)
    set_value(insn.value.load.value, value, state)
}

def eval_Store(insn: *compiler::Insn, state: *State) {
    let loc = insn.value.store.loc
    let mem = get_address(loc, state)
    let ptr = get(mem, loc.tpe).i !*
    let value = get_value(insn.value.store.value, state)
    set(ptr, value.tpe, value)
}

def eval_Alloca(insn: *compiler::Insn, state: *State) {
    let ret = insn.value.alloca.ret
    let mem = zero_allocate(ret.tpe.size) // TODO: We shouldn't have to initalize this
    ret.tpe = typechecking::pointer(ret.tpe)
    let ptr = { kind = compiler::ValueKind::POINTER, tpe = ret.tpe, i = mem !int64 } !compiler::Value
    let addr = allocate(ret.tpe.size)
    map::put(get_stack_frame(state).locals, ret.name, addr)
    set(addr, ret.tpe, ptr)
}

def eval_FAdd(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret 

    var result = left.f + right.f
    set_value(ret, { kind = ValueKind::FLOAT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_FSub(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret 

    var result = left.f - right.f
    set_value(ret, { kind = ValueKind::FLOAT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_FMul(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret 

    var result = left.f * right.f
    set_value(ret, { kind = ValueKind::FLOAT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_FRem(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret 

    var result = left.f % right.f
    set_value(ret, { kind = ValueKind::FLOAT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_FDiv(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret 

    var result = left.f / right.f
    set_value(ret, { kind = ValueKind::FLOAT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_FNeg(insn: *compiler::Insn, state: *State) {
    let value = get_value(insn.value.fneg.value, state)
    let ret = insn.value.fneg.ret 

    var result = -value.f
    set_value(ret, { kind = ValueKind::FLOAT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_SRem(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i % right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_URem(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = (left.i !uint64 % right.i !uint64) !int64
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_Add(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i + right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_Sub(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i - right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_AShr(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i >> right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_LShr(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = (left.i !uint64 >> right.i) !int64
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_Shl(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i << right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_And(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i & right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_Or(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i | right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_XOr(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i ^ right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}


def eval_Mul(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i * right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_SDiv(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i / right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_UDiv(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i !uint64 / right.i !uint64
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_ICmp(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.icmp.left, state)
    let right = get_value(insn.value.icmp.right, state)
    let ret = insn.value.icmp.ret
    let op = insn.value.icmp.op

    var result = false
    if op == compiler::CompareInt::eq {
        result = left.i == right.i
    } else if op == compiler::CompareInt::ne {
        result = left.i != right.i
    } else if op == compiler::CompareInt::ugt {
        result = left.i !uint64 > right.i !uint64
    } else if op == compiler::CompareInt::uge {
        result = left.i !uint64 >= right.i !uint64
    } else if op == compiler::CompareInt::ult {
        result = left.i !uint64 < right.i !uint64
    } else if op == compiler::CompareInt::ule {
        result = left.i !uint64 <= right.i !uint64
    } else if op == compiler::CompareInt::sgt {
        result = left.i > right.i
    } else if op == compiler::CompareInt::sge {
        result = left.i >= right.i
    } else if op == compiler::CompareInt::slt {
        result = left.i < right.i
    } else if op == compiler::CompareInt::sle {
        result = left.i <= right.i
    } else {
        assert(false)
    }

    set_value(ret, { kind = ValueKind::BOOL, tpe = ret.tpe, i = result !int64 } !compiler::Value, state)
}

def eval_FCmp(insn: *compiler::Insn, state: *State) {
    let left = get_value(insn.value.fcmp.left, state)
    let right = get_value(insn.value.fcmp.right, state)
    let ret = insn.value.fcmp.ret
    let op = insn.value.fcmp.op

    var result = false
    if op == compiler::CompareFloat::ueq {
        result = left.f == right.f
    } else if op == compiler::CompareFloat::une {
        result = left.f != right.f
    } else if op == compiler::CompareFloat::ugt {
        result = left.f > right.f
    } else if op == compiler::CompareFloat::uge {
        result = left.f >= right.f
    } else if op == compiler::CompareFloat::ult {
        result = left.f < right.f
    } else if op == compiler::CompareFloat::ule {
        result = left.f <= right.f
    } else {
        assert(false)
    }

    set_value(ret, { kind = ValueKind::BOOL, tpe = ret.tpe, i = result !int64 } !compiler::Value, state)
}

// TODO
def struct_to_ffi(tpe: *typechecking::Type) -> *cstd::ffi_type {
    assert(false)
    return null
}

def union_to_ffi(tpe: *typechecking::Type) -> *cstd::ffi_type {
    assert(false)
    return null
}

def type_to_ffi(tpe: *typechecking::Type) -> *cstd::ffi_type {
    if not tpe {
        return *cstd::ffi_type_void
    } else if tpe.kind == typechecking::TypeKind::STRUCT {
        return struct_to_ffi(tpe)
    } else if tpe.kind == typechecking::TypeKind::UNION {
        return union_to_ffi(tpe)
    } else if typechecking::is_enum(tpe) {
        return type_to_ffi(tpe.tpe)
    } else if typechecking::is_pointer(tpe) {
        return *cstd::ffi_type_pointer
    } else if typechecking::equals(tpe, builtins::int8_) {
        return *cstd::ffi_type_sint8
    } else if typechecking::equals(tpe, builtins::uint8_) {
        return *cstd::ffi_type_uint8
    } else if typechecking::equals(tpe, builtins::int16_) {
        return *cstd::ffi_type_sint16
    } else if typechecking::equals(tpe, builtins::uint16_) {
        return *cstd::ffi_type_uint16
    } else if typechecking::equals(tpe, builtins::int32_) {
        return *cstd::ffi_type_sint32
    } else if typechecking::equals(tpe, builtins::uint32_) {
        return *cstd::ffi_type_uint32
    } else if typechecking::equals(tpe, builtins::int64_) {
        return *cstd::ffi_type_sint64
    } else if typechecking::equals(tpe, builtins::uint64_) {
        return *cstd::ffi_type_uint64
    } else if typechecking::equals(tpe, builtins::float_) {
        return *cstd::ffi_type_float
    } else if typechecking::equals(tpe, builtins::double_) {
        return *cstd::ffi_type_double
    } else if typechecking::equals(tpe, builtins::bool_) {
        return *cstd::ffi_type_sint8
    } else {
        error(debug::type_to_str(tpe), "\n")
        assert(false)
    }
}

def ffi_call(args: [compiler::Value], ret: compiler::Value, parameter_t: *vector::Vector, ret_tpe: *typechecking::Type, ffi_function: *FfiFunction, varargs: bool, state: *State) {
    let ffi_cif = *ffi_function.ffi_cif

    let ffi_args = allocate((size_of type *cstd::ffi_type) * args.size) !**cstd::ffi_type
    for var i in 0..args.size {
        ffi_args[i] = type_to_ffi(args[i].tpe)
    }

    var status: cstd::ffi_status = cstd::ffi_status::FFI_OK
    if varargs {
        status = cstd::ffi_prep_cif_var(ffi_cif, cstd::ffi_abi::FFI_DEFAULT_ABI, (vector::length(parameter_t) - 1) !uint, args.size !uint, type_to_ffi(ret_tpe), ffi_args)
    } else if not ffi_function.initialized {
        status = cstd::ffi_prep_cif(ffi_cif, cstd::ffi_abi::FFI_DEFAULT_ABI, args.size !uint, type_to_ffi(ret_tpe), ffi_args)
        ffi_function.initialized = true
    }
    if status != cstd::ffi_status::FFI_OK {
        errors::errorv("Failed to prepare ffi for function `", ffi_function.name, "`. Status: ", status.to_string())
        return
    }

    let avalues = allocate((size_of type *) * args.size) !**
    for var i in 0..args.size {
        let arg = args[i]
        var mem: * = null
        if arg.kind == compiler::ValueKind::LOCAL or arg.kind == compiler::ValueKind::GLOBAL {
            mem = get_address(arg, state)
        } else {
            // We need to allocate memory for static values
            mem = allocate(arg.tpe.size)
            set(mem, arg.tpe, arg)
        }
        avalues[i] = mem
    } 

    var rvalue: * = null
    if ret.tpe {
        // TODO Define the register size somewhere
        var size = 8 !size_t
        if ret_tpe.size > size {
            size = ret_tpe.size
        }
        rvalue = allocate(size)
        // TODO This will fail for function pointers
        map::put(get_stack_frame(state).locals, ret.name, rvalue)
    }
    
    cstd::ffi_call(ffi_cif, ffi_function.ptr, rvalue, avalues)
}

def eval_Call(insn: *compiler::Insn, state: *State) {
    let call = insn.value.call.name 
    let args = insn.value.call.args
    let ret = insn.value.call.ret
   
    var name = call.name
    var fp: *FunctionPtr = null

    if call.kind == compiler::ValueKind::LOCAL {
        let mem = get_address(call, state)
        let value = get(get(mem, call.tpe).i !*, call.tpe.tpe)
        fp = value.function
    } else if call.kind == compiler::ValueKind::GLOBAL {
        if starts_with(name, "llvm.") { return }
        let function = map::get(state.cstate.result.functions, name) !*compiler::Function
        if function {
            let functionptr = { is_fp = false } !FunctionPtr
            functionptr.function = function
            fp = *functionptr
        } else {
            let mem = get_address(call, state)
            let value = get(get(mem, call.tpe).i !*, call.tpe.tpe)
            fp = value.function
        }
    }

    if not fp {
        errors::errorv("Function `", name, "` not found")
        return
    }

    /*print(name, " ")
    for var i in 0..args.size {
        print(debug::type_to_str(args[i].tpe), " ")
    }
    print("\n")*/

    if fp.is_fp {
        let ffi_function = {
            name = name,
            ptr = fp.fp
        } !FfiFunction

        var varargs = false
        var ret_tpe: *typechecking::Type = null
        if vector::length(call.tpe.return_t) >= 1 {
            ret_tpe = vector::get(call.tpe.return_t, 0) !*typechecking::Type
        }
        let last_arg = vector::peek(call.tpe.parameter_t) !*typechecking::NamedParameter
        if last_arg {
            varargs = last_arg.varargs
        }
        ffi_call(args, ret, call.tpe.parameter_t, ret_tpe, *ffi_function, varargs, state)
    } else {
        let function = fp.function
        if function.imported {
            let ffi_function = map::get(FFI_FUNCTIONS, name) !*FfiFunction
            
            ffi_call(args, ret, function.args, function.ret, ffi_function, function.varargs, state)
        } else {
            let result = state.cstate.result
            state.cstate.result = function.module.result

            var line = 1
            if insn.debug {
                // TODO This points to another file
                let debug_value = map::get(function.module.result.metadata, insn.debug.name) !*compiler::Value
                if debug_value and debug_value.debug_values.value {
                    line = debug_value.debug_values[0].value.i !int 
                }
            }

            let stack_frame = make_stack_frame(function.block, name, line)

            for var i in 0..args.size {
                let arg = args[i]
                let np = vector::get(function.args, i) !*typechecking::NamedParameter
                let arg_value = get_value(arg, state)
                let mem = allocate(arg.tpe.size)

                let buf = buffer::make_buffer()
                buffer::append_str(*buf, np.name)
                buffer::append_str(*buf, ".value")
                let name = buffer::to_string(*buf)
                map::put(stack_frame.locals, name, mem)
                set(mem, arg.tpe, arg_value)
            }

            push_stack_frame(stack_frame, state)
            
            /*print(name, "\n")
            for var i in 0..vector::length(state.stack) {
                let frame = vector::get(state.stack, vector::length(state.stack) - 1 - i) !*StackFrame
                print("\t", frame.function_name, ":", frame.line, "\n")
            }*/
            eval(function.block, state)

            if ret.tpe {
                let ret_value = get_value(stack_frame.ret, state)
                pop_stack_frame(state)

                set_value(ret, ret_value, state)
            } else {
                pop_stack_frame(state)
            }
            state.cstate.result = result
        }
    }
    
}

def eval_Ret(insn: *compiler::Insn, state: *State) {
    let ret = insn.value.ret.value
    let stack_frame = get_stack_frame(state)
    stack_frame.ret = get_value(ret, state)
    stack_frame.next = null
}

def eval_BrUnc(insn: *compiler::Insn, state: *State) {
    let label_ = insn.value.br_unc.label_
    let stack_frame = get_stack_frame(state)
    stack_frame.next = map::get(stack_frame.jump_table, label_.name) !*compiler::Block
}

def eval_Br(insn: *compiler::Insn, state: *State) {
    let if_true = insn.value.br.if_true
    let if_false = insn.value.br.if_false
    
    let cond = get_value(insn.value.br.cond, state)
    assert(cond.kind == compiler::ValueKind::BOOL)
    
    let stack_frame = get_stack_frame(state)
    if cond.i {
        stack_frame.next = map::get(stack_frame.jump_table, if_true.name) !*compiler::Block
    } else {
        stack_frame.next = map::get(stack_frame.jump_table, if_false.name) !*compiler::Block
    }
}

def eval_Switch(insn: *compiler::Insn, state: *State) {
    let value = get_value(insn.value.switch_.value, state)
    let switch_values = insn.value.switch_.switch_values
    let otherwise = insn.value.switch_.otherwise

    let stack_frame = get_stack_frame(state)
    for var i in 0..vector::length(switch_values) {
        let sw = vector::get(switch_values, i) !*SwitchValue
        if sw.value.i == value.i {
            stack_frame.next = map::get(stack_frame.jump_table, sw.label_.name) !*compiler::Block
            return
        }
    }

    stack_frame.next = map::get(stack_frame.jump_table, otherwise.name) !*compiler::Block
}

def eval_Fptoui(insn: *compiler::Insn, state: *State) {
    let ret = insn.value.convert.ret
    let value = get_value(insn.value.convert.value, state)
    let result = (value.f !uint64) !int64
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_Fptosi(insn: *compiler::Insn, state: *State) {
    let ret = insn.value.convert.ret
    let value = get_value(insn.value.convert.value, state)
    let result = value.f !int64
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_Uitofp(insn: *compiler::Insn, state: *State) {
    let ret = insn.value.convert.ret
    let value = get_value(insn.value.convert.value, state)
    let result = (value.i !uint64) !double
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_Sitofp(insn: *compiler::Insn, state: *State) {
    let ret = insn.value.convert.ret
    let value = get_value(insn.value.convert.value, state)
    let result = value.i !double
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_Ptrtoint(insn: *compiler::Insn, state: *State) {
    let ret = insn.value.convert.ret
    let value = get_value(insn.value.convert.value, state)
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = value.i } !compiler::Value, state) 
}

def eval_Inttoptr(insn: *compiler::Insn, state: *State) {
    let ret = insn.value.convert.ret
    let value = get_value(insn.value.convert.value, state)
    set_value(ret, { kind = ValueKind::POINTER, tpe = ret.tpe, i = value.i } !compiler::Value, state) 
}

def eval_insn(insn: *compiler::Insn, state: *State) {
    switch insn.kind !int {
        case compiler::InsnKind::INSERTVALUE:
            eval_InsertValue(insn, state)
        case compiler::InsnKind::EXTRACTVALUE:
            eval_ExtractValue(insn, state)
        case compiler::InsnKind::GETELEMENTPTR:
            eval_GetElementPtr(insn, state)
        case compiler::InsnKind::PTRTOINT:
            eval_Ptrtoint(insn, state)
        case compiler::InsnKind::INTTOPTR:
            eval_Inttoptr(insn, state)
        case compiler::InsnKind::TRUNC, compiler::InsnKind::SEXT, 
            compiler::InsnKind::ZEXT, compiler::InsnKind::FPTRUNC, 
            compiler::InsnKind::FPEXT, compiler::InsnKind::BITCAST:
            eval_Convert(insn, state)
        case compiler::InsnKind::FPTOUI:
            eval_Fptoui(insn, state)
        case compiler::InsnKind::FPTOSI:
            eval_Fptosi(insn, state)
        case compiler::InsnKind::UITOFP:
            eval_Uitofp(insn, state)
        case compiler::InsnKind::SITOFP:
            eval_Sitofp(insn, state)
        case compiler::InsnKind::SREM:
            eval_SRem(insn, state)
        case compiler::InsnKind::UREM:
            eval_URem(insn, state)
        case compiler::InsnKind::ASHR:
            eval_AShr(insn, state)
        case compiler::InsnKind::LSHR:
            eval_LShr(insn, state)
        case compiler::InsnKind::SHL:
            eval_Shl(insn, state)
        case compiler::InsnKind::AND:
            eval_And(insn, state)
        case compiler::InsnKind::OR:
            eval_Or(insn, state)
        case compiler::InsnKind::XOR:
            eval_XOr(insn, state)
        case compiler::InsnKind::ADD:
            eval_Add(insn, state)
        case compiler::InsnKind::SUB:
            eval_Sub(insn, state)
        case compiler::InsnKind::MUL:
            eval_Mul(insn, state)
        case compiler::InsnKind::SDIV:
            eval_SDiv(insn, state)
        case compiler::InsnKind::UDIV:
            eval_UDiv(insn, state)
        case compiler::InsnKind::FADD:
            eval_FAdd(insn, state)
        case compiler::InsnKind::FSUB:
            eval_FSub(insn, state) 
        case compiler::InsnKind::FMUL:
            eval_FMul(insn, state)
        case compiler::InsnKind::FREM:
            eval_FRem(insn, state)
        case compiler::InsnKind::FDIV:
            eval_FDiv(insn, state)
        case compiler::InsnKind::FNEG:
            eval_FNeg(insn, state)
        case compiler::InsnKind::FCMP:
            eval_FCmp(insn, state)
        case compiler::InsnKind::ICMP:
            eval_ICmp(insn, state)
        case compiler::InsnKind::ALLOCA:
            eval_Alloca(insn, state)
        case compiler::InsnKind::STORE:
            eval_Store(insn, state)
        case compiler::InsnKind::LOAD:
            eval_Load(insn, state)
        case compiler::InsnKind::CALL:
            eval_Call(insn, state)
        case compiler::InsnKind::RET:
            eval_Ret(insn, state)
        case compiler::InsnKind::BR_UNC:
            eval_BrUnc(insn, state)
        case compiler::InsnKind::BR:
            eval_Br(insn, state)
        case compiler::InsnKind::SWITCH:
            eval_Switch(insn, state)
        case compiler::InsnKind::UNREACHABLE:
            errors::errorv("Reached unreachable instruction")
        case:
            error(insn.kind, "\n") 
            assert(false)
    }
}

def eval_block(block: *compiler::Block, state: *State) {
    // TODO Turn this into a function
    /*for var i in 0..vector::length(block.insn) {
        let insn = vector::get(block.insn, i) !*compiler::Insn
        if insn.kind == compiler::InsnKind::LOAD {
            print(insn.kind, " ", insn.value.load.loc.name, "\n")
        } else if insn.kind == compiler::InsnKind::ALLOCA {
            print(insn.kind, " ", insn.value.alloca.ret.name, "\n")
        } else {
            print(insn.kind, "\n")
        }
    }
    print("\n")*/

    let stack_frame = get_stack_frame(state)
    stack_frame.next = block.next
    for var i in 0..vector::length(block.insn) {
        let insn = vector::get(block.insn, i) !*compiler::Insn
        eval_insn(insn, state)
    }
}

export def eval(block: *compiler::Block, state: *State) {
    let stack_frame = get_stack_frame(state)
    while block {
        eval_block(block, state)
        block = stack_frame.next
    }
}

// Turn pointers into their own constants
// the first parameter is an out value, you need to pass true and it gets set to false if any of the 
// sub expressions of value is not a constant (pointers and arrays)
def serialize(is_constant: *bool, value: compiler::Value, global: *compiler::Global, index: *vector::Vector, module: *toolchain::Module, cstate: *compiler::State) -> compiler::Value {
    if value.kind == compiler::ValueKind::POINTER {
        @is_constant = false

        var loc: compiler::Value
        if vector::length(index) > 0 {
            loc = compiler::make_local_value(typechecking::pointer(value.tpe), null, cstate)

            let gep = compiler::make_insn(compiler::InsnKind::GETELEMENTPTR)
            let index_array = allocate(compiler::Value, vector::length(index) + 1)
            index_array[0] = compiler::make_int_value(0)
            for var i in 0..vector::length(index) {
                index_array[i + 1] = @(vector::get(index, i) !*compiler::Value)
            }
            gep.value.gep = {
                ret = loc,
                tpe = global.tpe,
                value = { kind = compiler::ValueKind::GLOBAL, name = global.name, tpe = typechecking::pointer(global.tpe) } !compiler::Value,
                index = index_array
            } !compiler::InsnGetElementPtr
            compiler::push_insn(gep, cstate)
        } else {
            loc = { kind = compiler::ValueKind::GLOBAL, name = global.name, tpe = global.tpe } !compiler::Value
        }

        let new_global = allocate(compiler::Global)
        @new_global = {
            private = true,
            name = compiler::make_global_name("const", cstate),
            tpe = value.tpe.tpe,
            line = -1
        } !compiler::Global
        map::put(module.result.globals, new_global.name, new_global)

        let valuep = allocate(compiler::Value)
        @valuep = serialize(is_constant, get(value.i !*, value.tpe.tpe), new_global, vector::make(), module, cstate)
        new_global.value = valuep
        
        let store = compiler::make_insn(compiler::InsnKind::STORE)
        store.value.store = {
            value = { kind = compiler::ValueKind::GLOBAL, tpe = value.tpe, name = new_global.name } !compiler::Value,
            loc = loc
        } !compiler::InsnStore
        compiler::push_insn(store, cstate)

        return { kind = compiler::ValueKind::UNDEF, tpe = value.tpe } !compiler::Value
    } else if value.kind == compiler::ValueKind::STRUCT and value.tpe.kind == typechecking::TypeKind::ARRAY {
        @is_constant = false

        let length = value.values[0].i
        let ptr = value.values[1].i !*
        let values = allocate(compiler::Value, length)
        let array_value = { kind = compiler::ValueKind::ARRAY, tpe = value.tpe, values = values } !compiler::Value
        
        let tpe = typechecking::make_type_raw(typechecking::TypeKind::STATIC_ARRAY)
        tpe.tpe = builtins::char_
        tpe.length = length
        tpe.size = tpe.length * value.tpe.tpe.size
        tpe.align = value.tpe.tpe.align

        let new_global = allocate(compiler::Global)
        @new_global = {
            private = true,
            name = compiler::make_global_name("const", cstate),
            tpe = tpe,
            line = -1
        } !compiler::Global
        map::put(module.result.globals, new_global.name, new_global)

        for var i in 0..length {
            let new_index = vector::make()
            let indexp = allocate(compiler::Value)
            @indexp = compiler::make_int_value(i)
            vector::push(new_index, indexp)
            values[i] = serialize(is_constant, get(ptr ++ value.tpe.tpe.size * i, value.tpe.tpe), new_global, new_index, module, cstate)
        }

        let loc = compiler::make_local_value(typechecking::pointer(typechecking::pointer(value.tpe.tpe)), null, cstate)
        let gep = compiler::make_insn(compiler::InsnKind::GETELEMENTPTR)
        let index_array = allocate(compiler::Value, vector::length(index) + 2)
        index_array[0] = compiler::make_int_value(0)
        for var i in 0..vector::length(index) {
            index_array[i + 1] = @(vector::get(index, i) !*compiler::Value)
        }
        index_array[vector::length(index) + 1] = compiler::make_int_value(1)
        gep.value.gep = {
            ret = loc,
            tpe = global.tpe,
            value = { kind = compiler::ValueKind::GLOBAL, name = global.name, tpe = typechecking::pointer(global.tpe) } !compiler::Value,
            index = index_array
        } !compiler::InsnGetElementPtr
        compiler::push_insn(gep, cstate)

        let gep2_ret = compiler::make_local_value(typechecking::pointer(value.tpe.tpe), null, cstate)
        let gep2 = compiler::make_insn(compiler::InsnKind::GETELEMENTPTR)
        let index_array2 = allocate(compiler::Value, 2)
        index_array2[0] = compiler::make_int_value(0)
        index_array2[1] = compiler::make_int_value(0)
        gep2.value.gep = {
            ret = gep2_ret,
            tpe = tpe,
            value = { kind = compiler::ValueKind::GLOBAL, tpe = typechecking::pointer(tpe), name = new_global.name } !compiler::Value,
            index = index_array2
        }
        compiler::push_insn(gep2, cstate)
        
        let store = compiler::make_insn(compiler::InsnKind::STORE)
        store.value.store = {
            value = gep2_ret,
            loc = loc
        } !compiler::InsnStore
        compiler::push_insn(store, cstate)

        let valuep = allocate(compiler::Value)
        @valuep = array_value
        new_global.value = valuep

        value.values[1].kind = compiler::ValueKind::UNDEF
        return value
        
    } else if value.kind == compiler::ValueKind::ARRAY or value.kind == compiler::ValueKind::STRUCT {
        @is_constant = false
        for var i in 0..value.values.size {
            let new_index = vector::copy(index)
            let indexp = allocate(compiler::Value)
            @indexp = compiler::make_int_value(i)
            vector::push(new_index, indexp)
            value.values[i] = serialize(is_constant, value.values[i], global, new_index, module, cstate)
        }
        return value
    } else {
        return value
    }
}

export def eval(cstate: *compiler::State) -> State {
    var block = cstate.current_function.block
    vector::insert(block.insn, 0, cstate.current_function.allocas)

    let stack_frame = make_stack_frame(block, "<inline>", 1)

    let state = {
        cstate = cstate,
        stack = vector::make()
    } !State

    vector::push(state.stack, stack_frame)

    eval(block, *state)

    return state
}

export def serialize_value(key: string, module: *toolchain::Module, cstate: *compiler::State) -> *compiler::Global {
    cstate.current_block = module.code

    let mem = map::get(cstate.globals, key)
    let global = map::get(cstate.result.globals, key) !*compiler::Global
    if not global { return null } // Probably a constant
    if typechecking::is_stub(global.tpe) { return null } // Didn't reference

    let ptr = get(mem, typechecking::pointer(global.tpe)).i !*
    var is_constant = true
    let value = serialize(
        *is_constant, 
        get(ptr, global.tpe), 
        global, 
        vector::make(), 
        module, 
        cstate
    )
    
    let valuep = allocate(compiler::Value)
    @valuep = value

    if is_constant {
        global.value = valuep
    } else {
        // We need to create a new global, or else the constant is getting inlined
        let new_global = allocate(compiler::Global)
        @new_global = {
            private = false,
            name = global.name,
            tpe = global.tpe,
            value = valuep,
            line = -1
        } !compiler::Global
        map::put(module.result.globals, new_global.name, new_global)
        map::put(module.imported, new_global.name, map::sentinel)
    }

    return global
}