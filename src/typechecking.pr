// TODO Many of these function will error twice with misleading errors
// Every function needs to check for possible null types and null nodes
// and abort in those cases

import map
import vector
import parser
import buffer
import util

export type TypeKind = enum {
    TYPE
    WORD
    FLOAT
    BOOL
    STRUCT
    UNION
    ENUM
    FUNCTION
    TUPLE
    POINTER
    REFERENCE
    ARRAY
    STATIC_ARRAY
    RANGE
    RANGE_INC
    // Used for enums
    NAMESPACE
    // Auto cast, this type will convert to anything
    // AUTO_CAST // TODO Actually implement this
    // Forward declaration
    STUB
    // Null
    NULL
}

export type Type
export type State

export type StructMember = struct {
    // Source line
    line: int
    name: string
    tpe: *Type
    offset: size_t
}

type compiler::State
type compiler::Value
type scope::Scope

export type Type = struct {
    kind: TypeKind
    // Source line
    line: int
    // Name of the type as used by the source code
    // Might be the name of a typedef
    name: string
    // Unique name of the type
    type_name: string
    // Size in bytes
    size: size_t
    align: size_t
    unsig: bool
    // TODO Add kw (parser::VarDecl) for arrays and pointers
    // Static array
    length: size_t
    // Type both used for array/pointer and enum
    tpe: *Type
    packed: bool
    // Fields for struct, array of StructMember
    fields: [StructMember]
    // Function and Tuple
    // Vector of Type
    return_t: *vector::Vector
    // Vector of NamedParameter
    parameter_t: *vector::Vector
    // Macro for builtin functions
    macro: (*parser::Node, [compiler::Value], *compiler::State) -> compiler::Value
    // This calculates the return types for functions 
    // where the return types depend on the argument types
    proto: (*vector::Vector, *vector::Vector, *State) -> (*vector::Vector)
    //          args            kwargs                        return_t
    // Enum scope
    scope: *scope::Scope
}

export type NamedParameter = struct {
    // Might be empty for positional parameters
    name: string
    value: *Type
    varargs: bool
    node: *parser::Node
}

export type State = struct {
    filename: string
    module: string
    counter: int
    scope: *scope::Scope
    function_stack: *vector::Vector
}

export def errorn(node: *parser::Node, msg: string)
export def common_type(a: *Type, b: *Type) -> *Type
export def type_lookup(node: *parser::Node, state: *State, lookup_default: bool) -> *Type
export def type_lookup(node: *parser::Node, state: *State) -> *Type
export def evaluate_constant(node: *parser::Node) -> *
export def mangle_function_name(name: string, parameter_t: *vector::Vector) -> string

def current_function(state: *State) -> *Type {
    let length = vector::length((@state).function_stack)
    if length == 0 {
        return null
    } else {
        return vector::get((@state).function_stack, length - 1) !*Type
    }
}

def push_function(state: *State, tpe: *Type) {
    vector::push((@state).function_stack, tpe)
}

def pop_function(state: *State) -> *Type {
    return vector::pop((@state).function_stack) !*Type
}

export def is_function(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::FUNCTION
}

export def is_function_pointer(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::POINTER and 
        is_function((@tpe).tpe)
}

export def is_integer(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::WORD or 
        (@tpe).kind == TypeKind::BOOL
}

export def is_arithmetic(tpe: *Type) -> bool {
    if not tpe { return false }
    return is_integer(tpe) or 
        (@tpe).kind == TypeKind::FLOAT
}

export def is_float(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::FLOAT
}

// TODO Also allow arrays and strings
export def is_boolean(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::BOOL or
        (@tpe).kind == TypeKind::WORD or
        (@tpe).kind == TypeKind::FLOAT or
        (@tpe).kind == TypeKind::POINTER or
        (@tpe).kind == TypeKind::REFERENCE
}

export def is_pointer(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::POINTER
    // TODO What about references?
}

export def is_struct(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::STRUCT or
        (@tpe).kind == TypeKind::UNION
}

export def is_enum(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::ENUM
}

export def is_type(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::TYPE
}

export def is_array(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::ARRAY or
        (@tpe).kind == TypeKind::STATIC_ARRAY
}

export def is_range(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::RANGE or
        (@tpe).kind == TypeKind::RANGE_INC
}

export def is_stub(tpe: *Type) -> bool {
    if not tpe { return true }
    return (@tpe).kind == TypeKind::STUB
}

export def append_module(name: string, module: string) -> string {
    var buf = buffer::make_buffer()
    if length(module) > 0 {
        buffer::append_str(*buf, module)
        buffer::append_str(*buf, "::")
    }
    buffer::append_str(*buf, name)
    return buffer::to_string(*buf)
}

export def make_type_raw(kind: TypeKind) -> *Type {
    let tpe = allocate(Type)
    (@tpe).type_name = ""
    (@tpe).name = ""
    (@tpe).line = -1
    (@tpe).kind = kind
    (@tpe).scope = null
    return tpe
}

export def make_type(kind: TypeKind, node: *parser::Node) -> *Type {
    assert((@node).kind == parser::NodeKind::IDENTIFIER)
    let name = parser::identifier_to_str(node)
    var t = make_type_raw(kind)
    (@t).line = (@node).loc.line
    (@t).type_name = append_module(name, (@node).loc.module)
    (@t).name = name

    return t
}

export def make_function_type() -> *Type {
    let tpe = make_type_raw(TypeKind::FUNCTION)
    (@tpe).size = size_of type () -> ()
    (@tpe).align = align_of type () -> ()
    (@tpe).macro = null
    (@tpe).proto = null
    return tpe
}

export def make_function_type_n(name: *parser::Node, parameter_t: *vector::Vector, return_t: *vector::Vector, extern: bool) -> *Type {
    let tpe = make_function_type()
    (@tpe).parameter_t = parameter_t
    (@tpe).return_t = return_t
    (@tpe).name = parser::identifier_to_str(name)
    if extern {
        (@tpe).type_name = (@tpe).name
    } else {
        (@tpe).type_name = mangle_function_name(append_module((@tpe).name, (@name).loc.module), parameter_t)
    }
    (@tpe).line = (@name).loc.line
    return tpe
}

export def pointer(tpe: *Type) -> *Type {
    var t = make_type_raw(TypeKind::POINTER)
    (@t).tpe = tpe
    (@t).size = (size_of type *)
    (@t).align = (align_of type *)
    return t
}

export def array(tpe: *Type) -> *Type {
    var t = make_type_raw(TypeKind::ARRAY)
    (@t).tpe = tpe
    (@t).size = (size_of string)
    (@t).align = (align_of string)
    return t
}

export def make_static_array(array_tpe: *Type, size: size_t) -> *Type {
    let tpe = make_type_raw(TypeKind::STATIC_ARRAY)
    (@tpe).tpe = array_tpe
    (@tpe).length = size
    (@tpe).size = (@tpe).length * (@array_tpe).size
    (@tpe).align = (@array_tpe).align
    return tpe
}

def make_unique_name(name: string, state: *State) -> string {
    let buf = buffer::make_buffer()
    buffer::append_str(*buf, name)
    buffer::append_char(*buf, '.')
    let s = util::int_to_str((@state).counter)
    buffer::append_str(*buf, s)

    (@state).counter += 1
    return buffer::to_string(*buf)
}

export def make_anonymous_type(kind: TypeKind) -> *Type {
    var t = allocate(Type)
    (@t).line = -1
    (@t).kind = kind
    (@t).type_name = ""
    (@t).name = ""

    return t
}

export let type_ = make_anonymous_type(TypeKind::TYPE)

// TODO Not a deep copy
export def copy(a: *Type) -> *Type {
    if not a { return null }
    var t = allocate(Type)
    @t = @a
    return t
}

export def equals(a: *Type, b: *Type) -> bool {
    if a == b {
        return true
    }
    if not a or not b { return false }

    if (@a).kind != (@b).kind { return false }

    let kind = (@a).kind
    if kind == TypeKind::BOOL or kind == TypeKind::TYPE { return true }
    if kind == TypeKind::WORD {
        return (@a).size == (@b).size and (@a).unsig == (@b).unsig
    }
    if kind == TypeKind::FLOAT {
        return (@a).size == (@b).size
    }
    if kind == TypeKind::ENUM or
        kind == TypeKind::STRUCT or
        kind == TypeKind::UNION or
        kind == TypeKind::STUB {

        return (@a).type_name == (@b).type_name        
    }
    if kind == TypeKind::ARRAY or
        kind == TypeKind::POINTER or
        kind == TypeKind::REFERENCE {
        
        return equals((@a).tpe, (@b).tpe)
    }
    if kind == TypeKind::STATIC_ARRAY {
        return (@a).length == (@b).length and equals((@a).tpe, (@b).tpe)
    }
    if kind == TypeKind::FUNCTION {
        if vector::length((@a).parameter_t) != vector::length((@b).parameter_t) or
            vector::length((@a).return_t) != vector::length((@b).return_t) {
            return false        
        }
        for var i in 0..vector::length((@a).parameter_t) {
            let param_a = vector::get((@a).parameter_t, i) !*NamedParameter
            let param_b = vector::get((@b).parameter_t, i) !*NamedParameter
            if not equals((@param_a).value, (@param_b).value) {
                return false
            }
        }
        for var i in 0..vector::length((@a).return_t) {
            if not equals(vector::get((@a).return_t, i) !*Type, vector::get((@b).return_t, i) !*Type) {
                return false
            }
        }
        return true
    }

    assert(false)
}

// Returns true if b is assignable to a
def is_assignable(a: *Type, b: *Type) -> bool {
    if equals(a, b) { return true }
    if (@a).kind == TypeKind::WORD {
        if (@b).kind == TypeKind::WORD {
            return (@a).size >= (@b).size
        }
        // TODO Move this to implicit conversion
        /*if (@b).kind == TypeKind::INT_LITERAL {
            if (@a).unsig {
                var i: uint64 = (@b).i * (@b).sign
                switch (@a).size {
                    case 1: return i <= util::MAX_UINT8
                    case 2: return i <= util::MAX_UINT16
                    case 4: return i <= util::MAX_UINT32
                    case 8: return true
                    case: assert(false)
                }
            } else {
                if (@b).i > util::MAX_INT64 { return false }
                var i: int64 = (@b).i * (@b).sign
                switch (@a).size {
                    case 1: return i >= util::MIN_INT8  and i <= util::MAX_INT8
                    case 2: return i >= util::MIN_INT16 and i <= util::MAX_INT16
                    case 4: return i >= util::MIN_INT32 and i <= util::MAX_INT32
                    case 8: return true
                    case: assert(false)
                }
            }
        }*/
    }
    if (@a).kind == TypeKind::FLOAT {
        if (@b).kind == TypeKind::WORD or
            (@b).kind == TypeKind::FLOAT {
            return true
        }
    }
    if (@a).kind == TypeKind::ARRAY {
        if (@b).kind == TypeKind::STATIC_ARRAY {
            return equals((@a).tpe, (@b).tpe)
        }
    }
    if ((@a).kind == TypeKind::POINTER or (@a).kind == TypeKind::REFERENCE) and
        (@b).kind == TypeKind::NULL {
        return true
    }
    if (@a).kind == TypeKind::POINTER and (@a).tpe == null {
        return (@b).kind == TypeKind::POINTER
    }
    if (@a).kind == TypeKind::REFERENCE and (@a).tpe == null {
        return (@b).kind == TypeKind::REFERENCE
    }
    return false
}

// Tries to convert type b to type a
// The return value is -1 if b can't be converted to a
// if the types are equal, 0 is returned.
// Otherwise a positive integer is returned.
def convert_type_score(a: *Type, b: *Type) -> int {
    if not a or not b { return 0 }
    if equals(a, b) {
        return 0
    }
    if ((@a).kind == TypeKind::POINTER or (@a).kind == TypeKind::REFERENCE) and (@b).kind == TypeKind::NULL {
        return 0
    }
    if (@a).kind == TypeKind::WORD and (@b).kind == TypeKind::WORD and
        (@a).size >= (@b).size {
        
        // TODO if we are ever going to allow a 24 bit value this is going to fail
        return log2((@a).size) !int - log2((@b).size) !int
    }
    if (@a).kind == TypeKind::FLOAT and (@b).kind == TypeKind::FLOAT {
        // TODO This works because there are only two float sizes
        return 1
    }
    if (@a).kind == TypeKind::FLOAT and
        (@b).kind == TypeKind::WORD {
        
        return 10
    }
    if ((@a).kind == TypeKind::POINTER and (@b).kind == TypeKind::POINTER or
        (@a).kind == TypeKind::REFERENCE and (@b).kind == TypeKind::REFERENCE) and
        (@a).tpe == null {
        
        return 1
    }
    if (@a).kind == TypeKind::ARRAY {
        if (@b).kind == TypeKind::STATIC_ARRAY and equals((@a).tpe, (@b).tpe) {
            return 1
        }
        if (@a).tpe == null and ((@b).kind == TypeKind::ARRAY or (@b).kind == TypeKind::STATIC_ARRAY) {
            return 1
        }
    }
    return -1
}

// Calculates a score for overload resultion, the result is 0 for an exact match
// and a positive integer if the argument types need to be converted.
// -1 is returned if the argument types don't match.
export def overload_score(a: *Type, param_b: *vector::Vector, positional: bool) -> int {
    assert(is_function(a))

    let param_a = (@a).parameter_t
    // TODO default arguments
    if vector::length(param_a) > vector::length(param_b) {
        if vector::length(param_a) == vector::length(param_b) + 1 {
            if not (@(vector::peek(param_a) !*NamedParameter)).varargs {
                return -1
            }
        } else {
            return -1
        }
    }

    var sum = 0
    for var i in 0..vector::length(param_b) {
        let right = vector::get(param_b, i) !*NamedParameter
        var left: *NamedParameter = null
        if length((@right).name) > 0 and not positional {
            for var i in 0..vector::length(param_a) {
                let param = vector::get(param_a, i) !*NamedParameter
                if (@right).name == (@param).name {
                    left = param
                    break
                }
            }
            if not left { return -1 }
        } else {
            if i < vector::length(param_a) {
                left = vector::get(param_a, i) !*NamedParameter
            } else if vector::length(param_a) > 0 {
                left = vector::peek(param_a) !*NamedParameter
                if not (@left).varargs {
                    return -1
                } 
            } else {
                return -1
            }
        }
        let score = convert_type_score((@left).value, (@right).value)
        if score < 0 { return -1 }
        sum += score
    }

    return sum
}

export def type_to_str(tpe: *Type) -> string {
    if not tpe { return "V" }

    var buf = buffer::make_buffer()
    
    switch ((@tpe).kind !int) {
        case TypeKind::WORD: 
            if (@tpe).unsig {
                buffer::append_char(*buf, 'u')
            }
            buffer::append_char(*buf, 'i')
            buffer::append_str(*buf, util::int_to_str((@tpe).size * 8))
        case TypeKind::FLOAT:
            buffer::append_char(*buf, 'f')
            buffer::append_str(*buf, util::int_to_str((@tpe).size * 8))
        case TypeKind::BOOL:
            buffer::append_char(*buf, 'b')
        case TypeKind::STRUCT:
            buffer::append_char(*buf, 'S')
            buffer::append_str(*buf, util::int_to_str(length((@tpe).type_name)))
            buffer::append_str(*buf, (@tpe).type_name)
        case TypeKind::UNION:
            buffer::append_char(*buf, 'U')
            buffer::append_str(*buf, util::int_to_str(length((@tpe).type_name)))
            buffer::append_str(*buf, (@tpe).type_name)
        case TypeKind::ENUM:
            buffer::append_char(*buf, 'E')
            buffer::append_str(*buf, util::int_to_str(length((@tpe).type_name)))
            buffer::append_str(*buf, (@tpe).type_name)
        case TypeKind::FUNCTION:
            buffer::append_char(*buf, 'F')
            for var i in 0..vector::length((@tpe).parameter_t) {
                let parameter = vector::get((@tpe).parameter_t, i) !*NamedParameter
                buffer::append_str(*buf, type_to_str((@parameter).value))
            }
            buffer::append_char(*buf, '_')
            for var i in 0..vector::length((@tpe).return_t) {
                buffer::append_str(*buf, type_to_str(vector::get((@tpe).return_t, i) !*Type))
            }
            buffer::append_char(*buf, '$')
        case TypeKind::POINTER:
            buffer::append_char(*buf, 'P')
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
        case TypeKind::REFERENCE:
            buffer::append_char(*buf, 'R')
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
        case TypeKind::STATIC_ARRAY:
            buffer::append_char(*buf, 'a')
            buffer::append_str(*buf, util::int_to_str((@tpe).length))
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
        case TypeKind::ARRAY:
            buffer::append_char(*buf, 'A')
            buffer::append_str(*buf, type_to_str((@tpe).tpe))
        case:
            error((@tpe).kind, "\n")
            assert(false)
    }

    return buffer::to_string(*buf)
}

export def mangle_function_name(name: string, parameter_t: *vector::Vector) -> string {
    var buf = buffer::make_buffer()
    buffer::append_str(*buf, "_F")
    buffer::append_str(*buf, util::int_to_str(length(name)))
    buffer::append_str(*buf, name)
    buffer::append_str(*buf, "__")

    for var i in 0..vector::length(parameter_t) {
        buffer::append_str(*buf, type_to_str((@(vector::get(parameter_t, i) !*NamedParameter)).value))
    }

    return buffer::to_string(*buf)
}

// TODO Move this into parser
export def last_ident_to_str(node: *parser::Node) -> string {
    if not node { return "" }
    assert((@node).kind == parser::NodeKind::IDENTIFIER)
    if vector::length((@node).value.body) > 1 {
        errorn(node, "Expected plain identifier without path\n")
    }
    return @(vector::get((@node).value.body, 0) !*string)
}

def flatten_return_type(node: *parser::Node, return_t: *vector::Vector) -> *Type {
    let len = vector::length(return_t) 
    if len > 1 {
        // TODO size and alignment! Same as a struct,
        // also refactor type_lookup and compiler (functions with multiple return types)
        // into a single function for calculating the size and alignmenet of a struct
        let return_tpe = make_type_raw(TypeKind::TUPLE)
        (@return_tpe).line = (@node).loc.line
        (@return_tpe).return_t = return_t
        return return_tpe
    } else if len == 1 {
        return vector::peek(return_t) !*Type
    }

    return null
}

export def walk(parent: *parser::Node, node: *parser::Node, state: *State)

import scope
import builtins
import debug

type toolchain::Module

export def typecheck(module: *toolchain::Module) 

import toolchain

def check_is_identifier_assignable(ident: *parser::Node, state: *State) -> bool {
    if (@ident).kind == parser::NodeKind::IDENTIFIER {
        let value = scope::get((@state).scope, ident)
        if value {
            if (@value).modifier != parser::VarDecl::VAR {
                errorn(ident, "Assignment to non var\n")
                return false
            }
        } else {
            errorn(ident, "Unknown variable \"")
            error(parser::identifier_to_str(ident), "\n")
            return false
        }
    }
    return true
}

//TODO Move this into its own file, along with a more sophisticated execution engine...
export def evaluate_constant(node: *parser::Node) -> * {
    if (@node).kind == parser::NodeKind::INTEGER or (@node).kind == parser::NodeKind::CHAR {
        let i = allocate(uint64)
        @i = (@node).value.i
        return i
    } else if (@node).kind == parser::NodeKind::IDENTIFIER {
        let value = scope::get_const_value((@node).scope, node)
        return (@value).value
    }
    error((@node).kind, "\n")
    assert(false)
}

export def type_lookup(node: *parser::Node, state: *State, lookup_default: bool) -> *Type {
    if not node { return null }
    if (@node).kind == parser::NodeKind::IDENTIFIER {
        if not lookup_default {
            return scope::get_type(state.scope, node)
        } else {
            let value = scope::get((@state).scope, node, false, false)
            var tpe: *Type = null
            if value {
                if value.modifier != parser::VarDecl::TYPE {
                    errorn(node, parser::identifier_to_str(node))
                    error(" is not a type\n")
                    return null
                }
                tpe = value.value !*Type
            } else {
                tpe = make_type(TypeKind::STUB, node)
                tpe = scope::create_type(state.scope, node, parser::ShareMarker::NONE, tpe)
            }
            return tpe
        }
    } else if (@node).kind == parser::NodeKind::PTR_T {
        let tpe = type_lookup((@node).value.t_parr.tpe, state, lookup_default)
        return pointer(tpe)
    } else if (@node).kind == parser::NodeKind::STRUCT_T {
        let tpe = make_anonymous_type(TypeKind::STRUCT)
        (@tpe).type_name = make_unique_name("<anonymous>", state)
        (@tpe).name = "<anonymous>"
        (@tpe).packed = false
        
        let length = vector::length((@node).value.body)
        if length == 0 {
            errorn(node, "Empty struct not allowed\n")
            return null
        }

        let fields = allocate(StructMember, length)

        var offset = 0
        var align = 1
        for var i in 0..length {
            let field = vector::get((@node).value.body, i) !*parser::Node
            let line = (@field).loc.line

            var tpe: *Type = null
            var name = ""

            if (@field).kind == parser::NodeKind::ID_DECL_STRUCT {
                let ident = (@field).value.id_decl_struct.ident
                name = last_ident_to_str(ident)
                tpe = type_lookup((@field).value.id_decl_struct.tpe, state, lookup_default)
            } else if (@field).kind == parser::NodeKind::STRUCT_T or
                (@field).kind == parser::NodeKind::UNION_T {
                tpe = type_lookup(field, state, lookup_default)
            }
            
            if is_stub(tpe) {
                fields[i] = { line, name, null, 0 } !StructMember
                continue 
            }
            
            offset = (ceil(offset / (@tpe).align !double) * (@tpe).align) !int
            align = util::lcm(align, (@tpe).align !int)

            fields[i] = { line, name, tpe, offset } !StructMember
            offset += (@tpe).size
        }
        offset = (ceil(offset / align !double) * align) !int
        
        (@tpe).line = (@node).loc.line
        (@tpe).size = offset
        (@tpe).align = align
        (@tpe).fields = fields

        return tpe
    } else if (@node).kind == parser::NodeKind::UNION_T {
        let tpe = make_anonymous_type(TypeKind::UNION)
        (@tpe).type_name = make_unique_name("<anonymous>", state)
        (@tpe).name = "<anonymous>"

        let length = vector::length((@node).value.body)
        if length == 0 {
            errorn(node, "Empty union not allowed\n")
            return null
        }

        let fields = allocate(StructMember, length)

        var size = 0
        var align = 1
        for var i in 0..length {
            let field = vector::get((@node).value.body, i) !*parser::Node
            let line = (@field).loc.line
            
            var tpe: *Type = null
            var name = ""

            if (@field).kind == parser::NodeKind::ID_DECL_STRUCT {
                let ident = (@field).value.id_decl_struct.ident
                name = last_ident_to_str(ident)
                tpe = type_lookup((@field).value.id_decl_struct.tpe, state, lookup_default)
            } else if (@field).kind == parser::NodeKind::STRUCT_T or
                (@field).kind == parser::NodeKind::UNION_T {
                tpe = type_lookup(field, state, lookup_default)
            }
            
            if is_stub(tpe) {
                fields[i] = { line, name, null, 0 } !StructMember
                continue 
            }

            fields[i] = { line, name, tpe, 0 } !StructMember

            size = max((@tpe).size, size) !int
            align = max((@tpe).align, align) !int
        }

        (@tpe).line = (@node).loc.line
        (@tpe).size = size
        (@tpe).align = align
        (@tpe).fields = fields

        return tpe
    } else if (@node).kind == parser::NodeKind::ENUM_T {
        var enum_tpe = builtins::int_
        if (@node).value.t_enum.tpe {
            enum_tpe = type_lookup((@node).value.t_enum.tpe, state, lookup_default)
        }
        let tpe = make_anonymous_type(TypeKind::ENUM)
        (@tpe).line = (@node).loc.line
        (@tpe).tpe = enum_tpe
        (@tpe).size = (@enum_tpe).size
        (@tpe).align = (@enum_tpe).align

        return tpe
    } else if (@node).kind == parser::NodeKind::ARRAY_T {
        let array_tpe = type_lookup((@node).value.t_parr.tpe, state, lookup_default)
        let tpe = make_type_raw(TypeKind::ARRAY)
        (@tpe).line = (@node).loc.line
        (@tpe).tpe = array_tpe
        (@tpe).size = size_of string
        (@tpe).align = align_of string

        return tpe
    } else if (@node).kind == parser::NodeKind::ARRAY_STATIC_T {
        let array_tpe = type_lookup((@node).value.t_arrs.tpe, state, lookup_default)

        return make_static_array(array_tpe, (@(@node).value.t_arrs.n).value.i)
    } else if (@node).kind == parser::NodeKind::FUNCTION_T {
        let tpe = make_function_type()
        (@tpe).line = (@node).loc.line
        (@tpe).parameter_t = vector::make()
        for var i in 0..vector::length((@node).value.t_func.args) {
            let arg = vector::get((@node).value.t_func.args, i) !*parser::Node
            let np = allocate(NamedParameter)
            (@np).varargs = false
            (@np).name = ""
            (@np).value = type_lookup(arg, state, lookup_default)
            (@np).node = arg
            vector::push((@tpe).parameter_t, np)
        }
        (@tpe).return_t = vector::make()
        for var i in 0..vector::length((@node).value.t_func.ret) {
            let arg = vector::get((@node).value.t_func.ret, i) !*parser::Node
            vector::push((@tpe).return_t, type_lookup(arg, state, lookup_default))
        }
        return pointer(tpe)
    }

    return null
}

export def type_lookup(node: *parser::Node, state: *State) -> *Type {
    return type_lookup(node, state, false)
}

// Returns the common type of two arithmetic types
// byte -> ubyte -> short -> ushort -> int -> uint -> long -> ulong
export def common_type(a: *Type, b: *Type) -> *Type {
    if not a or not b { return null }

    //TODO Should cause an error
    //assert(is_arithmetic(a) and is_arithmetic(b))

    if (@a).kind == TypeKind::FLOAT and (@b).kind == TypeKind::WORD {
        return a
    } else if (@a).kind == TypeKind::WORD and (@b).kind == TypeKind::FLOAT {
        return b
    }
    if (@a).kind == (@b).kind {
        if (@a).size == (@b).size {
            if (@b).unsig {
                return b
            } else {
                return a
            }
        } else if (@a).size > (@b).size {
            return a 
        } else {
            return b
        }
    }
    return null
}

def walk_PtrT(node: *parser::Node, state: *State) {
    walk(node, (@node).value.t_parr.tpe, state)
    (@node).tpe = type_
}

def walk_Null(node: *parser::Node, state: *State) {
    let tpe = make_type_raw(TypeKind::NULL)
    (@node).tpe = tpe
}

def walk_Integer(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::int_
}

def walk_Boolean(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::bool_
}

def walk_Float(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::double_
}

def walk_String(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::string_
}

def walk_Char(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::char_
}

def walk_Range(node: *parser::Node, state: *State) {
    walk(node, (@node).value.bin_op.left, state)
    walk(node, (@node).value.bin_op.right, state)

    var kind = TypeKind::RANGE
    if (@node).kind == parser::NodeKind::RANGE_INC {
        kind = TypeKind::RANGE_INC
    }
    let tpe = make_type_raw(kind)
    (@tpe).line = (@node).loc.line
    
    (@node).tpe = tpe
}

def walk_Identifier(node: *parser::Node, state: *State) {
    var value = scope::get((@state).scope, node)
    if not value {
        errorn(node, "Unknown identifier \"")
        error(parser::identifier_to_str(node), "\"\n")
        return
    }

    (@node).svalue = value
    (@node).tpe = (@value).tpe

    if is_function((@node).tpe) and 
        (@(@node).parent).kind != parser::NodeKind::FUNC_CALL and
        (@(@node).parent).kind != parser::NodeKind::PTR {

        let parent = (@node).parent
        let old_node = parser::copy_node(node)
        (@old_node).tpe = flatten_return_type(old_node, (@(@node).tpe).return_t)

        @node = {
            kind = parser::NodeKind::FUNC_CALL,
            loc = (@node).loc
        } !parser::Node
        (@node).value.func_call = {
            left = old_node,
            args = vector::make(),
            kwargs = vector::make()
        } !parser::NodeFuncCall
        walk(parent, node, state)
    }
}

def implicit_conversion(node: *parser::Node, tpe: *Type) {
    if not tpe { return }
    // TODO For integers we need to check the boundaries
    // TODO What about stuff like --10? I mean its kinda useless but for completeness
    if (@node).kind == parser::NodeKind::NULL and is_pointer(tpe) or
        is_arithmetic(tpe) and ((@node).kind == parser::NodeKind::INTEGER or
        ((@node).kind == parser::NodeKind::USUB or (@node).kind == parser::NodeKind::UADD) and 
        (@(@node).value.expr).kind == parser::NodeKind::INTEGER) {

        (@node).tpe = tpe
    }
}

def infer_struct_type(node: *parser::Node, tpe: *Type) {
    if (@node).kind != parser::NodeKind::STRUCT_LIT { return }
    if not is_struct(tpe) {
        errorn(node, "Incompatible types, ")
        error(debug::type_to_str(tpe), " is not a structure type\n")
        return
    }
    (@node).tpe = tpe
}

def collapse_types(node: *parser::Node, ltypes: *vector::Vector, right: *vector::Vector, state: *State) -> *vector::Vector {
    let rtypes = vector::make()
    var k = 0
    for var i in 0..vector::length(right) {
        let value = vector::get(right, i) !*parser::Node
        if not value { continue }

        var ltpe: *Type = null
        if k < vector::length(ltypes) {
            ltpe = vector::get(ltypes, k) !*Type
            infer_struct_type(value, ltpe)
        }
        
        walk(node, value, state)
        let rtpe = (@value).tpe
        if rtpe and (@rtpe).kind == TypeKind::TUPLE {
            for var j in 0..vector::length((@rtpe).return_t) {
                let t = vector::get((@rtpe).return_t, j) !*Type
                vector::push(rtypes, t)
                k += 1
            }
        } else {
            implicit_conversion(value, ltpe)
            if rtpe {
                vector::push(rtypes, (@value).tpe)
            }
            k += 1
        }
    }
    return rtypes
}

def walk_Assign(node: *parser::Node, state: *State) {
    let left = (@node).value.assign.left
    let right = (@node).value.assign.right

    let ltypes = vector::make()
    for var i in 0..vector::length(left) {
        let l = vector::get(left, i) !*parser::Node
        walk(node, l, state)
        vector::push(ltypes, (@l).tpe)
    }
    let rtypes = collapse_types(node, ltypes, right, state)

    if vector::length(ltypes) != vector::length(rtypes) {
        errorn(node, "Unbalanced assignment\n")
        return
    }

    for var i in 0..vector::length(left) {
        let l = vector::get(left, i) !*parser::Node
        let ltpe = (@l).tpe
        if not check_is_identifier_assignable(l, state) {
            continue
        }
        var rtpe = vector::get(rtypes, i) !*Type

        if not ltpe or not rtpe { continue }
        if not is_assignable(ltpe, rtpe) {
            errorn(l, "Incompatible types ")
            error(debug::type_to_str(rtpe), " and ", debug::type_to_str(ltpe), "\n")
        }
    }
    (@node).tpe = vector::peek(ltypes) !*Type
}

// TODO We should declare all variables, always, to prevent multiple errors to occur
def walk_VarDecl(node: *parser::Node, state: *State) {
    let share = (@node).value.var_decl.share
    let kw = (@node).value.var_decl.kw
    let left = (@node).value.var_decl.left
    let right = (@node).value.var_decl.right
    let extern = (@node).value.var_decl.extern

    if current_function(state) {
        if share != parser::ShareMarker::NONE {
            errorn(node, "Can't share non top level variable\n")
        }
    }
    
    let ltypes = vector::make()
    for var i in 0..vector::length(left) {
        let node = vector::get(left, i) !*parser::Node
        if (@node).kind == parser::NodeKind::ID_DECL {
            let tpe_node = (@node).value.id_decl.tpe
            if tpe_node {
                let tpe = type_lookup(tpe_node, state)
                vector::push(ltypes, tpe)
            } else {
                vector::push(ltypes, null)
            }
        } else {
            let n = (@node).value.expr
            walk(node, n, state)
            vector::push(ltypes, (@n).tpe)
        }
    }

    let rtypes = collapse_types(node, ltypes, right, state)

    if (kw == parser::VarDecl::CONST or 
        kw == parser::VarDecl::LET) and 
        vector::length(ltypes) != vector::length(rtypes) {
        
        errorn(node, "Unbalanced assignment\n")
        return
    }

    for var i in 0..vector::length(left) {
        var ltpe = vector::get(ltypes, i) !*Type
        let node = vector::get(left, i) !*parser::Node
        if (@node).kind == parser::NodeKind::ID_DECL {
            if not ltpe and i < vector::length(rtypes) {
                ltpe = vector::get(rtypes, i) !*Type
            }
            if not ltpe {
                errorn(node, "Need to specify a type\n")
                continue
            }
            if i < vector::length(rtypes) {
                let rtpe = vector::get(rtypes, i) !*Type
                if not is_assignable(ltpe, rtpe) {
                    errorn(node, "Incompatible types ")
                    error(debug::type_to_str(rtpe), " and ", debug::type_to_str(ltpe), "\n")
                }
            }

            let ident = (@node).value.id_decl.value
            (@ident).scope = (@state).scope
            (@ident).tpe = ltpe

            // TODO Implement constants (set a value)
            scope::create_variable_ext((@state).scope, ident, share, kw, ltpe, extern, null)
            (@ident).svalue = scope::get((@state).scope, ident)

        } else {
            let n = (@node).value.expr
            if not check_is_identifier_assignable(n, state) {
                continue
            }

            if i >= vector::length(rtypes) {
                errorn(node, "Must assign a value\n")
                continue
            }
            let rtpe = vector::get(rtypes, i) !*Type

            if not ltpe or not rtpe { continue }
            if not is_assignable(ltpe, rtpe) {
                errorn(node, "Incompatible types ")
                error(debug::type_to_str(rtpe), " and ", debug::type_to_str(ltpe), "\n")
            }
        }
    }
}

def walk_Not(node: *parser::Node, state: *State) {
    walk(node, (@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not tpe { return }
    if not is_boolean(tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str(tpe), ", must be boolean type\n")
    }
    (@node).tpe = tpe
}

def walk_BNot(node: *parser::Node, state: *State) {
    walk(node, (@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not tpe { return }
    if not is_integer(tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str(tpe), ", must be integer type\n")
    }
    (@node).tpe = tpe
}

def walk_UAdd(node: *parser::Node, state: *State) {
    walk(node, (@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not tpe { return }
    if not is_arithmetic(tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str(tpe), ", must be arithmetic type\n")
    }
    (@node).tpe = tpe
}

def walk_USub(node: *parser::Node, state: *State) {
    walk(node, (@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not tpe { return }
    if not is_arithmetic(tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str(tpe), ", must be arithmetic type\n")
    }
    /*if (@tpe).unsig {
        errorn(node, "Negation on unsigned type ")
        error(debug::type_to_str(tpe))
    }*/ // TODO Maybe give a warning on this?
    (@node).tpe = tpe
}

def walk_ArithmeticOp(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(node, left, state)
    walk(node, right, state)

    if not (@left).tpe or not (@right).tpe { return }
    (@node).tpe = common_type((@left).tpe, (@right).tpe)
}

def walk_BitwiseOp(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(node, left, state)
    walk(node, right, state)

    if not (@left).tpe or not (@right).tpe { return }
    if not is_integer((@left).tpe) or not is_integer((@right).tpe) {
        errorn(node, "Invalid operands of type ")
        error(debug::type_to_str((@left).tpe), " and ", debug::type_to_str((@right).tpe), " to bitwise operator")
    }

    (@node).tpe = common_type((@left).tpe, (@right).tpe)
}

def walk_BooleanOp(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(node, left, state)
    walk(node, right, state)

    if not (@left).tpe or not (@right).tpe { return }
    if not is_boolean((@left).tpe) or not is_boolean((@right).tpe) {
        errorn(node, "Invalid operands of type ")
        error(debug::type_to_str((@left).tpe), " and ", debug::type_to_str((@right).tpe), " to boolean operator")
    }

    (@node).tpe = builtins::bool_
}

// TODO implicit conversions here too
def walk_AssignEqArithmetic(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(node, left, state)
    walk(node, right, state)
    if not check_is_identifier_assignable(left, state) {
        return
    }

    if not (@left).tpe or not (@right).tpe { return }
    if not is_arithmetic((@right).tpe) {
        errorn(right, "Incompatible type, expected arithmetic type, got ")
        error(debug::type_to_str((@right).tpe), "\n")
    }
    if not is_arithmetic((@left).tpe) {
        errorn(right, "Incompatible type, expected arithmetic type, got ")
        error(debug::type_to_str((@left).tpe), "\n")
    }

    (@node).tpe = (@left).tpe
}

def walk_AssignEqBitwise(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(node, left, state)
    walk(node, right, state)
    if not check_is_identifier_assignable(left, state) {
        return
    }

    if not (@left).tpe or not (@right).tpe { return }
    if not is_integer((@right).tpe) {
        errorn(right, "Incompatible type, expected integer type, got ")
        error(debug::type_to_str((@right).tpe), "\n")
    }
    if not is_integer((@left).tpe) {
        errorn(right, "Incompatible type, expected integer type, got ")
        error(debug::type_to_str((@left).tpe), "\n")
    }

    (@node).tpe = (@left).tpe
}

def walk_AssignEqPtr(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(node, left, state)
    walk(node, right, state)
    if not check_is_identifier_assignable(left, state) {
        return
    }

    if not (@left).tpe or not (@right).tpe { return }
    if not is_integer((@right).tpe) {
        errorn(right, "Incompatible type, expected integer type, got ")
        error(debug::type_to_str((@right).tpe), "\n")
    }
    if not is_pointer((@left).tpe) {
        errorn(right, "Incompatible type, expected pointer type, got ")
        error(debug::type_to_str((@left).tpe), "\n")
    }

    (@node).tpe = (@left).tpe
}

def walk_Cast(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    let tpe = type_lookup(right, state)
    if not tpe { return }
    (@node).tpe = tpe

    if (@left).kind == parser::NodeKind::STRUCT_LIT {
        if (@tpe).kind != TypeKind::STRUCT and
            (@tpe).kind != TypeKind::UNION {
            errorn(left, "Invalid cast\n")
            return
        }
        (@left).tpe = (@node).tpe
    }
    if (@left).kind == parser::NodeKind::ARRAY_LIT {
        if (@tpe).kind != TypeKind::ARRAY and 
            (@tpe).kind != TypeKind::STATIC_ARRAY {
            errorn(left, "Invalid cast\n")
            return
        }
    }
    walk(node, left, state)
}

def walk_Import(node: *parser::Node, state: *State) {
    if current_function(state) != null {
        errorn(node, "Can only import at top level\n")
        return
    }

    let imports = (@node).value.body
    for var i in 0..vector::length(imports) {
        let imprt = vector::get(imports, i) !*parser::Node
        var name = (@imprt).value.import_module.name
        toolchain::typecheck_module(name)
    }
}

def walk_Def(node: *parser::Node, state: *State) {
    let share = (@node).value.def_.share
    let body = (@node).value.def_.body
    let name = (@node).value.def_.name
    let params = (@node).value.def_.params
    let returns = (@node).value.def_.returns
    let extern = (@node).value.def_.extern
    let outer_scope = (@state).scope
    
    node.value.def_.is_used = true

    if not name or not params or not returns { return }

    if current_function(state) {
        if share != parser::ShareMarker::NONE {
            errorn(node, "Can't share non top level function\n")
        }
    }

    // TODO Maybe extract this into a function, see code in preprocess
    let parameter_t = vector::make()
    let return_t = vector::make()
    for var i in 0..vector::length(params) {
        let param = vector::get(params, i) !*parser::Node
        assert(param.kind == parser::NodeKind::PARAMETER)
        
        let named = allocate(NamedParameter)
        let name = param.value.param.name
        let tpe = type_lookup(param.value.param.tpe, state)
        named.name = last_ident_to_str(name)
        named.value = tpe
        named.varargs = (@param).value.param.varargs
        named.node = name
        vector::push(parameter_t, named)
    }
    for var i in 0..vector::length(returns) {
        let n = vector::get(returns, i) !*parser::Node
        let tpe = type_lookup(n, state)
        vector::push(return_t, tpe)
    }

    let tpe = make_function_type_n(name, parameter_t, return_t, extern)

    var forward_declare = true
    if body {
        forward_declare = false
        state.scope = scope::enter_function_scope((@state).scope)

        for var i in 0..vector::length(tpe.parameter_t) {
            let np = vector::get(tpe.parameter_t, i) !*NamedParameter 
            scope::create_variable(state.scope, np.node, parser::ShareMarker::NONE, parser::VarDecl::VAR, np.value, null)
        }
    }

    if current_function(state) {
        // This is so that we don't create overloaded functions
        // inside of a function
        // TODO what about forward declarations?
        scope::create_variable(outer_scope, name, share, parser::VarDecl::CONST, tpe, null)
    } else {
        scope::create_function(outer_scope, name, share, tpe, forward_declare)
    }
    
    if body {
        push_function(state, tpe)
        for var i in 0..vector::length(body) {
            walk(node, vector::get(body, i) !*parser::Node, state)
        }
        (@node).scope = (@state).scope
        (@state).scope = scope::exit_scope((@state).scope)
        pop_function(state)
    }

    node.tpe = tpe
}

def walk_TypeDecl(node: *parser::Node, state: *State) {
    let share = (@node).value.type_decl.share
    let left = (@node).value.type_decl.left
    let right = (@node).value.type_decl.right

    if vector::length(left) < vector::length(right) {
        errorn(node, "Too many values to assign\n")
        return
    }

    for var i in 0..vector::length(left) {
        let name = vector::get(left, i) !*parser::Node
        var value: *parser::Node = null
        if i < vector::length(right) {
            value = vector::get(right, i) !*parser::Node
        }
        
        var tpe = make_type(TypeKind::STUB, name)
        if value {
            tpe = scope::create_type((@state).scope, name, share, tpe, true, null, null)
            if not tpe {
                continue
            }

            tpe = copy(type_lookup(value, state))
            if not tpe { continue }
            (@tpe).name = parser::identifier_to_str(name)
            if (@value).kind == parser::NodeKind::STRUCT_T or
                (@value).kind == parser::NodeKind::UNION_T or
                (@value).kind == parser::NodeKind::ENUM_T {
                // Name anonymous struct or union
                (@tpe).type_name = append_module((@tpe).name, (@node).loc.module)
            }
            if (@value).kind == parser::NodeKind::ENUM_T {
                // Create all the constants
                let scpe = scope::enter_scope((@state).scope)
                
                // TODO Do something about negative values (btw evaluate_constant can't handle them now)
                var last_value: uint64 = 0
                for var i in 0..vector::length((@value).value.t_enum.body) {
                    let iddecl = vector::get((@value).value.t_enum.body, i) !*parser::Node

                    var constant: *uint64 = null
                    if (@iddecl).value.id_decl_enum.value {
                        constant = evaluate_constant((@iddecl).value.id_decl_enum.value) !*uint64
                    } else {
                        constant = allocate(uint64)
                        @constant = last_value
                    }

                    scope::create_variable(scpe, (@iddecl).value.id_decl_enum.ident, 
                        share, parser::VarDecl::CONST, tpe, constant)

                    last_value = @constant + 1
                }

                (@tpe).scope = scpe

                // Create to_string function
                let parameter_t = vector::make()
                let return_t = vector::make()
                let np = allocate(NamedParameter)
                @np = {
                    name = "enum",
                    value = tpe
                } !NamedParameter
                vector::push(parameter_t, np)
                vector::push(return_t, builtins::string_)

                let ident = parser::make_identifier(["to_string"])
                let ftpe = make_function_type_n(ident, parameter_t, return_t, false)
                scope::create_function((@state).scope, ident, parser::ShareMarker::EXPORT, ftpe, false)
            }
            tpe = scope::create_type((@state).scope, name, share, tpe)
        }
        (@name).tpe = tpe
    }
}

def walk_Return(node: *parser::Node, state: *State) {
    let current_fun = current_function(state)
    let body = (@node).value.body
    if not current_fun {
        // TODO This is actually allowed, I just need to infer the types
        // and assign to some sort of internal variable
        errorn(node, "return outside of a function\n")
        return
    }

    let ltypes = (@current_fun).return_t
    let rtypes = collapse_types(node, ltypes, body, state)

    if vector::length(ltypes) != vector::length(rtypes) {
        // TODO Improve error message
        errorn(node, "Wrong number of arguments to return\n")
    }

    for var i in 0..vector::length(ltypes) {
        let argtpe = vector::get(ltypes, i) !*Type
        if i >= vector::length(rtypes) { return }

        var rettpe = vector::get(rtypes, i) !*Type
        
        if not argtpe or not rettpe { continue }
        if not is_assignable(argtpe, rettpe) {
            // TODO This doesn't point to the actual value
            errorn(node, "Wrong type of return argument, got ")
            error(debug::type_to_str(rettpe), ", expected ", debug::type_to_str(argtpe), "\n")
        }
    }
    (@node).tpe = current_fun
}

def walk_Call(node: *parser::Node, state: *State) {
    let left = (@node).value.func_call.left
    if not left { return }
    walk(node, left, state)
    var tpe = (@left).tpe

    var arguments = vector::make()
    for var i in 0..vector::length((@node).value.func_call.args) {
        let n = vector::get((@node).value.func_call.args, i) !*parser::Node
        walk(node, n, state)
        let np = allocate(NamedParameter)
        (@np).name = ""
        (@np).value = (@n).tpe
        (@np).varargs = false
        (@np).node = n
        vector::push(arguments, np)
    }
    let parameter_map = map::make()
    for var i in 0..vector::length((@node).value.func_call.kwargs) {
        let n = vector::get((@node).value.func_call.kwargs, i) !*parser::Node
        walk(node, (@n).value.named_arg.value, state)
        let name = last_ident_to_str((@n).value.named_arg.name)

        if map::contains(parameter_map, name) {
            // and we cannot have two things with the same name so just error here...
            errorn(n, "Cannot have the same parameter name multiple times in a function call. Parameter name was \"")
            error(name, "\".\n")
            break
        } else {
            map::put(parameter_map, name, map::sentinel)
            let np = allocate(NamedParameter)
            (@np).name = name
            (@np).value = (@(@n).value.named_arg.value).tpe
            (@np).varargs = false
            (@np).node = (@n).value.named_arg.name
            vector::push(arguments, np)
        }
    }

    if not is_function_pointer(tpe) {
        if (@left).kind == parser::NodeKind::IDENTIFIER {
            var function = scope::get_function((@state).scope, left, arguments)

            if not function {
                errorn(left, "Function \"")
                error(parser::identifier_to_str(left), "\" not found. ")
                let len = vector::length(arguments)
                if len > 0 {
                    error("Arguments were of type ")
                } else {
                    error("No arguments.")
                }
                for var i in 0..len {
                    let arg = vector::get(arguments, i) !*NamedParameter
                    error(debug::type_to_str((@arg).value))
                    if i < len - 1 {
                        error(", ")
                    }
                }
                error("\n")
                return
            }

            tpe = (@function).tpe
        } else {
            errorn(left, "Can't call expression\n")
            return
        }
    }

    (@node).function = tpe
    if is_function_pointer(tpe) {
        tpe = (@tpe).tpe
    }
    
    let parameter_t = (@tpe).parameter_t

    // Implicit conversions
    for var i in 0..vector::length((@node).value.func_call.args) {
        let n = vector::get((@node).value.func_call.args, i) !*parser::Node
        var rhstpe: *Type
        if i < vector::length(parameter_t) {
            rhstpe = (@(vector::get(parameter_t, i) !*NamedParameter)).value
        } else {
            let np = vector::peek(parameter_t) !*NamedParameter
            assert((@np).varargs)
            rhstpe = (@np).value
        }
        
        implicit_conversion(n, rhstpe)
    }
    for var i in 0..vector::length((@node).value.func_call.kwargs) {
        let n = vector::get((@node).value.func_call.kwargs, i) !*parser::Node
        let name = last_ident_to_str((@n).value.named_arg.name)
        let arg = (@n).value.named_arg.value

        var rhstpe: *Type
        for var j in 0..vector::length(parameter_t) {
            let param = vector::get(parameter_t, j) !*NamedParameter
            if (@param).name == name {
                rhstpe = (@param).value
                break
            }
        }
        implicit_conversion(arg, rhstpe)
    }
    var return_t = (@tpe).return_t
    if (@tpe).proto {
        return_t = (@tpe).proto((@node).value.func_call.args, (@node).value.func_call.kwargs, state)
    }

    (@node).tpe = flatten_return_type(node, return_t)
}

def walk_Case(node: *parser::Node, state: *State) {
    for var i in 0..vector::length((@node).value.case_.expr) {
        let expr = vector::get((@node).value.case_.expr, i) !*parser::Node
        walk(node, expr, state)
        if not (is_arithmetic((@expr).tpe) or is_enum((@expr).tpe) or is_range((@expr).tpe)){
            errorn(expr, "Incompatible type, expected arithmetic type, range or enum, got ")
            error(debug::type_to_str((@expr).tpe), "\n")
            return
        }
    }
    for var i in 0..vector::length((@node).value.case_.body) {
        let expr = vector::get((@node).value.case_.body, i) !*parser::Node
        walk(node, expr, state)
    }
}

def walk_Switch(node: *parser::Node, state: *State) {
    let expr = (@node).value.switch_.expr
    walk(node, expr, state)
    if not (is_arithmetic((@expr).tpe) or is_enum((@expr).tpe) ){
        errorn(expr, "Incompatible type, expected arithmetic type or enum, got ")
        error(debug::type_to_str((@expr).tpe), "\n")
        return
    }

    for var i in 0..vector::length((@node).value.switch_.body) {
        walk(node, vector::get((@node).value.switch_.body, i) !*parser::Node, state)
    }
}

def walk_If(node: *parser::Node, state: *State) {
    let cond = (@node).value.if_.cond
    walk(node, cond, state)
    let tpe = (@cond).tpe
    if not tpe { return }
    if not is_boolean(tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str(tpe), ", must be boolean type\n")
    }
    
    (@state).scope = scope::enter_scope((@state).scope)
    for var i in 0..vector::length((@node).value.if_.body) {
        let n = vector::get((@node).value.if_.body, i) !*parser::Node
        walk(node, n, state)
    }
    (@state).scope = scope::exit_scope((@state).scope)

    for var i in 0..vector::length((@node).value.if_.else_if) {
        let n = vector::get((@node).value.if_.else_if, i) !*parser::Node
        
        let cond = (@n).value.else_if.cond
        walk(node, cond, state)
        let tpe = (@cond).tpe
        
        if not is_boolean(tpe) {
            errorn(n, "Incompatible type ")
            error(debug::type_to_str(tpe), ", must be boolean type\n")
        }

        (@state).scope = scope::enter_scope((@state).scope)
        for var i in 0..vector::length((@n).value.else_if.body) {
            let n2 = vector::get((@n).value.else_if.body, i) !*parser::Node
            walk(node, n2, state)
        }   
        (@state).scope = scope::exit_scope((@state).scope)
    }

    let else_ = (@node).value.if_.else_
    if else_ {
        (@state).scope = scope::enter_scope((@state).scope)
        for var i in 0..vector::length((@else_).value.body) {
            let n = vector::get((@else_).value.body, i) !*parser::Node
            walk(node, n, state)
        }
        (@state).scope = scope::exit_scope((@state).scope)
    }
}

def walk_Loop(node: *parser::Node, state: *State) {
    (@state).scope = scope::enter_scope((@state).scope)
    for var i in 0..vector::length((@node).value.body) {
        let n = vector::get((@node).value.body, i) !*parser::Node
        walk(node, n, state)
    }
    (@state).scope = scope::exit_scope((@state).scope)
}

def walk_While(node: *parser::Node, state: *State) {
    let expr = (@node).value.while_loop.expr
    walk(node, expr, state)
    if not is_boolean((@expr).tpe) {
        errorn(node, "Incompatible type ")
        error(debug::type_to_str((@expr).tpe), ", must be boolean type\n")
    }

    (@state).scope = scope::enter_scope((@state).scope)
    for var i in 0..vector::length((@node).value.while_loop.body) {
        let n = vector::get((@node).value.while_loop.body, i) !*parser::Node
        walk(node, n, state)
    }
    (@state).scope = scope::exit_scope((@state).scope)
}

def walk_For(node: *parser::Node, state: *State) {
    let expr = (@node).value.for_loop.expr
    walk(node, expr, state)
    (@state).scope = scope::enter_scope((@state).scope)

    let iddecl = (@node).value.for_loop.iddecl
    var tpe = builtins::int_
    if is_array((@expr).tpe) {
        tpe = (@(@expr).tpe).tpe
    }
    if (@iddecl).kind == parser::NodeKind::FOR_ID_DECL {
        (@iddecl).tpe = tpe
        (@iddecl).scope = (@state).scope
        scope::create_variable(
            (@state).scope, 
            (@iddecl).value.for_id_decl.ident, 
            parser::ShareMarker::NONE, 
            (@iddecl).value.for_id_decl.kw, 
            tpe, null
        )
    
    } else {
        walk(node, iddecl, state)
        if not equals(tpe, (@iddecl).tpe) {
            errorn(iddecl, "Type didn't match, expected ")
            error(debug::type_to_str(tpe), ", got ", debug::type_to_str((@iddecl).tpe))
        }
    }

    for var i in 0..vector::length((@node).value.for_loop.body) {
        let n = vector::get((@node).value.for_loop.body, i) !*parser::Node
        walk(node, n, state)
    }
    (@state).scope = scope::exit_scope((@state).scope)
}

def walk_Deref(node: *parser::Node, state: *State) {
    walk(node, (@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not tpe { return }
    if not is_pointer(tpe) {
        errorn(node, "Needs to be a pointer type, got ")
        error(debug::type_to_str(tpe), "\n")
        return
    }
    (@node).tpe = (@tpe).tpe
}

def walk_Ptr(node: *parser::Node, state: *State) {
    walk(node, (@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    (@node).tpe = pointer(tpe)
}

def walk_MemberAccess_ucs(node: *parser::Node, state: *State) -> bool {
    let right = (@node).value.bin_op.right
    let left = (@node).value.bin_op.left
    let parent = (@node).parent
    let tpe = (@left).tpe

    if (@parent).kind == parser::NodeKind::FUNC_CALL and
        (@parent).value.func_call.left == node {
        @(@parent).value.func_call.left = @right
        vector::prepend((@parent).value.func_call.args, left)
    } else {
        let parameter_t = vector::make()
        let np = allocate(NamedParameter)
        @np = {
            name = "",
            value = (@left).tpe
        } !NamedParameter
        vector::push(parameter_t, np)

        let function = scope::get_function((@node).scope, right, parameter_t)
        if not function { return false }

        let args = vector::make()
        vector::push(args, left)
        @node = {
            kind = parser::NodeKind::FUNC_CALL,
            loc = (@node).loc,
            parent = parent
        } !parser::Node
        (@node).value.func_call = {
            left = right,
            args = args,
            kwargs = vector::make()
        } !parser::NodeFuncCall
        
        walk(parent, node, state)
    }
    return true
}

def resolve_member(fields: [StructMember], name: string) -> *Type {
    for var i in 0..fields.size {
        let member = fields[i]
        if length(member.name) > 0 {
            if member.name == name {
                return member.tpe
            }
        } else {
            let member = resolve_member((@member.tpe).fields, name)
            if member { return member }
        }
    }
    return null
}

def walk_MemberAccess(node: *parser::Node, state: *State) {
    let right = (@node).value.bin_op.right
    let left = (@node).value.bin_op.left
    walk(node, left, state)
    let tpe = (@left).tpe

    if is_pointer(tpe) {
        let old_left = parser::copy_node(left)
        @left = {
            kind = parser::NodeKind::DEREF,
            loc = (@left).loc
        } !parser::Node
        (@left).value.expr = old_left

        walk(node, node, state)
        return
    }

    if not tpe { return }

    if (@tpe).kind == TypeKind::STRUCT or (@tpe).kind == TypeKind::UNION {
        let name = last_ident_to_str(right)

        var rtpe = resolve_member((@tpe).fields, name)
        if not rtpe {
            if walk_MemberAccess_ucs(node, state) { return }
            errorn(node, "Unknown field \"")
            error(name, "\"\n")
            return
        }
        (@node).tpe = rtpe
    } else if (@tpe).kind == TypeKind::ARRAY or (@tpe).kind == TypeKind::STATIC_ARRAY {
        let name = last_ident_to_str(right)
        if name == "size" {
            (@node).tpe = builtins::size_t_
        } else if name == "value" {
            (@node).tpe = pointer((@tpe).tpe)
        } else {
            if walk_MemberAccess_ucs(node, state) { return }
            errorn(node, "Expected size or value\n")
        }
    // TODO Enums might have ordinal and some other information
    } else {
        if walk_MemberAccess_ucs(node, state) { return }
        errorn(node, "Expected aggregate type, got ")
        error(debug::type_to_str(tpe), "\n")
    }
}

def walk_ArraySubscript(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right

    walk(node, left, state)
    walk(node, right, state)

    if not left or not right { return }
    let tpe = (@left).tpe
    if not tpe { return }
    if is_pointer(tpe) or (@tpe).kind == TypeKind::ARRAY or
        (@tpe).kind == TypeKind::STATIC_ARRAY {
        (@node).tpe = (@tpe).tpe
    } else {
        errorn(left, "Expected array or pointer type, got ")
        error(debug::type_to_str(tpe), "\n")
    }
    if not is_arithmetic((@right).tpe) {
        errorn(right, "Expected arithmetic type, got ")
        error(debug::type_to_str((@right).tpe), "\n")
    }
}

def walk_StructLit(node: *parser::Node, state: *State) {
    let tpe = (@node).tpe
    // This instructs compile to skip the struct literal completely
    (@node).tpe = null

    if not tpe {
        errorn(node, "Need to specify a type for struct literal\n")
        return
    }

    for var i in 0..vector::length((@node).value.struct_lit.args) {
        let n = vector::get((@node).value.struct_lit.args, i) !*parser::Node
        if i > (@tpe).fields.size {
            errorn(n, "Too many arguments to array literal\n")
            return
        }
        walk(node, n, state)
        
        var ntpe = (@tpe).fields[i].tpe
        implicit_conversion(n, ntpe)

        if not ntpe or not (@n).tpe { continue }
        if not is_assignable(ntpe, (@n).tpe) {
            errorn(n, "Incompatible types ")
            error(debug::type_to_str((@n).tpe), " and ", debug::type_to_str(ntpe), "\n")
            return
        }
    }
    for var i in 0..vector::length((@node).value.struct_lit.kwargs) {
        let kwarg = vector::get((@node).value.struct_lit.kwargs, i) !*parser::Node
        let n = (@kwarg).value.named_arg.value
        walk(node, n, state)
        let name = last_ident_to_str((@kwarg).value.named_arg.name)

        var found = false
        for var j in 0..(@tpe).fields.size {
            let field = (@tpe).fields[j]
            if field.name == name {
                found = true

                var ntpe = field.tpe
                implicit_conversion(n, ntpe)

                if not ntpe or not (@n).tpe { continue }
                if not is_assignable(ntpe, (@n).tpe) {
                    errorn(n, "Incompatible types ")
                    error(debug::type_to_str((@n).tpe), " and ", debug::type_to_str(ntpe), "\n")
                    return
                }
                break
            }
        }
        if not found {
            errorn(n, "Unknown field \"")
            error(name, "\"")
            return
        }
    }

    (@node).tpe = tpe
}

// TODO We might want to allow assignments like
// let array: [double] = [1, 2, 3, 4] // And convert to double here
def walk_ArrayLit(node: *parser::Node, state: *State) {
    var tpe: *Type = null
    let len = vector::length((@node).value.body)
    for var i in 0..len {
        let n = vector::get((@node).value.body, i) !*parser::Node
        walk(node, n, state)
        let t = (@n).tpe
        if not tpe { tpe = t }
        else {
            if not equals(tpe, t) {
                errorn(n, "Incompatible types, all array elements need to have the same type. Array type ")
                error(debug::type_to_str(tpe), ", got ", debug::type_to_str(t), "\n")
                // It might be confusing to get multiple errors here
                break
            }
        }
    }
    if not tpe {
        tpe = builtins::char_
    }
    
    let ret_tpe = make_type_raw(TypeKind::STATIC_ARRAY)
    (@ret_tpe).line = (@node).loc.line
    (@ret_tpe).length = len
    (@ret_tpe).tpe = tpe
    (@ret_tpe).size = len * (@tpe).size
    (@ret_tpe).align = (@tpe).align

    (@node).tpe = ret_tpe
}

def walk_SizeOf(node: *parser::Node, state: *State) {
    let expr = (@node).value.expr
    // Need to special case here
    if (@expr).kind == parser::NodeKind::IDENTIFIER {
        let value = scope::get((@state).scope, expr)
        if not value {
            errorn(expr, "Unknown identifier \"")
            error(parser::identifier_to_str(expr), "\"\n")
            return
        }
        if (@value).modifier == parser::VarDecl::TYPE {
            (@expr).tpe = (@value).value !*Type
        } else {
            (@expr).tpe = (@value).tpe
        }
    } else {
        (@expr).tpe = type_lookup(expr, state)
        if not (@expr).tpe {
            walk(node, expr, state)
        }
    }

    (@node).tpe = builtins::size_t_
}

def walk_AlignOf(node: *parser::Node, state: *State) {
    let expr = (@node).value.expr
    // Need to special case here
    if (@expr).kind == parser::NodeKind::IDENTIFIER {
        let value = scope::get((@state).scope, expr)
        if not value {
            errorn(expr, "Unknown identifier \"")
            error(parser::identifier_to_str(expr), "\"\n")
            return
        }
        if (@value).modifier == parser::VarDecl::TYPE {
            (@expr).tpe = (@value).value !*Type
        } else {
            (@expr).tpe = (@value).tpe
        }
    } else {
        (@expr).tpe = type_lookup(expr, state)
        if not (@expr).tpe {
            walk(node, expr, state)
        }
    }

    (@node).tpe = builtins::size_t_
}

def walk_ComparisionOp(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    walk(node, left, state)
    walk(node, right, state)
    // TODO We can compare almost everything
    (@node).tpe = builtins::bool_
}

def walk_PAdd(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    walk(node, left, state)
    walk(node, right, state)
    if not is_pointer((@left).tpe) {
        errorn(left, "Must be pointer type, got ")
        error(debug::type_to_str((@left).tpe), "\n")
    }
    if not is_arithmetic((@right).tpe) {
        errorn(left, "Must be arithmetic type, got ")
        error(debug::type_to_str((@right).tpe), "\n")
    }
    // TODO should probably not set this to a garbage value
    (@node).tpe = (@left).tpe
}

def walk_PSub(node: *parser::Node, state: *State) {
    walk_PAdd(node, state)
}

export def walk(parent: *parser::Node, node: *parser::Node, state: *State) {
    if not node { return }
    (@node).scope = (@state).scope
    (@node).parent = parent

    switch (@node).kind !int {
        case parser::NodeKind::NULL:
            walk_Null(node, state)
        case parser::NodeKind::INTEGER:
            walk_Integer(node, state)
        case parser::NodeKind::BOOLEAN:
            walk_Boolean(node, state)
        case parser::NodeKind::STRING:
            walk_String(node, state)
        case parser::NodeKind::CHAR:
            walk_Char(node, state)
        case parser::NodeKind::FLOAT:
            walk_Float(node, state)
        case parser::NodeKind::RANGE..=parser::NodeKind::RANGE_INC:
            walk_Range(node, state)
        case parser::NodeKind::IDENTIFIER:
            walk_Identifier(node, state)
        case parser::NodeKind::SIZE_OF:
            walk_SizeOf(node, state)
        case parser::NodeKind::ALIGN_OF:
            walk_AlignOf(node, state)
        case parser::NodeKind::LOOP:
            walk_Loop(node, state)
        case parser::NodeKind::WHILE:
            walk_While(node, state)
        case parser::NodeKind::FOR:
            walk_For(node, state)
        case parser::NodeKind::IF:
            walk_If(node, state)
        case parser::NodeKind::SWITCH:
            walk_Switch(node, state)
        case parser::NodeKind::CASE:
            walk_Case(node, state)
        case parser::NodeKind::DEF:
            walk_Def(node, state)
        case parser::NodeKind::IMPORT:
            walk_Import(node, state)
        case parser::NodeKind::CAST:
            walk_Cast(node, state)
        case parser::NodeKind::ASSIGN:
            walk_Assign(node, state)
        case parser::NodeKind::VAR_DECL:
            walk_VarDecl(node, state)
        case parser::NodeKind::UADD:
            walk_UAdd(node, state)
        case parser::NodeKind::USUB:
            walk_USub(node, state)
        case parser::NodeKind::BNOT:
            walk_BNot(node, state)
        case parser::NodeKind::NOT:
            walk_Not(node, state)
        case parser::NodeKind::ADD..=parser::NodeKind::MOD:
            walk_ArithmeticOp(node, state)
        case parser::NodeKind::BAND..=parser::NodeKind::SHR:
            walk_BitwiseOp(node, state)
        case parser::NodeKind::AND..=parser::NodeKind::OR:
            walk_BooleanOp(node, state)
        case parser::NodeKind::EQ..=parser::NodeKind::LEQ:
            walk_ComparisionOp(node, state)
        case parser::NodeKind::ADD_EQ..=parser::NodeKind::MOD_EQ:
            walk_AssignEqArithmetic(node, state)
        case parser::NodeKind::AND_EQ..=parser::NodeKind::SHR_EQ:
            walk_AssignEqBitwise(node, state)
        case parser::NodeKind::PADD_EQ..=parser::NodeKind::PSUB_EQ:
            walk_AssignEqPtr(node, state)
        case parser::NodeKind::PADD:
            walk_PAdd(node, state)
        case parser::NodeKind::PSUB:
            walk_PSub(node, state)
        case parser::NodeKind::DEREF:
            walk_Deref(node, state)
        case parser::NodeKind::PTR:
            walk_Ptr(node, state)
        case parser::NodeKind::TYPE_DECL:
            walk_TypeDecl(node, state)
        case parser::NodeKind::RETURN:
            walk_Return(node, state)
        case parser::NodeKind::FUNC_CALL:
            walk_Call(node, state)
        case parser::NodeKind::BREAK..=parser::NodeKind::CONTINUE:
            // Noop
            null
        case parser::NodeKind::MEMBER_ACCESS:
            walk_MemberAccess(node, state)
        case parser::NodeKind::ARRAY_SUBSCRIPT:
            walk_ArraySubscript(node, state)
        case parser::NodeKind::STRUCT_LIT:
            walk_StructLit(node, state)
        case parser::NodeKind::ARRAY_LIT:
            walk_ArrayLit(node, state)
        case parser::NodeKind::PTR_T:
            walk_PtrT(node, state)
        case:
            error((@node).kind, "\n")
            assert(false)
    }
}

export def typecheck(module: *toolchain::Module) {
    let node = (@module).node
    assert((@node).kind == parser::NodeKind::PROGRAM)

    let state = {
        filename = (@module).filename,
        module = (@module).module,
        scope = (@module).scope,
        function_stack = vector::make()
    } !State

    (@node).scope = state.scope
   
    let string_array_tpe = array(builtins::string_)
    let args_ident = parser::make_identifier(["args"])
    scope::create_variable(
        (@node).scope, 
        args_ident, 
        parser::ShareMarker::NONE, 
        parser::VarDecl::VAR, 
        string_array_tpe, null
    )
    let value = scope::get((@node).scope, args_ident)
    (@value).global = false
    
    if state.module != "cstd" and state.module != "std" {
        // compile standard library
        toolchain::typecheck_module(parser::make_identifier(["cstd"]))
        toolchain::typecheck_module(parser::make_identifier(["std"]))
    }

    for var i in 0..vector::length((@node).value.body) {
        let n = vector::get((@node).value.body, i) !*parser::Node
        switch n.kind !int {
            case parser::NodeKind::TYPE_DECL, parser::NodeKind::DEF:
            case: walk(node, n, *state)
        }
    }
}

// TODO Make this function variadic
export def errorn(node: *parser::Node, msg: string) {
    if not node { assert(false) }
    let filename = (@node).loc.filename
    let line = (@node).loc.line
    let column = (@node).loc.column

    error("\n")
    error(filename, "@", line + 1, ":", column + 1, "\n")
    error((@node).loc.lines[line], "\n")
    for var i in 0..column {
        error(" ")
    }
    error("^\n")
    error(msg)

    toolchain::error_count += 1
}