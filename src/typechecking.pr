// TODO Many of these function will error twice with misleading errors
// Every function needs to check for possible null types and null nodes
// and abort in those cases

import map
import vector
import parser
import buffer
import util
import scope
import builtins
import debug
import toolchain
import compiler
import preprocess
import errors
import runtime

export type TypeKind = enum {
    TYPE
    WORD
    FLOAT
    BOOL
    STRUCT
    UNION
    ENUM
    FUNCTION
    TUPLE
    POINTER
    REFERENCE
    ARRAY
    STATIC_ARRAY
    RANGE
    RANGE_INC
    // Used for enums
    NAMESPACE
    // Auto cast, this type will convert to anything
    // AUTO_CAST // TODO Actually implement this
    // Forward declaration
    STUB
    // Placeholder for arguments with polymorphic type parameter in function definition
    TYPE_DEF
    // Null
    NULL
}

export type StructMember = struct {
    // Source line
    line: int
    name: string
    tpe: *Type
    offset: size_t
}

export type Type = struct {
    kind: TypeKind
    // Source line
    line: int
    // Name of the type as used by the source code
    // Might be the name of a typedef
    name: string
    // Unique name of the type
    type_name: string
    // Size in bytes
    size: size_t
    align: size_t
    unsig: bool
    // TODO Add kw (parser::VarDecl) for arrays and pointers
    // Static array
    length: size_t
    kw: parser::VarDecl
    // Type both used for array/pointer and enum
    // This is also used for type arguments to specify the actual type
    tpe: *Type
    packed: bool
    // Fields for struct, array of StructMember
    fields: [StructMember]
    // Biggest field of a union
    biggest_field: *StructMember
    // Function and Tuple
    // Vector of Type
    return_t: *vector::Vector
    // Vector of NamedParameter
    parameter_t: *vector::Vector
    // Macro for builtin functions
    macro: (*parser::Node, [compiler::Value], *compiler::State) -> compiler::Value
    // This calculates the return types for functions 
    // where the return types depend on the argument types
    proto: (*vector::Vector, *vector::Vector, *State) -> (*vector::Vector)
    //          args            kwargs                        return_t
    // Enum scope
    scope: *scope::Scope
    // For functions
    imported: bool
    is_polymorph: bool
}

export type NamedParameter = struct {
    // Might be empty for positional parameters
    name: string
    tpe: *Type
    varargs: bool
    node: *parser::Node
    value: *compiler::Value
}

export type Function = struct {
    tpe: *Type
    locals: *map::Map
    has_defer: bool
}

export type State = struct {
    module: *toolchain::Module
    counter: int
    scope: *scope::Scope
    // Vector of Type
    function_stack: *vector::Vector
    // Used by preprocess
    is_static: bool
    is_compiling_function: bool
}

export def current_function(state: *State) -> *Function {
    let length = vector::length((@state).function_stack)
    if length == 0 {
        return null
    } else {
        return vector::get((@state).function_stack, length - 1) !*Function
    }
}

export def push_function(state: *State, function: *Function) {
    vector::push((@state).function_stack, function)
}

export def pop_function(state: *State) -> *Function {
    return vector::pop((@state).function_stack) !*Function
}

export def is_function(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::FUNCTION
}

export def is_function_pointer(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::POINTER and 
        is_function((@tpe).tpe)
}

export def is_integer(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::WORD or 
        (@tpe).kind == TypeKind::BOOL
}

export def is_arithmetic(tpe: *Type) -> bool {
    if not tpe { return false }
    return is_integer(tpe) or 
        (@tpe).kind == TypeKind::FLOAT
}

export def is_float(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::FLOAT
}

// TODO Also allow arrays and strings
export def is_boolean(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::BOOL or
        (@tpe).kind == TypeKind::WORD or
        (@tpe).kind == TypeKind::FLOAT or
        (@tpe).kind == TypeKind::POINTER or
        (@tpe).kind == TypeKind::REFERENCE
}

export def is_pointer(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::POINTER
    // TODO What about references?
}

export def is_ref(tpe: *Type) -> bool {
    if not tpe { return false }
    return tpe.kind == TypeKind::REFERENCE
}

export def is_struct(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::STRUCT or
        (@tpe).kind == TypeKind::UNION
}

export def is_enum(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::ENUM
}

export def is_type(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::TYPE
}

export def is_array(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::ARRAY or
        (@tpe).kind == TypeKind::STATIC_ARRAY
}

export def is_range(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::RANGE or
        (@tpe).kind == TypeKind::RANGE_INC
}

export def is_stub(tpe: *Type) -> bool {
    if not tpe { return true }
    return (@tpe).kind == TypeKind::STUB
}

export def append_module(name: string, module: string) -> string {
    var buf = buffer::make_buffer()
    if length(module) > 0 {
        buffer::append_str(*buf, module)
        buffer::append_str(*buf, "::")
    }
    buffer::append_str(*buf, name)
    return buffer::to_string(*buf)
}

export def make_type_raw(kind: TypeKind) -> *Type {
    let tpe = allocate(Type)
    @tpe = {
        type_name = "",
        name = "",
        line = -1,
        kind = kind
    }
    return tpe
}

export def make_type(kind: TypeKind, node: *parser::Node) -> *Type {
    assert((@node).kind == parser::NodeKind::IDENTIFIER)
    let name = parser::identifier_to_str(node)
    var t = make_type_raw(kind)
    (@t).line = (@node).loc.line
    (@t).type_name = append_module(name, (@node).loc.module)
    (@t).name = name

    return t
}

export def make_function_type() -> *Type {
    let tpe = make_type_raw(TypeKind::FUNCTION)
    (@tpe).size = size_of type () -> ()
    (@tpe).align = align_of type () -> ()
    (@tpe).macro = null
    (@tpe).proto = null
    (@tpe).imported = false
    return tpe
}

export def make_function_type_n(name: *parser::Node, parameter_t: *vector::Vector, return_t: *vector::Vector, extern: bool, imported: bool) -> *Type {
    let tpe = make_function_type()
    (@tpe).parameter_t = parameter_t
    (@tpe).return_t = return_t
    (@tpe).name = parser::identifier_to_str(name, false)
    if extern {
        (@tpe).type_name = (@tpe).name
    } else {
        (@tpe).type_name = mangle_function_name(append_module((@tpe).name, (@name).loc.module), parameter_t)
    }
    (@tpe).line = (@name).loc.line
    (@tpe).imported = imported
    return tpe
}

export def pointer(tpe: *Type, kw: parser::VarDecl) -> *Type {
    var t = make_type_raw(TypeKind::POINTER)
    (@t).tpe = tpe
    (@t).kw = kw
    (@t).size = (size_of type *)
    (@t).align = (align_of type *)
    return t
}

// TODO Use default arguments for this, right now its bugged (it doesn't define the type)
export def pointer(tpe: *Type) -> *Type {
    return pointer(tpe, parser::VarDecl::VAR)
}

export def reference(tpe: *Type, kw: parser::VarDecl) -> *Type {
    var t = make_type_raw(TypeKind::REFERENCE)
    t.tpe = tpe
    t.kw = kw
    // TODO replace with correct size_of once this is implemented
    t.size = (size_of runtime::Ref)
    t.align = (align_of runtime::Ref)
    return t
}

export def reference(tpe: *Type) -> *Type {
    return reference(tpe, parser::VarDecl::VAR)
}

export def array(tpe: *Type, kw: parser::VarDecl) -> *Type {
    var t = make_type_raw(TypeKind::ARRAY)
    (@t).tpe = tpe
    // TODO This is really bad, sure string is an array but we can do better than this
    (@t).size = (size_of string)
    (@t).align = (align_of string)
    (@t).kw = kw
    return t
}

export def array(tpe: *Type) -> *Type {
    return array(tpe, parser::VarDecl::VAR)
}

export def make_static_array(array_tpe: *Type, size: size_t, kw: parser::VarDecl) -> *Type {
    let tpe = make_type_raw(TypeKind::STATIC_ARRAY)
    (@tpe).tpe = array_tpe
    (@tpe).length = size
    (@tpe).size = (@tpe).length * (@array_tpe).size
    (@tpe).align = (@array_tpe).align
    (@tpe).kw = kw
    return tpe
}

export def make_static_array(array_tpe: *Type, size: size_t) -> *Type {
    return make_static_array(array_tpe, size, parser::VarDecl::VAR)
}

def make_unique_name(name: string, state: *State) -> string {
    let buf = buffer::make_buffer()
    buffer::append_str(*buf, name)
    buffer::append_char(*buf, '.')
    let s = util::int_to_str((@state).counter)
    buffer::append_str(*buf, s)

    (@state).counter += 1
    return buffer::to_string(*buf)
}

export def make_anonymous_type(kind: TypeKind) -> *Type {
    var t = allocate(Type)
    @t = {
        line = -1,
        kind = kind,
        type_name = "",
        name = ""
    } !Type
    return t
}

// TODO Not a deep copy
export def copy(a: *Type) -> *Type {
    if not a { return null }
    var t = allocate(Type)
    @t = @a

    if a.kind == TypeKind::FUNCTION {
        t.return_t = vector::make()
        for var i in 0..vector::length(a.return_t) {
            vector::push(t.return_t, copy(vector::get(a.return_t, i) !*Type))
        }
        t.parameter_t = vector::make()
        for var i in 0..vector::length(a.parameter_t) {
            let np = vector::get(a.parameter_t, i) ! *NamedParameter
            let np2 = allocate(NamedParameter)
            @np2 = @np
            np2.tpe = copy(np.tpe)
            vector::push(t.parameter_t, np2)
        }
    }

    return t
}

export def equals(a: *Type, b: *Type) -> bool {
    if a == b {
        return true
    }
    if not a or not b { return false }

    if a.kind == TypeKind::STUB or b.kind == TypeKind::STUB {
        return a.type_name == b.type_name
    }

    if (@a).kind != (@b).kind { return false }

    let kind = (@a).kind
    if kind == TypeKind::BOOL or kind == TypeKind::TYPE { return true }
    if kind == TypeKind::WORD {
        return (@a).size == (@b).size and (@a).unsig == (@b).unsig
    }
    if kind == TypeKind::FLOAT {
        return (@a).size == (@b).size
    }
    if kind == TypeKind::ENUM or
        kind == TypeKind::STRUCT or
        kind == TypeKind::UNION or
        kind == TypeKind::STUB {
        
        return (@a).type_name == (@b).type_name
    }
    if kind == TypeKind::ARRAY or
        kind == TypeKind::POINTER or
        kind == TypeKind::REFERENCE {
        
        return equals((@a).tpe, (@b).tpe)
    }
    if kind == TypeKind::STATIC_ARRAY {
        return (@a).length == (@b).length and equals((@a).tpe, (@b).tpe)
    }
    if kind == TypeKind::FUNCTION {
        if vector::length((@a).parameter_t) != vector::length((@b).parameter_t) or
            vector::length((@a).return_t) != vector::length((@b).return_t) {
            return false        
        }
        for var i in 0..vector::length((@a).parameter_t) {
            let param_a = vector::get((@a).parameter_t, i) !*NamedParameter
            let param_b = vector::get((@b).parameter_t, i) !*NamedParameter
            if not equals((@param_a).tpe, (@param_b).tpe) {
                return false
            }
        }
        for var i in 0..vector::length((@a).return_t) {
            if not equals(vector::get((@a).return_t, i) !*Type, vector::get((@b).return_t, i) !*Type) {
                return false
            }
        }
        return true
    }

    assert(false)
}

// Returns true if b is assignable to a
def is_assignable(a: *Type, b: *Type) -> bool {
    if equals(a, b) { return true }
    if (@a).kind == TypeKind::WORD {
        if (@b).kind == TypeKind::WORD {
            return (@a).size >= (@b).size
        }
        // TODO Move this to implicit conversion
        /*if (@b).kind == TypeKind::INT_LITERAL {
            if (@a).unsig {
                var i: uint64 = (@b).i * (@b).sign
                switch (@a).size {
                    case 1: return i <= util::MAX_UINT8
                    case 2: return i <= util::MAX_UINT16
                    case 4: return i <= util::MAX_UINT32
                    case 8: return true
                    case: assert(false)
                }
            } else {
                if (@b).i > util::MAX_INT64 { return false }
                var i: int64 = (@b).i * (@b).sign
                switch (@a).size {
                    case 1: return i >= util::MIN_INT8  and i <= util::MAX_INT8
                    case 2: return i >= util::MIN_INT16 and i <= util::MAX_INT16
                    case 4: return i >= util::MIN_INT32 and i <= util::MAX_INT32
                    case 8: return true
                    case: assert(false)
                }
            }
        }*/
    }
    if (@a).kind == TypeKind::FLOAT {
        if (@b).kind == TypeKind::WORD or
            (@b).kind == TypeKind::FLOAT {
            return true
        }
    }
    if (@a).kind == TypeKind::ARRAY {
        if (@b).kind == TypeKind::STATIC_ARRAY {
            return equals((@a).tpe, (@b).tpe)
        }
    }
    if ((@a).kind == TypeKind::POINTER or (@a).kind == TypeKind::REFERENCE) and
        (@b).kind == TypeKind::NULL {
        return true
    }
    if a.kind == TypeKind::REFERENCE and equals(a.tpe, b) {
        return true
    }
    if (@a).kind == TypeKind::POINTER and (@a).tpe == null {
        return (@b).kind == TypeKind::POINTER
    }
    if (@a).kind == TypeKind::REFERENCE and (@a).tpe == null {
        return (@b).kind == TypeKind::REFERENCE
    }
    return false
}

// Tries to convert type b to type a
// The return value is -1 if b can't be converted to a
// if the types are equal, 0 is returned.
// Otherwise a positive integer is returned.
def convert_type_score(a: *Type, b: *Type, is_type: bool = false) -> int {
    if not a or not b { return 0 }
    if equals(a, b) {
        return 0
    }
    
    // We need to check if they are actually compatible elsewhere
    if a.kind == TypeKind::TYPE_DEF {
        return convert_type_score(a.tpe, b, true)
    }
    if a.kind == TypeKind::TYPE and equals(b, pointer(get_type_type())) { 
        return 1 
    }
    if ((@a).kind == TypeKind::POINTER or (@a).kind == TypeKind::REFERENCE) and (@b).kind == TypeKind::NULL {
        return 0
    }
    if (@a).kind == TypeKind::WORD and (@b).kind == TypeKind::WORD and
        (@a).size >= (@b).size {
        
        // TODO if we are ever going to allow a 24 bit value this is going to fail
        return log2((@a).size) !int - log2((@b).size) !int
    }
    if (@a).kind == TypeKind::FLOAT and (@b).kind == TypeKind::FLOAT {
        // TODO This works because there are only two float sizes
        return 1
    }
    if (@a).kind == TypeKind::FLOAT and
        (@b).kind == TypeKind::WORD {
        
        return 10
    }
    if ((@a).kind == TypeKind::POINTER and (@b).kind == TypeKind::POINTER or
        (@a).kind == TypeKind::REFERENCE and (@b).kind == TypeKind::REFERENCE) and
        (@a).tpe == null {
        
        return 1
    }
    if (@a).kind == TypeKind::ARRAY {
        if (@b).kind == TypeKind::STATIC_ARRAY and equals((@a).tpe, (@b).tpe) {
            return 1
        }
        if (@a).tpe == null and ((@b).kind == TypeKind::ARRAY or (@b).kind == TypeKind::STATIC_ARRAY) {
            return 1
        }
    }
    if is_type { 
        if a.kind == TypeKind::ARRAY and (b.kind == TypeKind::ARRAY or b.kind == TypeKind::STATIC_ARRAY) {
            return convert_type_score(a.tpe, b.tpe, true)
        }
        if a.kind == TypeKind::POINTER or a.kind == TypeKind::REFERENCE or a.kind == TypeKind::STATIC_ARRAY {
            if a.kind == b.kind {
                return convert_type_score(a.tpe, b.tpe, true)
            }
            return -1
        }
        return 1
    }
    return -1
}

export def is_polymorph(tpe: *Type) -> bool {
    if not tpe { return false }
    if tpe.kind == TypeKind::TYPE_DEF or tpe.kind == TypeKind::TYPE { return true }
    else if tpe.kind == TypeKind::POINTER or tpe.kind == TypeKind::REFERENCE or
        tpe.kind == TypeKind::STATIC_ARRAY or tpe.kind == TypeKind::ARRAY {
        return is_polymorph(tpe.tpe)
    } else if tpe.kind == TypeKind::FUNCTION or tpe.kind == TypeKind::TUPLE {
        for var i in 0..vector::length(tpe.parameter_t) {
            let np = vector::get(tpe.parameter_t, i) !*NamedParameter
            if is_polymorph(np.tpe) {
                return true
            }
        }
    }
    return false
}

def find_type_defs(left: *Type, right: *Type, types: *map::Map, replace: bool, is_type: bool = false) {
    if not left or not right { return }

    if left.kind == TypeKind::TYPE_DEF {
        find_type_defs(left.tpe, right, types, replace, true)
        if replace { @left = @right }
    } else if left.kind == TypeKind::POINTER or left.kind == TypeKind::REFERENCE or 
        left.kind == TypeKind::STATIC_ARRAY or left.kind == TypeKind::ARRAY {
        find_type_defs(left.tpe, right.tpe, types, replace, is_type)
    } else if left.kind == TypeKind::FUNCTION or left.kind == TypeKind::TUPLE {
        for var i in 0..vector::length(left.parameter_t) {
            let l = vector::get(left.parameter_t, i) !*NamedParameter
            let r = vector::get(right.parameter_t, i) !*NamedParameter
            find_type_defs(l.tpe, r.tpe, types, replace, is_type)
        }
    }
    if is_type {
        map::put(types, left.name, right)
    }
}

def replace_parameter(tpe: *Type, types: *map::Map) -> *Type {
    if tpe.kind == TypeKind::POINTER or tpe.kind == TypeKind::REFERENCE or 
        tpe.kind == TypeKind::STATIC_ARRAY or tpe.kind == TypeKind::ARRAY {
        if tpe.tpe {
            tpe.tpe = replace_parameter(tpe.tpe, types)
        }
    } else if tpe.kind == TypeKind::FUNCTION or tpe.kind == TypeKind::TUPLE {
        for var i in 0..vector::length(tpe.parameter_t) {
            let np = vector::get(tpe.parameter_t, i) !*NamedParameter
            np.tpe = replace_parameter(np.tpe, types)
        }
    } else if length(tpe.name) > 0 {
        let ntpe = map::get(types, tpe.name) !*Type
        if ntpe { return ntpe }
    }
    return tpe
}

export def replace_type_defs(a: *Type, param_b: *vector::Vector, replace: bool, types_map: *map::Map) {
    let param_a = a.parameter_t

    for var i in 0..vector::length(param_a) {
        let left = vector::get(param_a, i) !*NamedParameter
        
        let ltpe = left.tpe
        if not ltpe { continue }

        var right: *NamedParameter = null
        for var j in 0..vector::length(param_b) {
            let r = vector::get(param_b, j) !*NamedParameter
            if length(r.name) > 0 and r.name == left.name {
                right = r
                break
            }
        }
        if not right and vector::length(param_a) <= vector::length(param_b) {
            right = vector::get(param_b, i) !*NamedParameter
        }

        var rtpe: *Type = null
        if right {
            rtpe = right.tpe
        }
        if not right and left.value {
            rtpe = left.value.tpe
        }
        
        if not rtpe { return }
        if convert_type_score(ltpe, rtpe) < 0 { return }

        let types = map::make()
        if ltpe.kind == TypeKind::TYPE {
            if length(ltpe.name) > 0 and right.value {
                map::put(types, ltpe.name, right.value.value_tpe)
            }
        } else {
            find_type_defs(ltpe, rtpe, types, replace)
        }

        for var j in (i + 1)..vector::length(param_a) {
            let np = vector::get(param_a, j) !*NamedParameter
            if np.tpe {
                np.tpe = replace_parameter(np.tpe, types)
            }
        }
        for var j in 0..vector::length(a.return_t) {
            let rtpe = vector::get(a.return_t, j) !*Type
            vector::set(a.return_t, j, replace_parameter(rtpe, types))
        }

        if types_map {
            let keys = map::keys(types)
            for var i in 0..keys.size {
                let key = keys[i]
                map::put(types_map, key, map::get(types, key))
            }
        }

        free(types.entries.value)
        free(types)
    }
}

// Calculates a score for overload resultion, the result is 0 for an exact match
// and a positive integer if the argument types need to be converted.
// -1 is returned if the argument types don't match.
export def overload_score(a: *Type, param_b: *vector::Vector, positional: bool) -> int {
    assert(is_function(a))
    // We need to copy because looking up the typed arguments modifies the function type
    a = copy(a)

    var param_a = (@a).parameter_t
    if vector::length(param_a) > vector::length(param_b) {
        let not_default_param = (vector::get(param_a, vector::length(param_b)) !*NamedParameter).value == null
        if vector::length(param_a) == vector::length(param_b) + 1 {
            if not (@(vector::peek(param_a) !*NamedParameter)).varargs and not_default_param {
                return -1
            }
        } else if not_default_param {
            return -1
        }
    }

    replace_type_defs(a, param_b, false, null)

    var sum = 0
    for var i in 0..vector::length(param_b) {
        let right = vector::get(param_b, i) !*NamedParameter
        var left: *NamedParameter = null
        if length((@right).name) > 0 and not positional {
            for var i in 0..vector::length(param_a) {
                let param = vector::get(param_a, i) !*NamedParameter
                if (@right).name == (@param).name {
                    left = param
                    break
                }
            }
            if not left { return -1 }
        } else {
            if i < vector::length(param_a) {
                left = vector::get(param_a, i) !*NamedParameter
            } else if vector::length(param_a) > 0 {
                left = vector::peek(param_a) !*NamedParameter
                if not (@left).varargs {
                    return -1
                } 
            } else {
                return -1
            }
        }
        var lvalue = left.tpe
        if i == vector::length(param_a) - 1 and 
            left.varargs and left.tpe and
            convert_type_score(array(left.tpe), right.tpe) != -1 {

            lvalue = array(left.tpe)
        }
        var score = -1
        if lvalue and lvalue.kind == TypeKind::TYPE {
            if equals(right.tpe, pointer(get_type_type())) {
                if left.value {
                    if equals(left.value.value_tpe, right.tpe.tpe) {
                        score = 0
                    }
                } else {
                    score = 1
                }
            } else if right.tpe.kind == TypeKind::TYPE and left.value and right.value and equals(left.value.value_tpe, right.value.value_tpe) {
                score = 0
            }
        } else {
            score = convert_type_score(lvalue, right.tpe)
        }
        if score < 0 { return -1 }
        sum += score
    }
    return sum
}

export def mangle_function_name(name: string, parameter_t: *vector::Vector) -> string {
    var buf = buffer::make_buffer()
    buffer::append_str(*buf, name)
    buffer::append_str(*buf, "::(")

    let len = vector::length(parameter_t)
    for var i in 0..len {
        let np = vector::get(parameter_t, i) !*NamedParameter
        if np.varargs {
            buffer::append_char(*buf, '[')
        }
        if np.tpe.kind == TypeKind::TYPE {
            buffer::append_str(*buf, "type")
            if np.value {
                buffer::append_char(*buf, '<')
                buffer::append_str(*buf, debug::type_to_str(np.value.value_tpe, true))
                buffer::append_char(*buf, '>')
            }
        } else {
            buffer::append_str(*buf, debug::type_to_str(np.tpe, true))
        }
        if np.varargs {
            buffer::append_char(*buf, ']')
        }
        if i < len - 1 {
            buffer::append_str(*buf, ", ")
        }
    }
    buffer::append_char(*buf, ')')

    return buffer::to_string(*buf)
}

// TODO Move this into parser
export def last_ident_to_str(node: *parser::Node) -> string {
    if not node { return "" }
    assert((@node).kind == parser::NodeKind::IDENTIFIER)
    if vector::length((@node).value.identifier.path) > 1 {
        errors::errorn(node, "Expected plain identifier without path")
    }
    return @(vector::get((@node).value.identifier.path, 0) !*string)
}

def flatten_return_type(node: *parser::Node, return_t: *vector::Vector) -> *Type {
    let len = vector::length(return_t) 
    if len > 1 {
        // TODO size and alignment! Same as a struct,
        // also refactor type_lookup and compiler (functions with multiple return types)
        // into a single function for calculating the size and alignmenet of a struct
        let return_tpe = make_type_raw(TypeKind::TUPLE)
        (@return_tpe).line = (@node).loc.line
        (@return_tpe).return_t = return_t
        return return_tpe
    } else if len == 1 {
        return vector::peek(return_t) !*Type
    }

    return null
}

def check_is_identifier_assignable(node: *parser::Node, state: *State) -> bool {
    if node.kw != parser::VarDecl::VAR {
        errors::errorn(node, "Assignment to non var")
        return false
    }
    return true
}

export def type_lookup(node: *parser::Node, state: *State, lookup_default: bool) -> *Type {
    if not node { return null }
    if (@node).kind == parser::NodeKind::IDENTIFIER {
        if not lookup_default {
            return scope::get_type(state.scope, node)
        } else {
            let value = scope::get(state.scope, node, false, false)
            var tpe: *Type = null
            if value {
                if value.modifier != parser::VarDecl::TYPE {
                    errors::errorn(node, "`", parser::identifier_to_str(node), "` is not a type")
                    return null
                }
                tpe = value.value.value_tpe
            } else {
                tpe = make_type(TypeKind::STUB, node)
                tpe = scope::create_type(state.scope, node, parser::ShareMarker::NONE, tpe, scope::Phase::DECLARED, null, null)
            }
            return tpe
        }
    } else if (@node).kind == parser::NodeKind::PTR_T {
        let tpe = type_lookup((@node).value.t_parr.tpe, state, lookup_default)
        return pointer(tpe, node.value.t_parr.kw)
    } else if node.kind == parser::NodeKind::REF_T {
        let tpe = type_lookup(node.value.t_parr.tpe, state, lookup_default)
        return reference(tpe, node.value.t_parr.kw)
    } else if (@node).kind == parser::NodeKind::STRUCT_T {
        let tpe = make_anonymous_type(TypeKind::STRUCT)
        (@tpe).type_name = make_unique_name("<anonymous>", state)
        (@tpe).name = "<anonymous>"
        (@tpe).packed = false
        
        let length = vector::length((@node).value.body)
        if length == 0 {
            errors::errorn(node, "Empty struct not allowed")
            return null
        }

        let fields = allocate(StructMember, length)

        var offset = 0 !size_t
        var align = 1 !size_t
        for var i in 0..length {
            let field = vector::get((@node).value.body, i) !*parser::Node
            let line = (@field).loc.line

            var tpe: *Type = null
            var name = ""

            if (@field).kind == parser::NodeKind::ID_DECL_STRUCT {
                let ident = (@field).value.id_decl_struct.ident
                name = last_ident_to_str(ident)
                tpe = type_lookup((@field).value.id_decl_struct.tpe, state, lookup_default)
            } else if (@field).kind == parser::NodeKind::STRUCT_T or
                (@field).kind == parser::NodeKind::UNION_T {
                tpe = type_lookup(field, state, lookup_default)
            }
            
            if is_stub(tpe) {
                fields[i] = { line, name, null, offset } !StructMember
                continue 
            }
            
            offset = (ceil(offset / (@tpe).align !double) * (@tpe).align) !int
            align = util::lcm(align !int, (@tpe).align !int)

            fields[i] = { line, name, tpe, offset } !StructMember
            offset += (@tpe).size
        }
        offset = (ceil(offset / align !double) * align) !int
        assert(offset > 0)
        
        (@tpe).line = (@node).loc.line
        (@tpe).size = offset
        (@tpe).align = align
        (@tpe).fields = fields

        return tpe
    } else if (@node).kind == parser::NodeKind::UNION_T {
        let tpe = make_anonymous_type(TypeKind::UNION)
        (@tpe).type_name = make_unique_name("<anonymous>", state)
        (@tpe).name = "<anonymous>"

        let length = vector::length((@node).value.body)
        if length == 0 {
            errors::errorn(node, "Empty union not allowed")
            return null
        }

        let fields = allocate(StructMember, length)

        var size = 0 !size_t
        var align = 1 !size_t
        for var i in 0..length {
            let field = vector::get((@node).value.body, i) !*parser::Node
            let line = (@field).loc.line
            
            var field_tpe: *Type = null
            var name = ""

            if (@field).kind == parser::NodeKind::ID_DECL_STRUCT {
                let ident = (@field).value.id_decl_struct.ident
                name = last_ident_to_str(ident)
                field_tpe = type_lookup((@field).value.id_decl_struct.tpe, state, lookup_default)
            } else if (@field).kind == parser::NodeKind::STRUCT_T or
                (@field).kind == parser::NodeKind::UNION_T {
                field_tpe = type_lookup(field, state, lookup_default)
            }
            
            if is_stub(field_tpe) {
                fields[i] = { line, name, null, 0 } !StructMember
                continue 
            }

            fields[i] = { line, name, field_tpe, 0 } !StructMember

            if field_tpe.size > size {
                size = field_tpe.size
                tpe.biggest_field = *fields[i]
            }
            align = max(field_tpe.align, align) !size_t
        }

        (@tpe).line = (@node).loc.line
        (@tpe).size = size
        (@tpe).align = align
        (@tpe).fields = fields

        return tpe
    } else if (@node).kind == parser::NodeKind::ENUM_T {
        var enum_tpe = builtins::int_
        if (@node).value.t_enum.tpe {
            enum_tpe = type_lookup((@node).value.t_enum.tpe, state, lookup_default)
        }
        let tpe = make_anonymous_type(TypeKind::ENUM)
        (@tpe).line = (@node).loc.line
        (@tpe).tpe = enum_tpe
        (@tpe).size = (@enum_tpe).size
        (@tpe).align = (@enum_tpe).align

        return tpe
    } else if (@node).kind == parser::NodeKind::ARRAY_T {
        let array_tpe = type_lookup((@node).value.t_parr.tpe, state, lookup_default)
        return array(array_tpe, node.value.t_parr.kw)
    } else if (@node).kind == parser::NodeKind::ARRAY_STATIC_T {
        let array_tpe = type_lookup((@node).value.t_arrs.tpe, state, lookup_default)

        return make_static_array(array_tpe, (@(@node).value.t_arrs.n).value.i, node.value.t_arrs.kw)
    } else if (@node).kind == parser::NodeKind::FUNCTION_T {
        let tpe = make_function_type()
        (@tpe).line = (@node).loc.line
        (@tpe).parameter_t = vector::make()
        for var i in 0..vector::length((@node).value.t_func.args) {
            let arg = vector::get((@node).value.t_func.args, i) !*parser::Node
            let np = allocate(NamedParameter)
            (@np).varargs = false
            (@np).name = ""
            (@np).tpe = type_lookup(arg, state, lookup_default)
            (@np).node = arg
            vector::push((@tpe).parameter_t, np)
        }
        (@tpe).return_t = vector::make()
        for var i in 0..vector::length((@node).value.t_func.ret) {
            let arg = vector::get((@node).value.t_func.ret, i) !*parser::Node
            vector::push((@tpe).return_t, type_lookup(arg, state, lookup_default))
        }
        return pointer(tpe)
    } else if node.kind == parser::NodeKind::TYPE_T {
        let wrapped = type_lookup(node.value.expr, state, lookup_default)
        let tpe = make_anonymous_type(TypeKind::TYPE_DEF)
        tpe.line = node.loc.line
        tpe.tpe = wrapped
        return tpe
    }

    return null
}

export def type_lookup(node: *parser::Node, state: *State) -> *Type {
    return type_lookup(node, state, false)
}

// Returns the common type of two arithmetic types
// byte -> ubyte -> short -> ushort -> int -> uint -> long -> ulong
export def common_type(a: *Type, b: *Type) -> *Type {
    if not a or not b { return null }

    //TODO Should cause an error
    //assert(is_arithmetic(a) and is_arithmetic(b))

    if (@a).kind == TypeKind::FLOAT and (@b).kind == TypeKind::WORD {
        return a
    } else if (@a).kind == TypeKind::WORD and (@b).kind == TypeKind::FLOAT {
        return b
    } else if a.kind == TypeKind::BOOL and is_arithmetic(b) {
        return a
    } else if b.kind == TypeKind::BOOL and is_arithmetic(a) {
        return b
    }

    if (@a).kind == (@b).kind {
        if (@a).size == (@b).size {
            if (@b).unsig {
                return b
            } else {
                return a
            }
        } else if (@a).size > (@b).size {
            return a 
        } else {
            return b
        }
    }
    return null
}

def walk_PtrT(node: *parser::Node, state: *State) {
    let expr = (@node).value.t_parr.tpe
    walk(node, expr, state)
    assert(equals(expr.tpe, pointer(get_type_type())))

    let tpe = expr.svalue.value.value_tpe
    node.svalue = change_value_to_type(pointer(tpe), state)

    (@node).tpe = node.svalue.tpe
}

def walk_Null(node: *parser::Node, state: *State) {
    let tpe = make_type_raw(TypeKind::NULL)
    (@node).tpe = tpe
}

def walk_Integer(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::int_
}

def walk_Boolean(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::bool_
}

def walk_Float(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::double_
}

def walk_String(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::string_
}

def walk_Char(node: *parser::Node, state: *State) {
    (@node).tpe = builtins::char_
}

def walk_Range(node: *parser::Node, state: *State) {
    walk(node, (@node).value.bin_op.left, state)
    walk(node, (@node).value.bin_op.right, state)

    var kind = TypeKind::RANGE
    if (@node).kind == parser::NodeKind::RANGE_INC {
        kind = TypeKind::RANGE_INC
    }
    let tpe = make_type_raw(kind)
    (@tpe).line = (@node).loc.line
    
    (@node).tpe = tpe
}

// TODO Cache all the types
var type_type: *Type = null
export def get_type_type -> *Type {
    if type_type { return type_type }
    if not toolchain::runtime { return null }
    type_type = scope::get_type(toolchain::runtime.scope, make_identifier(["Type"]))
    return type_type
}

def do_create_type(tpe: *Type, state: *State) -> *compiler::Value {
    let value = zero_allocate(compiler::Value)

    value.values = zero_allocate(compiler::Value, 11)
    value.values[1] = { kind = ValueKind::UNDEF, tpe = builtins::string_ } !compiler::Value
    value.values[2] = { kind = ValueKind::INT, tpe = builtins::bool_, i = tpe.unsig !int64 } !compiler::Value
    value.values[3] = { kind = ValueKind::UNDEF, tpe = builtins::size_t_ } !compiler::Value
    value.values[4] = { kind = ValueKind::UNDEF, tpe = pointer(get_type_type()) } !compiler::Value
    value.values[5] = { kind = ValueKind::INT, tpe = builtins::size_t_, i = tpe.size } !compiler::Value
    value.values[6] = { kind = ValueKind::INT, tpe = builtins::size_t_, i = tpe.align } !compiler::Value
    value.values[7] = { kind = ValueKind::UNDEF, tpe = array(scope::get_type(toolchain::runtime.scope, make_identifier(["Field"]))) } !compiler::Value
    value.values[8] = { kind = ValueKind::UNDEF, tpe = array(scope::get_type(toolchain::runtime.scope, make_identifier(["Parameter"]))) } !compiler::Value
    value.values[9] = { kind = ValueKind::UNDEF, tpe = array(pointer(get_type_type())) } !compiler::Value
    value.values[10] = { kind = ValueKind::UNDEF, tpe = array(scope::get_type(toolchain::runtime.scope, make_identifier(["EnumValue"]))) } !compiler::Value

    switch tpe.kind !int {
        case TypeKind::STRUCT, TypeKind::UNION:
            for var i in 0..tpe.fields.size {
                let member = tpe.fields[i]
                create_type(member.tpe, state)
            }
            value.values[0] = { kind = ValueKind::INT, tpe = builtins::int_, i = 3 if tpe.kind == TypeKind::STRUCT else 4 }
        case TypeKind::BOOL:
            value.values[0] = { kind = ValueKind::INT, tpe = builtins::int_, i = 0 } !compiler::Value
        case TypeKind::WORD:
            value.values[0] = { kind = ValueKind::INT, tpe = builtins::int_, i = 1 } !compiler::Value
        case TypeKind::FLOAT:
            value.values[0] = { kind = ValueKind::INT, tpe = builtins::int_, i = 2 } !compiler::Value
        case TypeKind::ARRAY:
            create_type(tpe.tpe, state)
            value.values[0] = { kind = ValueKind::INT, tpe = builtins::int_, i = 5 } !compiler::Value
        case TypeKind::STATIC_ARRAY:
            create_type(tpe.tpe, state)
            value.values[0] = { kind = ValueKind::INT, tpe = builtins::int_, i = 6 } !compiler::Value
            value.values[3] = { kind = ValueKind::INT, tpe = builtins::size_t_, i = tpe.length} !compiler::Value
        case TypeKind::POINTER:
            create_type(tpe.tpe, state)
            value.values[0] = { kind = ValueKind::INT, tpe = builtins::int_, i = 7 } !compiler::Value
        case TypeKind::REFERENCE:
            create_type(tpe.tpe, state)
            value.values[0] = { kind = ValueKind::INT, tpe = builtins::int_, i = 8 } !compiler::Value
        case TypeKind::FUNCTION:
            for var i in 0..vector::length(tpe.parameter_t) {
                let np = vector::get(tpe.parameter_t, i) !*NamedParameter
                create_type(np.tpe, state)
            }
            for var i in 0..vector::length(tpe.return_t) {
                create_type(vector::get(tpe.return_t, i) !*Type, state)
            }
            value.values[0] = { kind = ValueKind::INT, tpe = builtins::int_, i = 9 } !compiler::Value
        case TypeKind::ENUM:
            create_type(tpe.tpe, state)
            value.values[0] = { kind = ValueKind::INT, tpe = builtins::int_, i = 10 } !compiler::Value
        case:
            error(tpe.kind, "\n")
            assert(false)
    }

    value.kind = ValueKind::STRUCT
    value.tpe = get_type_type()
    return value
}

def create_type(tpe: *Type, state: *State) -> *compiler::Value {
    if not tpe { return null }

    let ident = make_identifier([debug::type_to_str(tpe, true)])
    ident.loc.module = "type"

    var svalue = scope::get(toolchain::types.scope, ident, false, false)
    if not svalue {
        scope::create_variable(toolchain::types.scope, ident, parser::ShareMarker::NONE, parser::VarDecl::CONST, get_type_type(), false, null, scope::Phase::DEFINED, null, null)
        svalue = scope::create_variable(toolchain::types.scope, ident, parser::ShareMarker::NONE, parser::VarDecl::CONST, get_type_type(), do_create_type(tpe, state))

        let global = allocate(compiler::Global)
        @global = {
            private = false,
            name = svalue.assembly_name,
            tpe = svalue.tpe,
            value = svalue.value,
            line = -1
        }
        map::put(toolchain::types.result.globals, global.name, global)
        map::put(toolchain::types.imported, global.name, map::sentinel)
    }
    if not map::contains(state.module.result.globals, svalue.assembly_name) {
        let global = allocate(compiler::Global)
        @global = {
            external = true,
            name = svalue.assembly_name,
            tpe = svalue.tpe,
            line = -1
        }
        map::put(state.module.result.globals, global.name, global)
        map::put(state.module.imported, global.name, map::sentinel)
    }

    let value = allocate(compiler::Value)
    @value = {
        kind = compiler::ValueKind::GLOBAL,
        tpe = pointer(get_type_type()), 
        name = svalue.assembly_name
    } !compiler::Value

    value.value_tpe = tpe

    return value
}

def change_value_to_type(tpe: *Type, state: *State) -> *scope::Value {
    let type_tpe = copy(get_type_type())
    type_tpe.tpe = tpe 
    compiler::import_structures(type_type, state.module)
    let value = zero_allocate(scope::Value)
    value.tpe = pointer(type_tpe)
    value.value = create_type(tpe, state)
    return value
}

def walk_Identifier(node: *parser::Node, state: *State) {
    if node.value.identifier.args {
        node.value.identifier.types = vector::make()
        for var i in 0..vector::length(node.value.identifier.args) {
            let arg = vector::get(node.value.identifier.args, i) !*parser::Node
            let tpe = type_lookup(arg, state, true)

            let np = allocate(NamedParameter)
            @np = {
                name = "",
                tpe = tpe
            } !NamedParameter
            vector::push(node.value.identifier.types, np)
        }
    }

    var value = scope::get(state.scope, node) !*scope::Value
    if not value {
        errors::errorn(node, "Unknown identifier `", parser::identifier_to_str(node), "`")
        return
    }

    if value.tpe and value.tpe.kind == TypeKind::TYPE {
        value = change_value_to_type(value.value.value_tpe, state)
    }

    (@node).svalue = value
    (@node).tpe = (@value).tpe
    node.kw = value.modifier
    
    if is_function((@node).tpe) and 
        (@(@node).parent).kind != parser::NodeKind::FUNC_CALL and
        (@(@node).parent).kind != parser::NodeKind::PTR {

        let parent = (@node).parent
        let old_node = parser::copy_node(node)
        (@old_node).tpe = flatten_return_type(old_node, (@(@node).tpe).return_t)

        @node = {
            kind = parser::NodeKind::FUNC_CALL,
            loc = (@node).loc
        } !parser::Node
        (@node).value.func_call = {
            left = old_node,
            args = vector::make(),
            kwargs = vector::make()
        } !parser::NodeFuncCall
        walk(parent, node, state)
    }
}

def implicit_conversion(node: *parser::Node, tpe: *Type) {
    if not tpe { return }
    // TODO For integers we need to check the boundaries
    // TODO What about stuff like --10? I mean its kinda useless but for completeness
    if (@node).kind == parser::NodeKind::NULL and is_pointer(tpe) or
        is_arithmetic(tpe) and ((@node).kind == parser::NodeKind::INTEGER or
        ((@node).kind == parser::NodeKind::USUB or (@node).kind == parser::NodeKind::UADD) and 
        (@(@node).value.expr).kind == parser::NodeKind::INTEGER) {

        (@node).tpe = tpe
    } else if is_function_pointer(tpe) and 
        node.kind == parser::NodeKind::PTR and 
        node.value.expr and node.value.expr.kind == parser::NodeKind::IDENTIFIER {
        node.tpe = tpe
    }
}

def infer_struct_type(node: *parser::Node, tpe: *Type) {
    if (@node).kind != parser::NodeKind::STRUCT_LIT { return }
    if not is_struct(tpe) {
        errors::errorn(node, "Incompatible types ", debug::type_to_str(tpe), " is not a structure type")
        return
    }
    (@node).tpe = tpe
}

def collapse_types(node: *parser::Node, ltypes: *vector::Vector, right: *vector::Vector, state: *State) -> *vector::Vector {
    let rtypes = vector::make()
    var k = 0
    for var i in 0..vector::length(right) {
        let value = vector::get(right, i) !*parser::Node
        if not value { continue }

        var ltpe: *Type = null
        if k < vector::length(ltypes) {
            ltpe = vector::get(ltypes, k) !*Type
            infer_struct_type(value, ltpe)
        }
        
        walk(node, value, state)
        let rtpe = (@value).tpe
        if rtpe and (@rtpe).kind == TypeKind::TUPLE {
            for var j in 0..vector::length((@rtpe).return_t) {
                let t = vector::get((@rtpe).return_t, j) !*Type
                vector::push(rtypes, t)
                k += 1
            }
        } else {
            implicit_conversion(value, ltpe)
            if rtpe {
                vector::push(rtypes, (@value).tpe)
            }
            k += 1
        }
    }
    return rtypes
}

def walk_Assign(node: *parser::Node, state: *State) {
    let left = (@node).value.assign.left
    let right = (@node).value.assign.right

    let ltypes = vector::make()
    for var i in 0..vector::length(left) {
        let l = vector::get(left, i) !*parser::Node
        walk(node, l, state)
        vector::push(ltypes, (@l).tpe)
    }
    let rtypes = collapse_types(node, ltypes, right, state)

    if vector::length(ltypes) != vector::length(rtypes) {
        errors::errorn(node, "Unbalanced assignment")
        return
    }

    for var i in 0..vector::length(left) {
        let l = vector::get(left, i) !*parser::Node
        var ltpe = (@l).tpe
        if not check_is_identifier_assignable(l, state) {
            continue
        }
        var rtpe = vector::get(rtypes, i) !*Type

        if l.kind == parser::NodeKind::IDENTIFIER and scope::last_path_element(l) == "_" {
            ltpe = rtpe
            l.tpe = rtpe
            l.svalue = scope::create_underscore(state.scope, rtpe)
        }

        if not ltpe or not rtpe { continue }
        if not is_assignable(ltpe, rtpe) {
            errors::errorn(l, "Incompatible types ", debug::type_to_str(rtpe), " and ", debug::type_to_str(ltpe))
        }
    }
    (@node).tpe = vector::peek(ltypes) !*Type
}

// This is getting called from preprocessing for constants
export def walk_VarDecl(node: *parser::Node, state: *State, set_constant: bool) {
    let share = (@node).value.var_decl.share
    let kw = (@node).value.var_decl.kw
    let left = (@node).value.var_decl.left
    let right = (@node).value.var_decl.right
    let extern = (@node).value.var_decl.extern

    if kw == parser::VarDecl::CONST and not set_constant {
        for var i in 0..vector::length(left) {
            let id = vector::get(left, i) !*parser::Node
            assert(id.kind == parser::NodeKind::ID_DECL)
            
            let ident = id.value.id_decl.value
            ident.svalue = scope::get(state.scope, ident)
        }
        return 
    }

    if current_function(state) {
        if share != parser::ShareMarker::NONE {
            errors::errorn(node, "Can't share non top level variable")
        }
    }
    
    let ltypes = vector::make()
    for var i in 0..vector::length(left) {
        let node = vector::get(left, i) !*parser::Node
        if (@node).kind == parser::NodeKind::ID_DECL {
            let tpe_node = (@node).value.id_decl.tpe
            if tpe_node {
                let tpe = type_lookup(tpe_node, state)
                vector::push(ltypes, tpe)
            } else {
                vector::push(ltypes, null)
            }
        } else {
            let n = (@node).value.expr
            walk(node, n, state)
            vector::push(ltypes, (@n).tpe)
        }
    }

    let rtypes = collapse_types(node, ltypes, right, state)
    	
    var balanced = true
    if (kw == parser::VarDecl::CONST or 
        kw == parser::VarDecl::LET) and 
        vector::length(ltypes) != vector::length(rtypes) {
        
        errors::errorn(node, "Unbalanced assignment")
        balanced = false
    }

    let function = current_function(state)

    for var i in 0..vector::length(left) {
        var ltpe = vector::get(ltypes, i) !*Type

        let node = vector::get(left, i) !*parser::Node
        if (@node).kind == parser::NodeKind::ID_DECL {
            if not ltpe and i < vector::length(rtypes) {
                ltpe = vector::get(rtypes, i) !*Type
            }
            if not ltpe and balanced {
                errors::errorn(node, "Need to specify a type")
            }

            let ident = (@node).value.id_decl.value
            let is_underscore = scope::last_path_element(ident) == "_"

            if i < vector::length(rtypes) {
                let rtpe = vector::get(rtypes, i) !*Type

                if is_underscore { ltpe = rtpe }
                if not is_assignable(ltpe, rtpe) {
                    errors::errorn(node, "Incompatible types ", debug::type_to_str(rtpe), " and ", debug::type_to_str(ltpe))
                }
            }

            ident.scope = state.scope
            ident.tpe = ltpe

            if is_underscore {
                ident.svalue = scope::create_underscore(state.scope, ltpe)
            } else {
                ident.svalue = scope::create_variable(state.scope, ident, share, kw, ltpe, extern, null)
            }
            

            if function {
                map::put(function.locals, ident.svalue.assembly_name, ltpe)
            }
        } else {
            let n = (@node).value.expr
            if not check_is_identifier_assignable(n, state) {
                continue
            }

            if i >= vector::length(rtypes) {
                errors::errorn(node, "Must assign a value")
                continue
            }
            let rtpe = vector::get(rtypes, i) !*Type

            if node.kind == parser::NodeKind::IDENTIFIER and scope::last_path_element(node) == "_" {
                ltpe = rtpe
                node.tpe = rtpe
                node.svalue = scope::create_underscore(state.scope, rtpe)
            }

            if not ltpe or not rtpe { continue }
            if not is_assignable(ltpe, rtpe) {
                errors::errorn(node, "Incompatible types ", debug::type_to_str(rtpe), " and ", debug::type_to_str(ltpe))
            }
        }
    }
}

def walk_VarDecl(node: *parser::Node, state: *State) {
    walk_VarDecl(node, state, false)
}

def walk_Not(node: *parser::Node, state: *State) {
    walk(node, (@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not tpe { return }
    if not is_boolean(tpe) {
        errors::errorn(node, "Incompatible type ", debug::type_to_str(tpe), ", must be boolean type")
    }
    (@node).tpe = tpe
}

def walk_BNot(node: *parser::Node, state: *State) {
    walk(node, (@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not tpe { return }
    if not is_integer(tpe) {
        errors::errorn(node, "Incompatible type ", debug::type_to_str(tpe), ", must be integer type")
    }
    (@node).tpe = tpe
}

def walk_UAdd(node: *parser::Node, state: *State) {
    walk(node, (@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not tpe { return }
    if not is_arithmetic(tpe) {
        errors::errorn(node, "Incompatible type ", debug::type_to_str(tpe), ", must be arithmetic type")
    }
    (@node).tpe = tpe
}

def walk_USub(node: *parser::Node, state: *State) {
    walk(node, (@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not tpe { return }
    if not is_arithmetic(tpe) {
        errors::errorn(node, "Incompatible type ", debug::type_to_str(tpe), ", must be arithmetic type")
    }
    (@node).tpe = tpe
}

def walk_ArithmeticOp(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(node, left, state)
    walk(node, right, state)

    if not (@left).tpe or not (@right).tpe { return }
    (@node).tpe = common_type((@left).tpe, (@right).tpe)
}

def walk_BitwiseOp(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(node, left, state)
    walk(node, right, state)

    if not (@left).tpe or not (@right).tpe { return }
    if not is_integer((@left).tpe) or not is_integer((@right).tpe) {
        errors::errorn(node, "Invalid operands of type ", debug::type_to_str((@left).tpe), " and ", debug::type_to_str((@right).tpe), " to bitwise operator")
    }

    (@node).tpe = common_type((@left).tpe, (@right).tpe)
}

def walk_BooleanOp(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(node, left, state)
    walk(node, right, state)

    if not (@left).tpe or not (@right).tpe { return }
    if not is_boolean((@left).tpe) or not is_boolean((@right).tpe) {
        errors::errorn(node, "Invalid operands of type ", debug::type_to_str((@left).tpe), " and ", debug::type_to_str((@right).tpe), " to boolean operator")
    }

    (@node).tpe = builtins::bool_
}

// TODO implicit conversions here too
def walk_AssignEqArithmetic(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(node, left, state)
    walk(node, right, state)
    if not check_is_identifier_assignable(left, state) {
        return
    }

    if not (@left).tpe or not (@right).tpe { return }
    if not is_arithmetic((@right).tpe) {
        errors::errorn(right, "Incompatible type, expected arithmetic type, got ", debug::type_to_str((@right).tpe))
    }
    if not is_arithmetic((@left).tpe) {
        errors::errorn(right, "Incompatible type, expected arithmetic type, got ", debug::type_to_str((@left).tpe))
    }

    (@node).tpe = (@left).tpe
}

def walk_AssignEqBitwise(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(node, left, state)
    walk(node, right, state)
    if not check_is_identifier_assignable(left, state) {
        return
    }

    if not (@left).tpe or not (@right).tpe { return }
    if not is_integer((@right).tpe) {
        errors::errorn(right, "Incompatible type, expected integer type, got ", debug::type_to_str((@right).tpe))
    }
    if not is_integer((@left).tpe) {
        errors::errorn(right, "Incompatible type, expected integer type, got ", debug::type_to_str((@left).tpe))
    }

    (@node).tpe = (@left).tpe
}

def walk_AssignEqPtr(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    walk(node, left, state)
    walk(node, right, state)
    if not check_is_identifier_assignable(left, state) {
        return
    }

    if not (@left).tpe or not (@right).tpe { return }
    if not is_integer((@right).tpe) {
        errors::errorn(right, "Incompatible type, expected integer type, got ", debug::type_to_str((@right).tpe))
    }
    if not is_pointer((@left).tpe) {
        errors::errorn(right, "Incompatible type, expected pointer type, got ", debug::type_to_str((@left).tpe))
    }

    (@node).tpe = (@left).tpe
}

def walk_Cast(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    if not left or not right { return }

    let tpe = type_lookup(right, state)
    if not tpe { return }
    (@node).tpe = tpe

    if (@left).kind == parser::NodeKind::STRUCT_LIT {
        if (@tpe).kind != TypeKind::STRUCT and
            (@tpe).kind != TypeKind::UNION {
            errors::errorn(left, "Invalid cast")
            return
        }
        (@left).tpe = (@node).tpe
    }
    if (@left).kind == parser::NodeKind::ARRAY_LIT {
        if (@tpe).kind != TypeKind::ARRAY and 
            (@tpe).kind != TypeKind::STATIC_ARRAY {
            errors::errorn(left, "Invalid cast")
            return
        }
    }
    /*if left.kind == parser::NodeKind::PTR and left.value.expr and 
        left.value.expr.kind == parser::NodeKind::IDENTIFIER {
        if is_function_pointer(tpe) {
            left.value.expr.tpe = tpe 
        }
    }*/
    walk(node, left, state)
}

def walk_Import(node: *parser::Node, state: *State) {
    if current_function(state) != null {
        errors::errorn(node, "Can only import at top level")
        return
    }

    let imports = (@node).value.body
    for var i in 0..vector::length(imports) {
        let imprt = vector::get(imports, i) !*parser::Node
        var name = (@imprt).value.import_module.name
        toolchain::typecheck_module(name)
    }
}

export def walk_Def(node: *parser::Node, state: *State, redefine_type: bool) {
    let share = (@node).value.def_.share
    let body = (@node).value.def_.body
    let name = (@node).value.def_.name
    let params = (@node).value.def_.params
    let returns = (@node).value.def_.returns
    let extern = (@node).value.def_.extern
    let outer_scope = node.scope
    let inner_scope = node.inner_scope
    let imported = (share !int & parser::ShareMarker::IMPORT !int) !bool

    if not name or not params or not returns { return }

    if current_function(state) {
        if share != parser::ShareMarker::NONE {
            errors::errorn(node, "Can't share non top level function")
        }
    }

    var tpe = node.tpe
    // We basically don't compile the original version of the function if it has a type argument
    if not tpe or tpe.is_polymorph { return }

    // TODO not is_used also signals that we have a type argument
    node.value.def_.is_used = true

    if redefine_type {
        // This is pretty ugly, we should only read the type once
        for var i in 0..vector::length(params) {
            let param = vector::get(params, i) !*parser::Node
            let named = vector::get(tpe.parameter_t, i) !*NamedParameter
            named.tpe = type_lookup(param.value.param.tpe, state)
        }
        tpe.return_t = vector::make()
        for var i in 0..vector::length(returns) {
            let n = vector::get(returns, i) !*parser::Node
            vector::push(tpe.return_t, type_lookup(n, state))
        }
    }

    tpe = make_function_type_n(name, tpe.parameter_t, tpe.return_t, extern, imported)

    var phase = scope::Phase::DECLARED
    if body {
        phase = scope::Phase::COMPILED
        for var i in 0..vector::length(tpe.parameter_t) {
            let np = vector::get(tpe.parameter_t, i) !*NamedParameter 
            var tpe = np.tpe
            if tpe.kind == TypeKind::TYPE { continue }
            if np.varargs {
                if np.tpe {
                    scope::create_variable(inner_scope, np.node, parser::ShareMarker::NONE, parser::VarDecl::VAR, array(np.tpe), null)
                }
            } else {
                scope::create_variable(inner_scope, np.node, parser::ShareMarker::NONE, parser::VarDecl::VAR, np.tpe, null)
            }
        }
    }

    if current_function(state) {
        // This is so that we don't create overloaded functions
        // inside of a function
        // TODO what about forward declarations?
        scope::create_variable(outer_scope, name, share, parser::VarDecl::CONST, tpe, null)
    } else {
        scope::create_function(outer_scope, name, share, tpe, phase, null, null)
    }
    
    if body {
        let function = allocate(Function)
        @function = {
            tpe = tpe,
            locals = node.value.def_.locals,
            has_defer = node.value.def_.has_defer
        }

        push_function(state, function)
        for var i in 0..vector::length(body) {
            walk(node, vector::get(body, i) !*parser::Node, state)
        }
        pop_function(state)

        node.value.def_.has_defer = function.has_defer
    }

    node.tpe = tpe
}

def walk_Def(node: *parser::Node, state: *State) {
    walk_Def(node, state, true)
}

def walk_TypeDecl(node: *parser::Node, state: *State) {
    let share = (@node).value.type_decl.share
    let left = (@node).value.type_decl.left
    let right = (@node).value.type_decl.right

    if vector::length(left) < vector::length(right) {
        errors::errorn(node, "Too many values to assign")
        return
    }

    for var i in 0..vector::length(left) {
        let name = vector::get(left, i) !*parser::Node
        var value: *parser::Node = null
        if i < vector::length(right) {
            value = vector::get(right, i) !*parser::Node
        }
        
        var tpe = make_type(TypeKind::STUB, name)
        if value {
            tpe = scope::create_type(state.scope, name, share, tpe, scope::Phase::COMPILED, null, null)
            if not tpe {
                continue
            }

            tpe = copy(type_lookup(value, state))
            if not tpe { continue }
            (@tpe).name = parser::identifier_to_str(name)
            (@tpe).type_name = append_module((@tpe).name, (@node).loc.module)
            tpe = scope::create_type(state.scope, name, share, tpe, scope::Phase::COMPILED, null, null)
        }
        (@name).tpe = tpe
    }
}

def walk_Return(node: *parser::Node, state: *State) {
    let current_fun = current_function(state)
    let body = (@node).value.body
    if not current_fun {
        // TODO This is actually allowed, I just need to infer the types
        // and assign to some sort of internal variable
        errors::errorn(node, "return outside of a function")
        return
    }
    let tpe = current_fun.tpe

    let ltypes = tpe.return_t
    let rtypes = collapse_types(node, ltypes, body, state)

    if vector::length(ltypes) != vector::length(rtypes) {
        // TODO Improve error message
        errors::errorn(node, "Wrong number of arguments to return")
    }

    for var i in 0..vector::length(ltypes) {
        let argtpe = vector::get(ltypes, i) !*Type
        if i >= vector::length(rtypes) { return }

        var rettpe = vector::get(rtypes, i) !*Type
        
        if not argtpe or not rettpe { continue }
        if not is_assignable(argtpe, rettpe) {
            // TODO This doesn't point to the actual value
            errors::errorn(node, "Wrong type of return argument, got ", debug::type_to_str(rettpe), ", expected ", debug::type_to_str(argtpe))
        }
    }
    (@node).tpe = tpe
}

def append_arguments(buf: *buffer::Buffer, arguments: *vector::Vector) {
    let len = vector::length(arguments)
    if len > 0 {
        buffer::append_str(buf, "Arguments were of type ")
    } else {
        buffer::append_str(buf, "No arguments.")
    }
    for var i in 0..len {
        let arg = vector::get(arguments, i) !*NamedParameter
        buffer::append_str(buf, debug::type_to_str((@arg).tpe))
        if i < len - 1 {
            buffer::append_str(buf, ", ")
        }
    }
}

def walk_Call(node: *parser::Node, dry_run: bool, state: *State) -> bool {
    var left = (@node).value.func_call.left
    if not left { return false }
    if not dry_run {
        walk(node, left, state)
    }
    // We need to do this because member access overwrites the parent node
    left = node.value.func_call.left
    var tpe = (@left).tpe

    var arguments = vector::make()
    for var i in 0..vector::length((@node).value.func_call.args) {
        let n = vector::get((@node).value.func_call.args, i) !*parser::Node
        walk(node, n, state)
        let np = allocate(NamedParameter)
        @np = {
            name = "",
            tpe = (@n).tpe,
            varargs = false,
            node = n
        } !NamedParameter
        
        if equals(np.tpe, pointer(get_type_type())) {
            np.value = allocate(compiler::Value)
            @np.value = { kind = compiler::ValueKind::TYPE, tpe = builtins::type_, value_tpe = np.tpe.tpe } !compiler::Value
        }

        vector::push(arguments, np)
    }
    let parameter_map = map::make()
    for var i in 0..vector::length((@node).value.func_call.kwargs) {
        let n = vector::get((@node).value.func_call.kwargs, i) !*parser::Node
        walk(node, (@n).value.named_arg.value, state)
        let name = last_ident_to_str((@n).value.named_arg.name)

        if map::contains(parameter_map, name) {
            // and we cannot have two things with the same name so just error here...
            errors::errorn(n, "Cannot have the same parameter name multiple times in a function call. Parameter name was `", name, "`.")
            break
        } else {
            map::put(parameter_map, name, map::sentinel)
            let np = allocate(NamedParameter)
            @np = {
                name = name,
                tpe = (@(@n).value.named_arg.value).tpe,
                varargs = false,
                node = (@n).value.named_arg.name
            } !NamedParameter

            if equals(np.tpe, get_type_type()) {
                np.value = allocate(compiler::Value)
                @np.value = { kind = compiler::ValueKind::TYPE, tpe = builtins::type_, value_tpe = np.tpe.tpe } !compiler::Value
            }

            vector::push(arguments, np)
        }
    }

    if not is_function_pointer(tpe) {
        if (@left).kind == parser::NodeKind::IDENTIFIER {
            var function = scope::get_function(state.scope, left, arguments, dry_run)
            left.svalue = function

            if not function and dry_run { return false }

            if left.value.identifier.types {
                if not function {
                    errors::errorn(left, "Function overload not found")
                    return false
                }
                if overload_score(function.tpe, arguments, false) < 0 {
                    let buf = buffer::make_buffer()
                    buffer::append_str(*buf, "Incorrect arguments to overloaded function. ")
                    append_arguments(*buf, arguments)
                    errors::errorn(left, buffer::to_string(*buf))
                    return false
                }
            }

            if not function {
                let buf = buffer::make_buffer()
                buffer::append_str(*buf, "Function `")
                buffer::append_str(*buf, parser::identifier_to_str(left))
                buffer::append_str(*buf, "` not found. ")
                
                append_arguments(*buf, arguments)
                errors::errorn(left, buffer::to_string(*buf))
                return false
            }

            tpe = copy((@function).tpe)
        } else {
            errors::errorn(left, "Can't call expression")
            return false
        }
    }

    (@node).function = tpe
    if is_function_pointer(tpe) {
        tpe = (@tpe).tpe
    }
    
    let parameter_t = (@tpe).parameter_t

    var i = 0
    var j = 0
    // Implicit conversions, this also removes type parameters from the argument list
    loop {
        if i >= vector::length((@node).value.func_call.args) { break }
        let n = vector::get((@node).value.func_call.args, i) !*parser::Node
        var rhstpe: *Type = null
        if j < vector::length(parameter_t) {
            rhstpe = (@(vector::get(parameter_t, j) !*NamedParameter)).tpe
        } else {
            let np = vector::peek(parameter_t) !*NamedParameter
            assert((@np).varargs)
            rhstpe = (@np).tpe
        }

        if rhstpe and rhstpe.kind == TypeKind::TYPE and not tpe.macro {
            vector::remove((@node).value.func_call.args, i)
        } else {
            i += 1
            implicit_conversion(n, rhstpe)
        }
        j += 1
    }
    i = 0
    loop {
        if i >= vector::length((@node).value.func_call.kwargs) { break }
        let n = vector::get((@node).value.func_call.kwargs, i) !*parser::Node
        let name = last_ident_to_str((@n).value.named_arg.name)
        let arg = (@n).value.named_arg.value

        var rhstpe: *Type = null
        for var j in 0..vector::length(parameter_t) {
            let param = vector::get(parameter_t, j) !*NamedParameter
            if (@param).name == name {
                rhstpe = (@param).tpe
                break
            }
        }

        if rhstpe and rhstpe.kind == TypeKind::TYPE and not tpe.macro {
            vector::remove((@node).value.func_call.kwargs, i)
        } else {
            i += 1
            implicit_conversion(arg, rhstpe)
        }
    }

    if not tpe.macro {
        i = 0
        loop {
            if i >= vector::length(parameter_t) { break }
            let np = vector::get(parameter_t, i) !*NamedParameter
            if np.tpe and np.tpe.kind == TypeKind::TYPE {
                vector::remove(parameter_t, i)
            } else {
                i += 1
            }
        }
    }

    var return_t = (@tpe).return_t
    if (@tpe).proto {
        return_t = (@tpe).proto((@node).value.func_call.args, (@node).value.func_call.kwargs, state)
    }

    (@node).tpe = flatten_return_type(node, return_t)
    return true
}

def walk_Call(node: *parser::Node, state: *State) {
    walk_Call(node, false, state)
}

def walk_Case(node: *parser::Node, state: *State) {
    for var i in 0..vector::length((@node).value.case_.expr) {
        let expr = vector::get((@node).value.case_.expr, i) !*parser::Node
        walk(node, expr, state)
        if not (is_arithmetic((@expr).tpe) or is_enum((@expr).tpe) or is_range((@expr).tpe)){
            errors::errorn(expr, "Incompatible type, expected arithmetic type, range or enum, got ", debug::type_to_str((@expr).tpe))
            return
        }

        if expr.kind == parser::NodeKind::RANGE or expr.kind == parser::NodeKind::RANGE_INC {
            let left = expr.value.bin_op.left
            let right = expr.value.bin_op.right
            left.svalue = preprocess::make_value(preprocess::expr(left, state))
            right.svalue = preprocess::make_value(preprocess::expr(right, state))
        } else {
            expr.svalue = preprocess::make_value(preprocess::expr(expr, state))
        }
    }

    for var i in 0..vector::length((@node).value.case_.body) {
        let expr = vector::get((@node).value.case_.body, i) !*parser::Node
        walk(node, expr, state)
    }
}

def walk_Switch(node: *parser::Node, state: *State) {
    let expr = (@node).value.switch_.expr
    walk(node, expr, state)
    if not (is_arithmetic((@expr).tpe) or is_enum((@expr).tpe) ){
        errors::errorn(expr, "Incompatible type, expected arithmetic type or enum, got ", debug::type_to_str((@expr).tpe))
        return
    }

    for var i in 0..vector::length((@node).value.switch_.body) {
        walk(node, vector::get((@node).value.switch_.body, i) !*parser::Node, state)
    }
}

def walk_If(node: *parser::Node, state: *State) {
    let cond = (@node).value.if_.cond
    walk(node, cond, state)
    let tpe = (@cond).tpe
    if not tpe { return }
    if not is_boolean(tpe) {
        errors::errorn(node, "Incompatible type ", debug::type_to_str(tpe), ", must be boolean type")
    }
    
    for var i in 0..vector::length((@node).value.if_.body) {
        let n = vector::get((@node).value.if_.body, i) !*parser::Node
        walk(node, n, state)
    }

    for var i in 0..vector::length((@node).value.if_.else_if) {
        let n = vector::get((@node).value.if_.else_if, i) !*parser::Node
        
        let cond = (@n).value.else_if.cond
        walk(node, cond, state)
        let tpe = (@cond).tpe
        
        if not is_boolean(tpe) {
            errors::errorn(n, "Incompatible type ", debug::type_to_str(tpe), ", must be boolean type")
        }

        for var i in 0..vector::length((@n).value.else_if.body) {
            let n2 = vector::get((@n).value.else_if.body, i) !*parser::Node
            walk(node, n2, state)
        }   
    }

    let else_ = (@node).value.if_.else_
    if else_ {
        for var i in 0..vector::length((@else_).value.body) {
            let n = vector::get((@else_).value.body, i) !*parser::Node
            walk(node, n, state)
        }
    }
}

def walk_IfExpr(node: *parser::Node, state: *State) {
    let cond = node.value.if_expr.cond
    walk(node, cond, state)

    let tpe = cond.tpe
    if not tpe { return }
    if not is_boolean(tpe) {
        errors::errorn(node, "Incompatible type ", debug::type_to_str(tpe), ", must be boolean type")
    }

    let if_true = node.value.if_expr.if_true
    let if_false = node.value.if_expr.if_false
    walk(node, if_true, state)
    walk(node, if_false, state)

    if not equals(if_true.tpe, if_false.tpe) {
        errors::errorn(node, "If expression needs to have a single type")
    }

    node.tpe = if_true.tpe
}

def walk_Loop(node: *parser::Node, state: *State) {
    for var i in 0..vector::length((@node).value.body) {
        let n = vector::get((@node).value.body, i) !*parser::Node
        walk(node, n, state)
    }
}

def walk_While(node: *parser::Node, state: *State) {
    let expr = (@node).value.while_loop.expr
    if not expr { return }
    walk(node, expr, state)
    if not is_boolean((@expr).tpe) {
        errors::errorn(node, "Incompatible type ", debug::type_to_str((@expr).tpe), ", must be boolean type")
    }

    for var i in 0..vector::length((@node).value.while_loop.body) {
        let n = vector::get((@node).value.while_loop.body, i) !*parser::Node
        walk(node, n, state)
    }
}

def walk_For(node: *parser::Node, state: *State) {
    let expr = (@node).value.for_loop.expr
    walk(node, expr, state)

    let iddecl = (@node).value.for_loop.iddecl
    var tpe = builtins::int_
    if is_array((@expr).tpe) {
        tpe = (@(@expr).tpe).tpe
    }
    if (@iddecl).kind == parser::NodeKind::FOR_ID_DECL {
        (@iddecl).tpe = tpe
        (@iddecl).scope = node.inner_scope
        let ident = (@iddecl).value.for_id_decl.ident
        scope::create_variable(
            node.inner_scope, 
            ident, 
            parser::ShareMarker::NONE, 
            (@iddecl).value.for_id_decl.kw, 
            tpe, null
        )
        let svalue = scope::get(node.inner_scope, ident)
        let function = current_function(state)
        if function {
            map::put(function.locals, svalue.assembly_name, tpe)
        }
    
    } else {
        walk(node, iddecl, state)
        if not equals(tpe, (@iddecl).tpe) {
            errors::errorn(iddecl, "Type didn't match, expected ", debug::type_to_str(tpe), ", got ", debug::type_to_str((@iddecl).tpe))
        }
    }

    for var i in 0..vector::length((@node).value.for_loop.body) {
        let n = vector::get((@node).value.for_loop.body, i) !*parser::Node
        walk(node, n, state)
    }
}

def walk_Deref(node: *parser::Node, state: *State) {
    walk(node, (@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not tpe { return }
    if not is_pointer(tpe) and not is_ref(tpe) {
        errors::errorn(node, "Needs to be a pointer or reference type, got ", debug::type_to_str(tpe))
        return
    }
    node.tpe = tpe.tpe
    node.kw = tpe.kw
}

def walk_Ptr(node: *parser::Node, state: *State) {
    walk(node, (@node).value.expr, state)
    let tpe = (@(@node).value.expr).tpe
    if not tpe { return }
    node.tpe = pointer(tpe, tpe.kw)
}

def walk_MemberAccess_ucs(node: *parser::Node, state: *State) -> bool {
    let right = (@node).value.bin_op.right
    let left = (@node).value.bin_op.left
    let parent = (@node).parent
    let tpe = (@left).tpe

    if (@parent).kind == parser::NodeKind::FUNC_CALL and
        (@parent).value.func_call.left == node {
        let old_parent = @parent
        let old_args = vector::copy((@parent).value.func_call.args)
        parent.value.func_call.left = right
        vector::prepend((@parent).value.func_call.args, left)

        if not walk_Call(parent, true, state) {
            @parent = old_parent
            parent.value.func_call.args = old_args
            return false 
        }
    } else {
        let parameter_t = vector::make()
        let np = allocate(NamedParameter)
        @np = {
            name = "",
            tpe = (@left).tpe
        } !NamedParameter
        vector::push(parameter_t, np)

        let function = scope::get_function((@node).scope, right, parameter_t, false)
        if not function { return false }

        let args = vector::make()
        vector::push(args, left)
        @node = {
            kind = parser::NodeKind::FUNC_CALL,
            loc = (@node).loc,
            parent = parent
        } !parser::Node
        (@node).value.func_call = {
            left = right,
            args = args,
            kwargs = vector::make()
        } !parser::NodeFuncCall
        
        walk(parent, node, state)
    }
    return true
}

def resolve_member(fields: [StructMember], name: string) -> *Type {
    for var i in 0..fields.size {
        let member = fields[i]
        if length(member.name) > 0 {
            if member.name == name {
                return member.tpe
            }
        } else {
            let member = resolve_member((@member.tpe).fields, name)
            if member { return member }
        }
    }
    return null
}

def walk_MemberAccess(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    walk(node, left, state)
    let tpe = (@left).tpe

    if is_pointer(tpe) {
        let old_left = parser::copy_node(left)
        let new_left = {
            kind = parser::NodeKind::DEREF,
            loc = (@left).loc,
            tpe = tpe.tpe
        } !parser::Node
        new_left.value.expr = old_left
        @left = new_left
        if walk_MemberAccess_aggregate(node, false, state) { return }
        
        @left = @old_left
        if walk_MemberAccess_ucs(node, state) { return }

        @left = new_left
        if not walk_MemberAccess_ucs(node, state) {
            errors::errorn(node, "Unknown field `", last_ident_to_str(right), "`")
        }
        return
    }

    walk_MemberAccess_aggregate(node, true, state)
}

def walk_MemberAccess_aggregate(node: *parser::Node, ucs: bool, state: *State) -> bool {
    let right = (@node).value.bin_op.right
    let left = (@node).value.bin_op.left
    let tpe = left.tpe
    if not tpe { return false }

    if (@tpe).kind == TypeKind::STRUCT or (@tpe).kind == TypeKind::UNION {
        let name = last_ident_to_str(right)

        let rtpe = resolve_member((@tpe).fields, name)
        if not rtpe {
            if ucs {
                if walk_MemberAccess_ucs(node, state) { return true }
                errors::errorn(node, "Unknown field `", name, "`")
            }
            return false
        }
        (@node).tpe = rtpe
    } else if (@tpe).kind == TypeKind::ARRAY or (@tpe).kind == TypeKind::STATIC_ARRAY {
        let name = last_ident_to_str(right)
        if name == "size" {
            (@node).tpe = builtins::size_t_
        } else if name == "value" {
            (@node).tpe = pointer((@tpe).tpe)
        } else {
            if ucs {
                if walk_MemberAccess_ucs(node, state) { return true }
                errors::errorn(node, "Expected size or value")
            }
            return false
        }
    // TODO Enums might have ordinal and some other information
    } else {
        if ucs {
            if walk_MemberAccess_ucs(node, state) { return true }
            errors::errorn(node, "Expected aggregate type, got ", debug::type_to_str(tpe), )
        }
        return false
    }
    return true
}

def walk_ArraySubscript(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right

    walk(node, left, state)
    walk(node, right, state)

    if not left or not right { return }
    let tpe = (@left).tpe
    if not tpe { return }
    if is_pointer(tpe) or (@tpe).kind == TypeKind::ARRAY or
        (@tpe).kind == TypeKind::STATIC_ARRAY {
        node.kw = tpe.kw
        node.tpe = tpe.tpe
    } else {
        errors::errorn(left, "Expected array or pointer type, got ", debug::type_to_str(tpe))
    }
    if not is_arithmetic((@right).tpe) {
        errors::errorn(right, "Expected arithmetic type, got ", debug::type_to_str((@right).tpe))
    }
}

def walk_StructLit(node: *parser::Node, state: *State) {
    let tpe = (@node).tpe
    // This instructs compile to skip the struct literal completely
    (@node).tpe = null

    if not tpe {
        errors::errorn(node, "Need to specify a type for struct literal")
        return
    }

    for var i in 0..vector::length((@node).value.struct_lit.args) {
        let n = vector::get((@node).value.struct_lit.args, i) !*parser::Node
        if i > (@tpe).fields.size {
            errors::errorn(n, "Too many arguments to array literal")
            return
        }
        walk(node, n, state)
        
        var ntpe = (@tpe).fields[i].tpe
        implicit_conversion(n, ntpe)

        if not ntpe or not (@n).tpe { continue }
        if not is_assignable(ntpe, (@n).tpe) {
            errors::errorn(n, "Incompatible types ", debug::type_to_str((@n).tpe), " and ", debug::type_to_str(ntpe))
            return
        }
    }
    for var i in 0..vector::length((@node).value.struct_lit.kwargs) {
        let kwarg = vector::get((@node).value.struct_lit.kwargs, i) !*parser::Node
        let n = (@kwarg).value.named_arg.value
        walk(node, n, state)
        let name = last_ident_to_str((@kwarg).value.named_arg.name)

        var found = false
        for var j in 0..(@tpe).fields.size {
            let field = (@tpe).fields[j]
            if field.name == name {
                found = true

                var ntpe = field.tpe
                implicit_conversion(n, ntpe)

                if not ntpe or not (@n).tpe { continue }
                if not is_assignable(ntpe, (@n).tpe) {
                    errors::errorn(n, "Incompatible types ", debug::type_to_str((@n).tpe), " and ", debug::type_to_str(ntpe), )
                    return
                }
                break
            }
        }
        if not found {
            errors::errorn(n, "Unknown field `", name, "`")
            return
        }
    }

    (@node).tpe = tpe
}

// TODO We might want to allow assignments like
// let array: [double] = [1, 2, 3, 4] // And convert to double here
def walk_ArrayLit(node: *parser::Node, state: *State) {
    var tpe: *Type = null
    let len = vector::length((@node).value.body)
    for var i in 0..len {
        let n = vector::get((@node).value.body, i) !*parser::Node
        walk(node, n, state)
        let t = (@n).tpe
        if not tpe { tpe = t }
        else {
            if not equals(tpe, t) {
                errors::errorn(n, "Incompatible types, all array elements need to have the same type. Array type ", 
                    debug::type_to_str(tpe), ", got ", debug::type_to_str(t))
                // It might be confusing to get multiple errors here
                break
            }
        }
    }
    if not tpe {
        tpe = builtins::char_
    }
    
    let ret_tpe = make_type_raw(TypeKind::STATIC_ARRAY)
    (@ret_tpe).line = (@node).loc.line
    (@ret_tpe).length = len
    (@ret_tpe).tpe = tpe
    (@ret_tpe).size = len * (@tpe).size
    (@ret_tpe).align = (@tpe).align

    (@node).tpe = ret_tpe
}

def walk_SizeOf(node: *parser::Node, state: *State) {
    let expr = (@node).value.expr
    // Need to special case here
    if (@expr).kind == parser::NodeKind::IDENTIFIER {
        let value = scope::get(state.scope, expr)
        if not value {
            errors::errorn(expr, "Unknown identifier `", parser::identifier_to_str(expr), "`")
            return
        }
        if (@value).modifier == parser::VarDecl::TYPE {
            (@expr).tpe = (@value).value.value_tpe
        } else {
            (@expr).tpe = (@value).tpe
        }
    } else {
        (@expr).tpe = type_lookup(expr, state)
        if not (@expr).tpe {
            walk(node, expr, state)
        }
    }

    (@node).tpe = builtins::size_t_
}

def walk_AlignOf(node: *parser::Node, state: *State) {
    let expr = (@node).value.expr
    // Need to special case here
    if (@expr).kind == parser::NodeKind::IDENTIFIER {
        let value = scope::get(state.scope, expr)
        if not value {
            errors::errorn(expr, "Unknown identifier `", parser::identifier_to_str(expr), "`")
            return
        }
        if (@value).modifier == parser::VarDecl::TYPE {
            (@expr).tpe = (@value).value.value_tpe
        } else {
            (@expr).tpe = (@value).tpe
        }
    } else {
        (@expr).tpe = type_lookup(expr, state)
        if not (@expr).tpe {
            walk(node, expr, state)
        }
    }

    (@node).tpe = builtins::size_t_
}

def walk_ComparisionOp(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    walk(node, left, state)
    walk(node, right, state)
    // TODO We can compare almost everything
    (@node).tpe = builtins::bool_
}

def walk_PAdd(node: *parser::Node, state: *State) {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    walk(node, left, state)
    walk(node, right, state)
    if not is_pointer((@left).tpe) {
        errors::errorn(left, "Must be pointer type, got ", debug::type_to_str((@left).tpe))
    }
    if not is_arithmetic((@right).tpe) {
        errors::errorn(left, "Must be arithmetic type, got ", debug::type_to_str((@right).tpe))
    }
    // TODO should probably not set this to a garbage value
    (@node).tpe = (@left).tpe
}

def walk_PSub(node: *parser::Node, state: *State) {
    walk_PAdd(node, state)
}

def walk_Defer(node: *parser::Node, state: *State) {
    let function = current_function(state)
    if not function {
        // TODO allow defer outside of functions
        assert(false)
    }
    function.has_defer = true

    for var i in 0..vector::length((@node).value.body) {
        let n = vector::get((@node).value.body, i) !*parser::Node
        walk(node, n, state)
    }
}

export def walk(parent: *parser::Node, node: *parser::Node, state: *State) {
    if not node { return }
    node.parent = parent

    let scpe = state.scope
    if node.scope {
        state.scope = node.scope
    }

    switch (@node).kind !int {
        case parser::NodeKind::NULL:
            walk_Null(node, state)
        case parser::NodeKind::INTEGER:
            walk_Integer(node, state)
        case parser::NodeKind::BOOLEAN:
            walk_Boolean(node, state)
        case parser::NodeKind::STRING:
            walk_String(node, state)
        case parser::NodeKind::CHAR:
            walk_Char(node, state)
        case parser::NodeKind::FLOAT:
            walk_Float(node, state)
        case parser::NodeKind::RANGE..=parser::NodeKind::RANGE_INC:
            walk_Range(node, state)
        case parser::NodeKind::IDENTIFIER:
            walk_Identifier(node, state)
        case parser::NodeKind::SIZE_OF:
            walk_SizeOf(node, state)
        case parser::NodeKind::ALIGN_OF:
            walk_AlignOf(node, state)
        case parser::NodeKind::LOOP:
            walk_Loop(node, state)
        case parser::NodeKind::WHILE:
            walk_While(node, state)
        case parser::NodeKind::FOR:
            walk_For(node, state)
        case parser::NodeKind::IF_EXPR:
            walk_IfExpr(node, state)
        case parser::NodeKind::IF:
            walk_If(node, state)
        case parser::NodeKind::SWITCH:
            walk_Switch(node, state)
        case parser::NodeKind::CASE:
            walk_Case(node, state)
        case parser::NodeKind::DEF:
            walk_Def(node, state)
        case parser::NodeKind::IMPORT:
            walk_Import(node, state)
        case parser::NodeKind::CAST:
            walk_Cast(node, state)
        case parser::NodeKind::ASSIGN:
            walk_Assign(node, state)
        case parser::NodeKind::VAR_DECL:
            walk_VarDecl(node, state)
        case parser::NodeKind::UADD:
            walk_UAdd(node, state)
        case parser::NodeKind::USUB:
            walk_USub(node, state)
        case parser::NodeKind::BNOT:
            walk_BNot(node, state)
        case parser::NodeKind::NOT:
            walk_Not(node, state)
        case parser::NodeKind::ADD..=parser::NodeKind::MOD:
            walk_ArithmeticOp(node, state)
        case parser::NodeKind::BAND..=parser::NodeKind::SHR:
            walk_BitwiseOp(node, state)
        case parser::NodeKind::AND..=parser::NodeKind::OR:
            walk_BooleanOp(node, state)
        case parser::NodeKind::EQ..=parser::NodeKind::LEQ:
            walk_ComparisionOp(node, state)
        case parser::NodeKind::ADD_EQ..=parser::NodeKind::MOD_EQ:
            walk_AssignEqArithmetic(node, state)
        case parser::NodeKind::AND_EQ..=parser::NodeKind::SHR_EQ:
            walk_AssignEqBitwise(node, state)
        case parser::NodeKind::PADD_EQ..=parser::NodeKind::PSUB_EQ:
            walk_AssignEqPtr(node, state)
        case parser::NodeKind::PADD:
            walk_PAdd(node, state)
        case parser::NodeKind::PSUB:
            walk_PSub(node, state)
        case parser::NodeKind::DEREF:
            walk_Deref(node, state)
        case parser::NodeKind::PTR:
            walk_Ptr(node, state)
        case parser::NodeKind::TYPE_DECL:
            walk_TypeDecl(node, state)
        case parser::NodeKind::RETURN:
            walk_Return(node, state)
        case parser::NodeKind::FUNC_CALL:
            walk_Call(node, state)
        case parser::NodeKind::BREAK..=parser::NodeKind::CONTINUE:
            // Noop
            null
        case parser::NodeKind::MEMBER_ACCESS:
            walk_MemberAccess(node, state)
        case parser::NodeKind::ARRAY_SUBSCRIPT:
            walk_ArraySubscript(node, state)
        case parser::NodeKind::STRUCT_LIT:
            walk_StructLit(node, state)
        case parser::NodeKind::ARRAY_LIT:
            walk_ArrayLit(node, state)
        case parser::NodeKind::DEFER:
            walk_Defer(node, state)
        case parser::NodeKind::PTR_T:
            walk_PtrT(node, state)
        case:
            error((@node).kind, "\n")
            assert(false)
    }

    state.scope = scpe
}

export def make_state(module: *toolchain::Module) -> State {
    return {
        module = module,
        scope = module.scope,
        function_stack = vector::make()
    } !State
}

export def typecheck(module: *toolchain::Module) {
    let state = make_state(module)
    typecheck(*state)
}

export var time_spent: int64 = 0

export def typecheck(state: *State) {
    let start = util::millis()

    let node = state.module.node
    assert((@node).kind == parser::NodeKind::PROGRAM)

    node.scope = state.scope

    let string_array_tpe = array(builtins::string_)
    let args_ident = parser::make_identifier(["args"])

    // repl tries to define this multiple times 
    // so we need to skip the declaration if it alreay exists
    if not scope::get(node.scope, args_ident) {
        scope::create_variable(
            node.scope, 
            args_ident, 
            parser::ShareMarker::NONE, 
            parser::VarDecl::VAR, 
            string_array_tpe, null
        )
    }
    let value = scope::get((@node).scope, args_ident)
    (@value).global = false
    
    if not toolchain::is_preload(state.module) {
        // compile standard library
        toolchain::typecheck_module(parser::make_identifier(["cstd"]))
        toolchain::typecheck_module(parser::make_identifier(["std"]))
    }

    if state.module.module == "main" {
        toolchain::typecheck_module(parser::make_identifier(["preload"]))
    }

    for var i in 0..vector::length((@node).value.body) {
        let n = vector::get((@node).value.body, i) !*parser::Node
        switch n.kind !int {
            case parser::NodeKind::TYPE_DECL, parser::NodeKind::DEF, parser::NodeKind::VAR_DECL:
            case: walk(node, n, state)
        }
    }

    let end = util::millis()
    time_spent += end - start
}

