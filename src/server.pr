// This is the entry point for a language server as defined by the LSP
import vector
import map
import json

const VERSION = "0.0.1"

const ParseError = -32700
const InvalidRequest = -32600
const MethodNotFound = -32601
const InvalidParams = -32602
const InternalError = -32603

const ServerNotInitialized = -32002
const UnknownErrorCode = -32001

type MessageType = enum {
    Error = 1
    Warning = 2
    Info = 3
    Log = 4
}

type DocumentUri = &string

type TextDocumentIdentifier = struct {
    uri: DocumentUri
}

type Position = struct {
    line: int
    character: int
}

type WorkspaceFolder = struct {
    uri: DocumentUri
    name: &string
}

type InitializeParams = struct {
    processId: int
    clientInfo: struct {
        name: &string
        version: &string
    }
    locale: &string
    rootPath: &string
    rootUri: DocumentUri
    initializationOptions: &JsonTree
    capabilities: &JsonTree
    trace: &string
    workspaceFolders: &[WorkspaceFolder]
}

type DefinitionParams = struct {
    textDocument: TextDocumentIdentifier
    position: Position
}

def go_to_definition(id: int, params: DefinitionParams) {
    send_error(id, InternalError, "Not implemented")
}

def initialize(id: int, params: InitializeParams) {
    let result = json::make_object()

    let capabilities = json::make_object()
    capabilities["positionEncoding"] = "utf-8"
    capabilities["textDocumentSync"] = 2 // Incremental
    capabilities["definitionProvider"] = true

    let serverInfo = json::make_object()
    serverInfo["name"] = "Princess Language Server"
    serverInfo["version"] = VERSION

    result["capabilities"] = capabilities
    result["serverInfo"] = serverInfo
    
    send_reply(id, result)
}

def initialized {
    let watcherPr = json::make_object()
    watcherPr["globPattern"] = "**/*.pr"
    let watchers = json::make_array()
    watchers.push(watcherPr)

    let registerOptions = json::make_object()
    registerOptions["watchers"] = watchers

    let registration = json::make_object()
    registration["id"] = "didChangeWatchedFiles"
    registration["method"] = "workspace/didChangeWatchedFiles"
    registration["registerOptions"] = registerOptions

    let registrations = json::make_array()
    registrations.push(registration)

    let obj = json::make_object()
    obj["registrations"] = registrations

    def on_register(reply: &JsonTree) {}
    send_request("client/registerCapability", obj, reply = *on_register)
}

type Header = &Vector(&string)

def get(header: Header, key: &string) -> &string {
    for var i in 0..header.length {
        let entry = header[i]
        if entry.starts_with(key + ": ") {
            return entry.substring(entry.index_of(": ") + 2)
        }
    }
    return null
}

def read_header -> Header {
    let header = vector::make(type &string)
    loop {
        var s: &string = ""
        loop {
            var c: char
            read(std::stdin(), *c)
            if c == '\r' {
                read(std::stdin(), *c)
                if c == '\n' {
                    break
                }
            } else {
                s += c
            }
        }
        if s.length == 0 {
            break
        }
        header.push(s)
    }
    return header
}

def send_message(payload: &JsonTree) {
    let message = to_string(payload)
    print("Content-Length: ", message.length, "\r\n")
    print("Content-Type: application/vscode-jsonrpc; charset=utf-8\r\n")
    print("\r\n")
    print(message)
    fflush(std::stdout())
}

def log_message(str: &string, tpe: int = MessageType::Log) {
    let obj = json::make_object()
    obj["type"] = tpe
    obj["message"] = str
    send_request("window/logMessage", obj)
}

var request_id: size_t = 0
def send_request(method: &string, params: &JsonTree, reply: &JsonTree -> ()) {
    on_reply(request_id, reply)
    send_request(method, params)
}

def send_request(method: &string, params: &JsonTree) {
    let obj = json::make_object()
    obj["jsonrpc"] = "2.0"
    obj["id"] = request_id !int
    obj["method"] = method
    obj["params"] = params
    send_message(obj)
    request_id += 1
}

def send_error(id: int, error_code: int, message: &string, data: &JsonTree = null) {
    error(message, "\n")

    let obj = json::make_object()
    obj["jsonrpc"] = "2.0"
    obj["id"] = id

    let error = json::make_object()
    error["code"] = error_code
    error["message"] = message
    if data {
        error["data"] = data
    }
 
    obj["error"] = error

    send_message(obj)
}

def send_reply(id: int, data: &JsonTree) {
    let obj = json::make_object()
    obj["jsonrpc"] = "2.0"
    obj["id"] = id
    obj["result"] = data
    send_message(obj)
}

def read_message -> &JsonTree {
    let header = read_header()
    if not header {
        send_error(0, ParseError, "Invalid header")
        return null
    }
    let content_length = parse_int(header.get("Content-Length"))
    if content_length == 0 {
        send_error(0, ParseError, "Invalid Content-Length")
        return null
    }
    let encoding = header.get("Content-Type")
    if encoding {
        if encoding != "application/vscode-jsonrpc; charset=utf-8" and
            encoding != "application/vscode-jsonrpc; charset=utf8" {
            
            send_error(0, ParseError, "Incalid Content-Type")
            return null
        }
    }

    let message_str = zero_allocate(char, content_length + 1)
    read(std::stdin(), message_str, content_length)
    error(message_str, "\n")
    let message = json::parse(message_str)
    if message.status == json::Status::JSON_ERROR {
        send_error(0, ParseError, "Can't parse content as json")
        return null
    }
    return message
}

var is_initialized = false
var is_shutdown = false
var reply_handlers = map::make(size_t, type &JsonTree -> ())

def on_reply(id: size_t, handler: &JsonTree -> ()) {
    reply_handlers[id] = handler
}

export def main -> int {
    loop {
        let message = read_message()
        if message {
            let id = message["id"].as_int() if message.has_item("id") else 0
            var method = message["method"].as_string() if message.has_item("method") else null
            let params = message["params"]

            if not method {
                if message.has_item("error") {
                    let error_msg = message["error"]["message"].as_string()
                    error("Error: ", error_msg, "\n")
                } else {
                    let request_id = id !size_t
                    // This is a response
                    if not reply_handlers.contains(request_id) {
                        send_error(id, InvalidRequest, "Not a valid request id")
                        continue
                    }
                    let handler = reply_handlers[request_id]
                    handler(message["result"])
                    reply_handlers.remove(request_id)
                    continue
                }
            }
        
            if method == "exit" {
                if is_shutdown {
                    return 0
                } else {
                    return 1
                }
            }

            if is_shutdown {
                send_error(id, InvalidRequest, "Server is shut down")
                continue
            }

            if method == "shutdown" {
                is_shutdown = true
                send_reply(id, null)
                continue
            }

            if not is_initialized {
                if method == "initialize" {
                    is_initialized = true
                    let p = json::deserialize(params, InitializeParams)
                    if not p.exists { send_error(id, ParseError, "Couldn't parse parameters") }
                    else { initialize(id, p.get()) }
                } else {
                    send_error(id, ServerNotInitialized, "Server not initialized!")
                }
                continue
            }

            if method {
                if method == "initialized" {
                    initialized()
                } else if method == "textDocument/definition" {
                    let p = json::deserialize(params, DefinitionParams)
                    if not p.exists { send_error(id, ParseError, "Couldn't parse parameters") }
                    else { go_to_definition(id, p.get()) }
                } else {
                    send_error(id, MethodNotFound, "Method " + method + " not found")
                }
            } else {
                send_error(id, MethodNotFound, "No method specified")
            }
        }
    }
    return 1
}