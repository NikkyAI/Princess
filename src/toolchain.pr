// This file handles all global state related to compiling

import vector
import util
import map
import set
import lexer
import compiler
import parser
import typechecking
import scope
import codegen
import debug
import builtins
import consteval
import errors

// Contains the scopes for already compiled modules 
// map of Module
export let modules = map::make(type &Module)

export var include_path = vector::make(type &string)
export var clang_flags = vector::make(type &string)
export var link_directories = vector::make(type &string)
export var link_libraries = vector::make(type &string)
export var link_flags = vector::make(type &string)

export var time_report = false
export var dependency_graph = false

let include: &string = util::exe_folder() + "/../include"
let stdlib: &string = util::exe_folder() + "/../std"

include_path.push(include)
include_path.push(stdlib)
include_path.push(".")
export var outfolder = util::tmpfolder("princess")

#if defined WIN32 {
    export var outfile: &string = "a.exe"
    let clang = "clang.exe"
    let link = "llvm-link.exe"
} else {
    export var outfile: &string = "a.out"
    let clang = "clang-13"
    let link = "llvm-link-13"
}

def create_version_string -> string {
    var ret: &string = "Princess "
    let version_file = util::exe_folder() + "/../version"
    let fp = open(@version_file, "r")
    let version_str = util::replace_all(util::read_all(fp), "VERSION=", "")
    ret += version_str
    close(fp)
    return @ret
}

export const version = "0.3.1"

// Debug stuff 
export var print_ast = false
// This flag controls emitting debug information to llvm
export var debug_sym = false

var main_module_name: &string

export def add_define(define: &string) {
    let tokens = lexer::lex(define)
    let program = parser::parse(tokens, [define], "<internal>", "<internal>")
    if errors::error_count != 0 {
        error("Error parsing define `", define, "`\n")
        exit(1)
    }
    delete(tokens)
    let body = program.body
    if vector::length(body) != 1 {
        error("Too many statements in define `", define, "`\n")
        exit(1)
    }
    let node = vector::peek(body)
    if node.kind == parser::NodeKind::ASSIGN {
        if vector::length(node.value.assign.left) != vector::length(node.value.assign.right) != 1 {
            error("Invalid define `", define, "`, must be single assignment\n")
            exit(1)
        }
        let identifier = vector::peek(node.value.assign.left)
        let right = vector::peek(node.value.assign.right)

        if identifier.kind != parser::NodeKind::IDENTIFIER {
            error("Invalid define `", define, "`, must be single assignment\n")
            exit(1)
        }

        var value: &compiler::Value

        switch right.kind {
            /*case parser::NodeKind::STRING:
                @value = { 
                    kind = compiler::ValueKind::STRING, 
                    tpe = typechecking::make_static_array(builtins::char_, right.value.str.size), 
                    s = right.value.str 
                } !compiler::Value*/
            case parser::NodeKind::INTEGER:
                value = { kind = compiler::ValueKind::INT, tpe = builtins::int_, i = right.value.i } !&compiler::Value
            case parser::NodeKind::BOOLEAN:
                value = { kind = compiler::ValueKind::BOOL, tpe = builtins::bool_, i = right.value.i } !&compiler::Value
            case parser::NodeKind::CHAR:
                value = { kind = compiler::ValueKind::INT, tpe = builtins::char_, i = right.value.i } !&compiler::Value
            case parser::NodeKind::FLOAT:
                value = { kind = compiler::ValueKind::FLOAT, tpe = builtins::double_, f = right.value.f } !&compiler::Value
            case: error("Invalid define, `", define, "`, must be basic type\n")
        }
        scope::create_variable(builtins::builtins, identifier, parser::ShareMarker::NONE, parser::VarDecl::CONST, value.tpe, value)
    } else if node.kind == parser::NodeKind::IDENTIFIER {
        let value = { kind = compiler::ValueKind::BOOL, tpe = builtins::bool_, i = true !int64 } !&compiler::Value
        scope::create_variable(builtins::builtins, node, parser::ShareMarker::NONE, parser::VarDecl::CONST, builtins::bool_, value)
    } else {
        error("Invalid define `", define, "`, must be an assignment or an identifier\n")
        exit(1)
    }
}

export type Stage = enum {
    PREPROCESS
    TYPECHECKING
    COMPILING
}

export type Module = struct {
    filename: &string
    llfile: &string
    module: &string
    node: &parser::Node
    scope: &scope::Scope
    // This is code that gets inserted by consteval/eval
    // it must be prepended to the main function 
    code: &compiler::Block
    result: &compiler::Result
    // TODO This should not be needed
    imported: &SSet
    difile: &compiler::Value
    stage: Stage
    // Vector of Module
    dependants: &Vector(weak_ref(Module))
    // List of Type
    // This is a list of functions that are generated for dynamic dispatch
    dyn_dispatch: &Vector(&typechecking::Type)
    // This is needed to generate functions from create_destructor
    compiler_state: &compiler::State
    state: &typechecking::State
}

export def make_module(filename: &string, modulename: &string, node: &parser::Node, scpe: &scope::Scope) -> &Module {
    let module = {
        filename = filename,
        module = modulename,
        node = node,
        scope = scpe,
        result = compiler::make_result(),
        code = compiler::make_block(),  
        imported = set::make(),
        dependants = vector::make(type weak_ref(Module)),
        dyn_dispatch = vector::make(type &typechecking::Type)
    } !&Module
    module.compiler_state = compiler::make_state(module )
    return module
}

export def is_preload(module: &Module) -> bool {
    if module.module == "runtime" { 
        return true 
    } else if module.module == "const" {
        return false
    }

    let mfilename = absolute_path(module.filename)
    let ifilename = absolute_path(include)

    let s = starts_with(mfilename, ifilename)
    return s
}

export def find_module_file(module: &parser::Node) -> &string {
    assert module.kind == parser::NodeKind::IDENTIFIER
    let ident = module.value.identifier.path
    var path: &string = ""

    let len = vector::length(ident)
    for var i in 0..len {
        var str = ident[i]
        path += str
        if i < len - 1 {
            path += "/"
        }
    }

    for var i in 0..vector::length(include_path) {
        var module_path = include_path[i] + "/" + path + ".pr"
        if util::exists(module_path) {
            return module_path
        }
    }
    return null
}

// name is an identifier
export def typecheck_module(name: &parser::Node) -> &Module {
    let modulename = parser::identifier_to_str(name)
    var module = modules.get_or_default(modulename, null)
    if module and module.stage < Stage::TYPECHECKING {
        module.stage = Stage::TYPECHECKING
        typechecking::typecheck(module)
        return module
    }
    return null
}

export def compile_module(name: &parser::Node) -> &Module {
    let modulename = parser::identifier_to_str(name)
    var module = modules.get_or_default(modulename, null)
    if module and module.stage < Stage::COMPILING {
        module.stage = Stage::COMPILING
        compiler::compile(module)
        return module
    }
    return null
}

export def consteval_file(filename: &string, modulename: &string) -> &Module {
    let fh = open(@filename, "rb")
    if not fh {
        error("File \"", filename, "\" doesn't exist\n")
    } else {
        let buf = util::read_all(fh)
        close(fh)
        let lines = util::split_lines(buf)

        debug::trace("Lexing ", modulename)
        let tokens = lexer::lex(buf)
        let node = parser::parse(tokens, lines, filename, modulename)
        delete(tokens)
        if print_ast {
            debug::print_node(node)
        }
        
        var sc = scope::enter_function_scope(builtins::builtins, null)
        var module = make_module(filename, modulename, node, sc)
        let state = compiler::make_state(module)
        sc.module = module

        module.compiler_state = state
        modules[modulename] = module

        consteval::consteval(module)

        return module
    }
    return null
}

// TODO This is inconsistent with the functions above, as a cached module is returned
// name is an identifier
export def consteval_module(name: &parser::Node) -> &Module {
    let modulename = parser::identifier_to_str(name)
    if modulename == main_module_name {
        return modules["main"]
    }
    var module = modules.get_or_default(modulename, null)
    if not module {
        let filename = find_module_file(name)
        if not filename { return null }
        module = consteval_file(filename, modulename)
    }

    return module
}

def generate_runtime_source -> string {
    let runtime = util::exe_folder() + "/../src/runtime.pr"
    let fp = open(@runtime, "r")
    let source = util::read_all(fp)
    close(fp)
    return @source
}

const runtime_source = "
import cstd

export type TypeKind = enum {
    BOOL
    WORD
    FLOAT
    STRUCT
    UNION
    ARRAY
    STATIC_ARRAY
    POINTER
    REFERENCE
    FUNCTION
    ENUM
    CHAR
    STRUCTURAL
    OPAQUE
    WEAK_REF
}

export type Function = struct {
    name: string
    exported: bool
    module: string
    parameter_t: [*Type]
    return_t: [*Type]
}

// TODO Potentially preserve type names
export type Type = struct {
    kind: TypeKind
    name: string
    unsig: bool
    length: size_t
    tpe: *Type
    size: size_t
    align: size_t
    fields: [Field]
    parameters: [*Type]
    returns: [*Type]
    enum_values: [EnumValue]
    module: string
    structural_members: [Function]
    type_members: [Function]
    id: int64
}

export type EnumValue = struct {
    name: string
    value: int64
}

export type Field = struct {
    name: string
    offset: size_t
    tpe: *Type
}

export type Ref = struct {
    ref_count: *int64
    value: *
    tpe: *Type
}

// TODO We can probably live without the allocation in here if we directly compare the values
def cut_name(s: string) -> string {
    var end = 0
    while s[end] != '(' and end < s.size - 1 {
        end += 1
    }
    if s[end] == '(' {
        end -= 2
    }
    
    var start = end - 1
    while s[start] != ':' and start > 0 {
        start -= 1
    }
    if s[start] == ':' {
        start += 1
    }

    let size = end - start
    var ret: string
    ret.value = cstd::malloc((size + 1) * (size_of char)) !*char
    cstd::memcpy(ret.value, s.value ++ start, size)
    ret.value[size] = '\0'
    ret.size = size + 1

    return ret
}

// TODO Need to do structural type implements structural type
export def implements(A: *Type, B: *Type) -> bool {
    // TODO We want to log something here
    if B.kind != TypeKind::STRUCTURAL { abort() }

    for var i in 0..B.structural_members.size {
        let member = B.structural_members[i]

        var found = false
        for var j in 0..A.type_members.size {            
            let type_member = A.type_members[j]
            // Exported
            if A.module != type_member.module and not type_member.exported { continue } 

            // Name
            let name = cut_name(type_member.name)
            if name != member.name { continue }
            cstd::free(name.value)
            
            // Parameter types
            if type_member.parameter_t.size != member.parameter_t.size + 1 { continue }
            
            // TODO work around missing goto
            var mismatch = false
            for var i in 0..member.parameter_t.size {
                let left = member.parameter_t[i]
                let right = type_member.parameter_t[i + 1]
                if not equals(left, right) { 
                    mismatch = true
                    break 
                }
            }
            if mismatch { continue }

            // Return types
            if type_member.return_t.size != member.return_t.size { continue }
            for var i in 0..member.return_t.size {
                let left = member.return_t[i]
                let right = type_member.return_t[i]
                if not equals(left, right) { 
                    mismatch = true
                    break 
                }
            }
            if mismatch { continue }

            found = true
            break
        }
        if not found { return false }
    }
    return true
}

export def ref_type(a: Ref) -> *Type {
    return a.tpe
}

export def equals(a: *Type, b: *Type) -> bool {
    if a !* == b !* { return true }
    if not a or not b { return false }
    if a.kind != b.kind { return false }
    if a.kind == TypeKind::BOOL or a.kind == TypeKind::CHAR { return true }
    if a.kind == TypeKind::WORD {
        return a.size == b.size and a.unsig == b.unsig
    }
    if a.kind == TypeKind::FLOAT {
        return a.size == b.size
    }
    if a.kind == TypeKind::STATIC_ARRAY {
        return a.length == b.length and equals(a.tpe, b.tpe)
    }
    if a.kind == TypeKind::ARRAY or a.kind == TypeKind::POINTER or a.kind == TypeKind::REFERENCE {
        return equals(a.tpe, b.tpe)
    }
    if a.kind == TypeKind::FUNCTION {
        if a.parameters.size != b.parameters.size { return false }
        if a.returns.size != b.returns.size { return false }
        for var i in 0..a.parameters.size {
            if not equals(a.parameters[i].tpe, b.parameters[i].tpe) { return false }
        }
        for var i in 0..a.returns.size {
            if not equals(a.returns[i], b.returns[i]) { return false }
        }
    }

    return a.id == b.id
}

// Caller must clean up
export def reference(tpe: *Type) -> *Type {
    if not tpe { return null }
    let ret = cstd::malloc(size_of Type) !*Type
    @ret = { 
        kind = TypeKind::REFERENCE,
        size = size_of &,
        align = align_of &,
        tpe = tpe
    } !Type
    return ret
}
"

export var runtime: &Module
export var types: &Module
export var types_state: &compiler::State

def create_runtime_module {
    if runtime { return }
    debug::trace("Creating runtime module")

    let lines = util::split_lines(runtime_source)
    let tokens = lexer::lex(runtime_source)
    let node = parser::parse(tokens, lines, "runtime.pr", "runtime")

    let runtime_module = make_module(
        filename = "runtime.pr",
        modulename = "runtime",
        node = node,
        scpe = scope::enter_function_scope(builtins::builtins, null)
    )
    runtime_module.scope.module = runtime_module 

    modules["runtime"] = runtime_module
    runtime = runtime_module

    consteval::consteval(runtime_module)
    runtime_module.stage = Stage::TYPECHECKING
    typechecking::typecheck(runtime_module)
    
    builtins::Type_ = scope::get_type(runtime.scope, make_identifier("Type"))
    builtins::Ref_  = scope::get_type(runtime.scope, make_identifier("Ref"))
    builtins::Function_  = scope::get_type(runtime.scope, make_identifier("Function"))
}

def create_types_module {
    if types { return }
    debug::trace("Creating types module")
    types = make_module(
        filename = null,
        modulename = "type",
        node = null,
        scpe = scope::enter_scope(null, types)
    )
    modules["type"] = types

    types_state = compiler::make_state(types)
    types_state.consteval = true
    types_state.scope = builtins::builtins
    types_state.current_block = types.code
}

export def prepare_preload {
    create_runtime_module()
    create_types_module()

    let keys = map::keys(runtime.scope.fields)
    for var i in 0..keys.size {
        let name = keys[i]
        let value = runtime.scope.fields[name]
        if typechecking::equals(value.tpe, builtins::type_) {
            let tpe = value.value.value_tpe
            types.result.structures[tpe.type_name] = tpe
        }
    }
}

export def create_types_main {
    let types = types 

    let types_main_ident = parser::make_identifier("__main__")
    types_main_ident.loc.module = types.module

    let args = vector::make(typechecking::NamedParameter)
    args.push({
        name = "args",
        tpe = typechecking::array(builtins::string_)
    } !typechecking::NamedParameter)

    let main_tpe = typechecking::make_function_type_n(types_main_ident, args, vector::make(type &typechecking::Type), types)
    scope::create_function(types.scope, types_main_ident, parser::ShareMarker::EXPORT, main_tpe)

    let types_main = compiler::predeclare_function(main_tpe, types)
    types_main.block = types.code
    types_main.forward_declare = false
    
    types.imported.add(main_tpe.type_name)
}

export def load_file_type {
    let std_module = modules["std"]
    builtins::File_ = scope::get_type(std_module.scope, parser::make_identifier("File"))
}

export def reset_types {
    types.scope = scope::enter_scope(null, null)
    types.code = compiler::make_block()
    types_state.current_block = types.code
    types_state.consteval = false
    types_state.module.result = compiler::make_result()
    create_types_main()
}

def extract_module_name(filename: &string) -> &string {
    // TODO Path manipulation should be made easier
    var folder_sep = filename.last_index_of("/")
    if folder_sep == -1 {
        folder_sep = filename.last_index_of("\\")
    }
    if folder_sep == -1 {
        folder_sep = 0
    }
    return filename.substring(folder_sep - 1 if folder_sep > 0 else 0, filename.length() - 4)
}

export def compile_main_file(filename: &string) {
    if not filename.ends_with(".pr") {
        error("File ", filename, " is not a Princess source file")
        exit(1)
    }

    let start_frontend = util::millis()

    prepare_preload()
    create_types_main()

    main_module_name = extract_module_name(filename)
    var module = consteval_file(filename, "main") 
    if not module { exit(1) }

    module.stage = Stage::TYPECHECKING
    typechecking::typecheck(module)

    load_file_type()

    module.stage = Stage::COMPILING
    reset_types()
    compiler::compile(module)

    debug::trace("Resolving types")
    compiler::resolve_types()
    debug::trace("Creating builtin functions")
    compiler::create_builtin_functions()

    let ret = compiler::make_insn(compiler::InsnKind::RET)
    ret.value.ret.value = compiler::NO_VALUE
    types.code.insn.push(ret)

    if dependency_graph {
        print_dependency_graph(module)
        exit(0)
    }

    if time_report {
        print("Frontend: \n")
        print("--------------------------------------\n")
        print("              Lexing: ", lexer::time_spent / 1000.0, "s \n")
        print("             Parsing: ", parser::time_spent / 1000.0, "s \n")
        print("Constant propagation: ", consteval::time_spent / 1000.0, "s \n")
        print("        Typechecking: ", typechecking::time_spent / 1000.0, "s \n")
        print("           Compiling: ", compiler::time_spent / 1000.0, "s \n")
    }

    let end_frontend = util::millis()

    if errors::error_count == 0 {

        #if defined WIN32 {
            let compile_cstd = clang + " -S -emit-llvm -o " + outfolder + "/cstd_include.ll " + include + "/cstd.c"
            system(@compile_cstd)
        }

        var link_command: &string = link + " -S "

        if debug::verbose { 
            link_command += "-v "
        }
        link_command += "-o " + outfolder + "/out.ll "

        #if defined WIN32 {
            link_command += outfolder + "/cstd_include.ll "
        }

        let filenames = map::keys(modules)
        for var i in 0..filenames.size {
            let filename = filenames[i]
            let module = modules[filename] 
            codegen::gen(module)

            link_command += module.llfile + ' '
        }

        if time_report {
            print("             Codegen: ", codegen::time_spent / 1000.0, "s \n")
            print("--------------------------------------\n")
            print("Total time frontend: ", (end_frontend - start_frontend) / 1000.0, "s \n")
            print("======================================\n")
            print("Backend: \n")
        }

        debug::trace("Linking with llvm-link...")
        debug::trace(link_command, "\n")
        let start_linking = util::millis()
        system(@link_command)
        let end_linking = util::millis()

        let start_compiling = util::millis()

        var compile_command: &string = clang
        #if defined WIN32 {
            compile_command += " -lUser32 -lKernel32 "
        } else {
            compile_command += " -lrt -lm -lpthread -lcrypt -ldl -lffi "
        }

        for var i in 0..link_directories.length {
            compile_command += "--library-directory=\"" + link_directories[i].replace_all("\\", "\\\\") + "\" "
        }
        for var i in 0..link_libraries.length {
            compile_command += "-l" + link_libraries[i] + " "
        }
        for var i in 0..link_flags.length {
            compile_command += "--for-linker=\"" + link_flags[i] + "\" "
        }
        for var i in 0..clang_flags.length {
            compile_command += clang_flags[i] + " "
        }

        if debug::verbose { 
            compile_command += "-v "
        }
        if debug_sym {
            compile_command += "-g "
        }

        compile_command += "--output "
        compile_command += outfile
        compile_command += ' '
        compile_command += outfolder
        compile_command += "/out.ll"

        debug::trace("Compiling with clang...")
        debug::trace(compile_command)
        system(@compile_command)

        let end_compiling = util::millis()

        if time_report {
            print("--------------------------------------\n")
            print("  Linking: ", (end_linking - start_linking) / 1000.0, "s \n")
            print("Compiling: ", (end_compiling - start_compiling) / 1000.0, "s \n")
            print("======================================\n")
            print("Total time backend: ", (end_compiling - start_linking) / 1000.0, "s \n")
            print("======================================\n")
            print("Total time: ", (end_compiling - start_frontend) / 1000.0, "s \n")
        }
    }
}


def print_dependency_graph(module: &Module, indent: &string, last: bool) {
    let branch = "└── " if last else "├── "
    print(indent, branch, module.module, "\n")

    if last {
        indent += "    "
    } else {
        indent += "│   "
    }
        
    let len = vector::length(module.dependants)
    for var i in 0..len {
        let dependant = module.dependants[i]
        print_dependency_graph(dependant, indent, i == len - 1)
    }
}

def print_dependency_graph(module: &Module) {
    print_dependency_graph(module, "", true)
}