// TODO This needs to be tested
// TODO It would also be nice to create a version that doesn't
// leak memory for the standard library

import map
import vector
import util


export type Value = struct {
    next: *Value
    struct #union {
        str: string
        arr: [string]
        b: bool
    }
}

export type Option = struct {
    shortop: char
    longop: string
    nargs: int
    repeat: bool
    help: string
    default: *Value
    is_set: bool
    value: *Value
}

export def option_repeat(shortop: char, longop: string, help: string) -> Option {
    return { shortop, longop, 1, true, help } !Option
}
export def option_repeat(shortop: char, longop: string, nargs: int, help: string) -> Option {
    return { shortop, longop, nargs, true, help } !Option
}
export def option_repeat(shortop: char, longop: string, default: [string], help: string) -> Option {
    var value: *Value = null
    for var i in 0..default.size {
        let next = zero_allocate(Value)
        next.str = default[i]
        if value { value.next = next }
        value = next
    }
    return { shortop, longop, 1, true, help, value } !Option
}
export def option_repeat(shortop: char, longop: string, nargs: int, default: [[string]], help: string) -> Option {
    var value: *Value = null
    for var i in 0..default.size {
        let next = zero_allocate(Value)
        next.arr = default[i]
        if value { value.next = next }
        value = next
    }
    return { shortop, longop, nargs, true, help, value } !Option
}

export def option_repeat(longop: string, help: string) -> Option {
    return option_repeat('\0', longop, help)
}
export def option_repeat(longop: string, nargs: int, help: string) -> Option {
    return option_repeat('\0', longop, nargs, help)
}
export def option_repeat(longop: string, default: [string], help: string) -> Option {
    return option_repeat('\0', longop, default, help)
}
export def option_repeat(longop: string, nargs: int, default: [[string]], help: string) -> Option {
    return option_repeat('\0', longop, nargs, default, help)
}

export def option(shortop: char, longop: string, nargs: int, default: [string], help: string) -> Option {
    assert(nargs == default.size)
    assert(nargs > 1) // TODO This is a bit arbitrary
    let value = zero_allocate(Value)
    value.arr = default
    return { shortop, longop, nargs, false, help, value }
}
export def option(shortop: char, longop: string, default: bool, help: string) -> Option {
    let value = zero_allocate(Value)
    value.b = default
    return { shortop, longop, 0, false, help, value }
}
export def option(shortop: char, longop: string, default: string, help: string) -> Option {
    let value = zero_allocate(Value)
    value.str = default
    return { shortop, longop, 1, false, help, value }
}

export def option(shortop: char, longop: string, nargs: int, help: string) -> Option {
    assert(nargs > 1)
    return { shortop, longop, nargs, false, help }
}
export def option(shortop: char, longop: string, help: string) -> Option {
    return { shortop, longop, 1, false, help }
}

export def option(longop: string, nargs: int, default: [string], help: string) -> Option {
    return option('\0', longop, nargs, default, help)
}
export def option(longop: string, default: bool, help: string) -> Option {
    return option('\0', longop, default, help)
}
export def option(longop: string, default: string, help: string) -> Option {
    return option('\0', longop, default, help)
}

export def option(longop: string, nargs: int, help: string) -> Option {
    return option('\0', longop, nargs, help)
}
export def option(longop: string, help: string) -> Option {
    return option('\0', longop, help)
}

def print_help(options: [Option]) {
    for var i in 0..options.size {
        
    }
}

def find_option(options: [Option], str: string, index: int) -> *Option {
    var optindex = 0
    for var i in 0..options.size {
        let option = *options[i]
        if not starts_with(option.longop, "-") {
            if index - optindex < option.nargs {
                return option
            } 
            optindex += option.nargs
        } else if starts_with(str, "--") {
            if option.longop == str {
                return option
            } else if starts_with(str, option.longop) and 
                length(str) > length(option.longop) and
                str[length(option.longop)] == '=' {

                return option        
            }
        } else {
            if length(str) > 1 and str[1] == option.shortop {
                return option
            }
        }
    }
    return null
}

def set_value(arg: string, option: *Option, value: *Value) -> bool {
    if option.is_set {
        if option.repeat {
            if not option.value {
                option.value = value
            } else {
                // Jump to the end of the linked list
                var last = option.value
                while last.next {
                    last = last.next
                }
                last.next = value
            }
        } else {
            error("Option ", arg, " was repeated!\n")
            return false
        }
    } else {
        option.value = value
    }
    option.is_set = true

    return true
}

export def parse(args: [string], options: [Option]) -> bool {
    var index = 0
    var i = 1
    while i < args.size {
        let arg = args[i]
        var option = find_option(options, arg, index)
        if starts_with(arg, "--") {
            if not option {
                error("Unknown long option: ", arg, "\n")
                return false
            }

            let value = zero_allocate(Value)
            if option.nargs == 0 {
                // parse --opt
                value.b = not option.default.b
                i += 1
            } else if length(arg) > length(option.longop) {
                // parse --opt="arg"
                if option.nargs != 1 {
                    error("Invalid number of arguments to option ", arg, "\n")
                    return false
                }
                value.str = arg
                value.str.value = value.str.value ++ length(option.longop) ++ 1
                value.str.size = strlen(value.str) + 1
                i += 1
            } else {
                if option.nargs == 1 {
                    // parse --opt arg
                    i += 1
                    if i < args.size and not starts_with(args[i], "-") {
                        value.str = args[i]
                    } else {
                        error("Not enough arguments to ", arg, "\n")
                        return false
                    }
                    i += 1
                } else {
                    // parse --opt arg1 arg2
                    let arr = allocate(string, option.nargs)
                    i += 1
                    for var j in 0..option.nargs {
                        if i < args.size and not starts_with(args[i], "-") {
                            arr[j] = args[i]
                        } else {
                            error("Not enough arguments to ", arg, "\n")
                            return false
                        }
                        i += 1
                    }
                    value.arr = arr
                }
            }
            if not set_value(arg, option, value) { return false }
        } else if starts_with(arg, "-") {
            var j = 1
            loop {
                if not option {
                    error("Unknown short option: ", arg, "\n")
                    return false
                }

                let value = zero_allocate(Value)
                if option.nargs == 0 {
                    // parse -X
                    value.b = not option.default.b
                    if j == length(arg) - 1 {
                        i += 1
                    }
                } else if option.nargs == 1 and j < length(arg) - 1 {
                    // parse -XArg
                    value.str = arg
                    value.str.value = value.str.value ++ j ++ 1
                    value.str.size = strlen(value.str) + 1
                    i += 1
                    j = length(arg) !int - 1
                } else if j == length(arg) - 1 {
                    if option.nargs == 1 {
                        // parse -X arg
                        i += 1
                        if i < args.size and not starts_with(args[i], "-") {
                            value.str = args[i]
                        } else {
                            error("Not enough arguments to ", arg, "\n")
                            return false
                        }
                        i += 1
                    } else {
                        // parse -X arg1 arg2
                        let arr = allocate(string, option.nargs)
                        i += 1
                        for var j in 0..option.nargs {
                            if i < args.size and not starts_with(args[i], "-") {
                                arr[j] = args[i]
                            } else {
                                error("Not enough arguments to ", arg, "\n")
                                return false
                            }
                            i += 1
                        }
                        value.arr = arr
                    }
                } else {
                    error("Invalid argument: ", arg, "\n")
                    return false
                }
                if not set_value(arg, option, value) { return false }
                
                // Deal with mashed shortopts like -abc for -a -b -c
                j += 1
                if j < length(arg) {
                    for var i in 0..options.size {
                        let option2 = *options[i]
                        if option2.shortop == arg[j] {
                            option = option2
                            break
                        }
                    }
                    continue
                }
                break
            }
        } else {
            if not option {
                error("Too many positional arguments\n")
                return false
            }

            let value = zero_allocate(Value)

            if option.nargs == 1 {
                value.str = args[i]
                i += 1
            } else {
                let arr = allocate(string, option.nargs)
                for var j in 0..option.nargs {
                    if i < args.size and not starts_with(args[i], "-") {
                        arr[j] = args[i]
                    } else {
                        error("Not enough arguments to ", option.longop, "\n")
                        return false
                    }
                    i += 1
                }
                value.arr = arr
            }

            option.value = value
            option.is_set = true
            index += option.nargs
        }
    }
    for var i in 0..options.size {
        let option = *options[i]
        if not option.is_set {
            if not option.default and not option.repeat {
                error("Option ", option.longop, " not specified\n")
                return false
            } else {
                option.value = option.default
            }
        }
    }
    return true
}