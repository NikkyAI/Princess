// This scans a file and predeclares every type, function and variable
// TODO This also needs to execute static if statements

import vector
import map
import toolchain
import scope
import parser
import typechecking
import compiler
import builtins

let module = zero_allocate(toolchain::Module)
@module = {
    imported = map::make()
} !toolchain::Module

// This is for compiling expressions
export let compiler_state = compiler::create_state(module)

def reset_state {
    compiler_state.current_block = compiler::make_block()
}

import eval

export def make_value(value: compiler::Value) -> *scope::Value {
    let svalue = zero_allocate(scope::Value)
    let valuep = allocate(compiler::Value)
    @valuep = value
    svalue.value = valuep
    svalue.tpe = value.tpe
    return svalue
}

// If we store the state we need to create a permanent copy
def copy_state(state: *typechecking::State) -> *typechecking::State {
    let new_state = allocate(typechecking::State)
    @new_state = @state
    new_state.function_stack = vector::copy(state.function_stack)
    return new_state
}

export def expr(parent: *parser::Node, node: *parser::Node, state: *typechecking::State) -> compiler::Value {
    typechecking::walk(node.parent, node, state)
    var result = compiler::walk_expression(node, compiler_state)
    result = eval::eval_expression(compiler_state.current_block, result)
    reset_state()
    return result
}

export def boolean_expr(parent: *parser::Node, node: *parser::Node, state: *typechecking::State) -> compiler::Value {
    typechecking::walk(node.parent, node, state)
    var result = compiler::walk_expression(node, compiler_state)
    result = compiler::convert_to(node, result, builtins::bool_, compiler_state)
    result = eval::eval_expression(compiler_state.current_block, result)
    reset_state()
    return result
}

def walk_StaticIf(node: *parser::Node, state: *typechecking::State) {
    var result = boolean_expr(node, node.value.if_.cond, state)

    var body: *vector::Vector = null
    if result.i {
        body = node.value.if_.body
    } else {
        for var i in 0..vector::length(node.value.if_.else_if) {
            let else_if = vector::get(node.value.if_.else_if, i) !*parser::Node
            result = boolean_expr(else_if, else_if.value.else_if.cond, state)
            if result.i { 
                body = else_if.value.else_if.body
                break
            }
        }
        let else_ = node.value.if_.else_
        if not result.i and else_ {
            body = else_.value.body
        }
    }
    
    let index = vector::index_of(node.parent.body, node)
    vector::remove(node.parent.body, index)
    if body {
        vector::insert(node.parent.body, index, body)
        for var i in 0..vector::length(body) {
            walk(node.parent, vector::get(body, i) !*parser::Node, state)
        }
    }
}

def walk_Import(node: *parser::Node, state: *typechecking::State) {
    let imports = (@node).value.body
    for var i in 0..vector::length(imports) {
        let imprt = vector::get(imports, i) !*parser::Node
        var name = (@imprt).value.import_module.name
        var alias = (@imprt).value.import_module.alias
        if not alias {
            alias = name
        }
        let module = toolchain::preprocess_module(name)
        if not module {
            typechecking::errorn(name, "Module ")
            error(parser::identifier_to_str(name), " could not be found\n")
            return
        }
        scope::insert_module(state.scope, alias, module)
    }
}

def walk_Def(node: *parser::Node, state: *typechecking::State) {
    let share = node.value.def_.share
    let name = node.value.def_.name
    let params = node.value.def_.params
    let returns = node.value.def_.returns
    let body = node.value.def_.body

    let parameter_t = vector::make()
    let return_t = vector::make()
    for var i in 0..vector::length(params) {
        let param = vector::get(params, i) !*parser::Node
        assert(param.kind == parser::NodeKind::PARAMETER)
        
        let named = allocate(typechecking::NamedParameter)
        let name = param.value.param.name
        let tpe = typechecking::type_lookup(param.value.param.tpe, state, true)
        named.name = last_ident_to_str(name)
        named.value = tpe
        named.varargs = (@param).value.param.varargs
        named.node = name
        vector::push(parameter_t, named)
    }
    for var i in 0..vector::length(returns) {
        let n = vector::get(returns, i) !*parser::Node
        let tpe = typechecking::type_lookup(n, state, true)
        vector::push(return_t, tpe)
    }

    let tpe = typechecking::make_function_type_n(name, parameter_t, return_t, true)
    if body {
        scope::create_function(state.scope, name, share, tpe, true, node, copy_state(state))
    } else {
        scope::create_function(state.scope, name, share, tpe, true)
    }

    if body {
        state.scope = scope::enter_function_scope(state.scope)
        node.inner_scope = state.scope
        for var i in 0..vector::length(body) {
            walk(node, vector::get(body, i) !*parser::Node, state)
        }
        state.scope = scope::exit_scope(state.scope)
    }
}

import debug
def walk_TypeDecl(node: *parser::Node, state: *typechecking::State) {
    let share = node.value.type_decl.share
    let left = node.value.type_decl.left
    let right = node.value.type_decl.right

    for var i in 0..vector::length(left) {
        let name = vector::get(left, i) !*parser::Node

        var value: *parser::Node = null
        if i < vector::length(right) {
            value = vector::get(right, i) !*parser::Node
        }
        var tpe = typechecking::make_type(typechecking::TypeKind::STUB, name)

        if vector::length(name.value.body) > 1 {
            if value {
                typechecking::errorn(name, "Can't create type in sub scope\n")
                continue
            }
            let scpe = toolchain::get_forward_declared_scope(name)
            let last = vector::peek((@name).value.body) !*string
            let n = parser::copy_node(name)
            (@n).value.body = vector::make()
            vector::push((@n).value.body, last)
            tpe = scope::create_type(scpe, n, share, tpe)
        }

        if value {
            if value.kind == parser::NodeKind::ENUM_T {
                tpe = typechecking::copy(typechecking::type_lookup(value, state))
                tpe.name = parser::identifier_to_str(name)
                tpe.type_name = typechecking::append_module(tpe.name, value.loc.module)

                var constant: int64 = 0
                // Create all the constants
                let scpe = scope::enter_scope(state.scope)
                for var i in 0..vector::length(value.value.t_enum.body) {
                    let iddecl = vector::get(value.value.t_enum.body, i) !*parser::Node
                    if iddecl.value.id_decl_enum.value {
                        constant = expr(value, iddecl.value.id_decl_enum.value, state).i
                    }

                    let c = allocate(compiler::Value)
                    @c = { kind = compiler::ValueKind::INT, tpe = tpe.tpe, i = constant } !compiler::Value
                    scope::create_variable(scpe, iddecl.value.id_decl_enum.ident, 
                        share, parser::VarDecl::CONST, tpe, c)

                    constant += 1
                }

                (@tpe).scope = scpe

                // Create to_string function
                let parameter_t = vector::make()
                let return_t = vector::make()
                let np = allocate(NamedParameter)
                @np = {
                    name = "enum",
                    value = tpe
                } !NamedParameter
                vector::push(parameter_t, np)
                vector::push(return_t, builtins::string_)

                let ident = parser::make_identifier(["to_string"])
                let ftpe = make_function_type_n(ident, parameter_t, return_t, false)
                scope::create_function(state.scope, ident, parser::ShareMarker::EXPORT, ftpe, false)

                scope::create_type(state.scope, name, share, tpe)
            } else {
                let typedef = parser::copy_node(node)
                typedef.value.type_decl.left = vector::make()
                vector::push(typedef.value.type_decl.left, name)
                typedef.value.type_decl.right = vector::make()
                vector::push(typedef.value.type_decl.right, value)

                tpe = scope::create_type(state.scope, name, share, tpe, true, typedef, copy_state(state))
            }
        } else {
            tpe = scope::create_type(state.scope, name, share, tpe)
        }

        name.tpe = tpe
    }
}

def walk_top_VarDecl(node: *parser::Node, state: *typechecking::State) {
    let share = node.value.var_decl.share
    let kw = node.value.var_decl.kw
    let left = node.value.var_decl.left
    let right = node.value.var_decl.right
    let extern = node.value.var_decl.extern

    if kw == parser::VarDecl::CONST {
        typechecking::walk_VarDecl(node, state)
        let body = vector::make()
        compiler::walk_top_VarDecl(node, body, compiler_state)
        compiler::walk_expression(vector::peek(body) !*parser::Node, compiler_state)
        eval::eval(compiler_state.current_block)
        reset_state()
        return
    }

    for var i in 0..vector::length(left) {
        let n = vector::get(left, i) !*parser::Node
        if n.kind == parser::NodeKind::ID_DECL {
            scope::create_variable_ext(
                state.scope, n.value.id_decl.value, 
                share, kw, typechecking::make_type_raw(typechecking::TypeKind::STUB), 
                extern, null, true, node, copy_state(state)
            )
        } else {
            walk(node, n, state)
        }
    }
    for var i in 0..vector::length(right) {
        walk(node, vector::get(right, i) !*parser::Node, state)
    }
}

def walk_VarDecl(node: *parser::Node, state: *typechecking::State) {
    for var i in 0..vector::length(node.value.var_decl.left) {
        let left = vector::get(node.value.var_decl.left, i) !*parser::Node
        if left.kind != parser::NodeKind::ID_DECL {
            walk(node, left, state)
        }
    }
    for var i in 0..vector::length(node.value.var_decl.right) {
        walk(node, vector::get(node.value.var_decl.right, i) !*parser::Node, state)
    }
}

def walk_UnaryOp(node: *parser::Node, state: *typechecking::State) {
    walk(node, node.value.expr, state)
}

def walk_BinaryOp(node: *parser::Node, state: *typechecking::State) {
    walk(node, node.value.bin_op.left, state)
    walk(node, node.value.bin_op.right, state)
}

def walk_Assign(node: *parser::Node, state: *typechecking::State) {
    for var i in 0..vector::length(node.value.assign.left) {
        walk(node, vector::get(node.value.assign.left, i) !*parser::Node, state)
    }
    for var i in 0..vector::length(node.value.assign.right) {
        walk(node, vector::get(node.value.assign.right, i) !*parser::Node, state)
    }
}

def walk_Return(node: *parser::Node, state: *typechecking::State) {
    for var i in 0..vector::length(node.value.body) {
        walk(node, vector::get(node.value.body, i) !*parser::Node, state)
    }
}

def walk_Call(node: *parser::Node, state: *typechecking::State) {
    walk(node, node.value.func_call.left, state)
    for var i in 0..vector::length(node.value.func_call.args) {
        walk(node, vector::get(node.value.func_call.args, i) !*parser::Node, state)
    }
    for var i in 0..vector::length(node.value.func_call.kwargs) {
        let named_arg = vector::get(node.value.func_call.kwargs, i) !*parser::Node
        walk(node, named_arg.value.named_arg.value, state)
    }
}

def walk_Switch(node: *parser::Node, state: *typechecking::State) {
    walk(node, node.value.switch_.expr, state)
    for var i in 0..vector::length(node.value.switch_.body) {
        walk(node, vector::get(node.value.switch_.body, i) !*parser::Node, state)
    }
}

def walk_Case(node: *parser::Node, state: *typechecking::State) {
    for var i in 0..vector::length(node.value.case_.expr) {
        walk(node, vector::get(node.value.case_.expr, i) !*parser::Node, state)
    }

    state.scope = scope::enter_scope(state.scope)
    node.inner_scope = state.scope
    for var i in 0..vector::length(node.value.case_.body) {
        walk(node, vector::get(node.value.case_.body, i) !*parser::Node, state)
    }
    state.scope = scope::exit_scope(state.scope)
}

def walk_If(node: *parser::Node, state: *typechecking::State) {
    walk(node, node.value.if_.cond, state)
    
    state.scope = scope::enter_scope(state.scope)
    node.inner_scope = state.scope
    for var i in 0..vector::length(node.value.if_.body) {
        walk(node, vector::get(node.value.if_.body, i) !*parser::Node, state)
    }
    state.scope = scope::exit_scope(state.scope)

    for var i in 0..vector::length(node.value.if_.else_if) {
        let else_if = vector::get(node.value.if_.else_if, i) !*parser::Node
        walk(node, else_if.value.else_if.cond, state)
        
        state.scope = scope::enter_scope(state.scope)
        else_if.inner_scope = state.scope
        for var i in 0..vector::length(else_if.value.else_if.body) {
            walk(node, vector::get(else_if.value.else_if.body, i) !*parser::Node, state)
        }
        state.scope = scope::exit_scope(state.scope)
    }
    if node.value.if_.else_ {
        let else_ = node.value.if_.else_
        state.scope = scope::enter_scope(state.scope)
        else_.inner_scope = state.scope
        for var i in 0..vector::length(else_.value.body) {
            walk(node, vector::get(else_.value.body, i) !*parser::Node, state)
        }
        state.scope = scope::exit_scope(state.scope)
    }
}

def walk_For(node: *parser::Node, state: *typechecking::State) {
    walk(node, node.value.for_loop.expr, state)
    state.scope = scope::enter_scope(state.scope)
    node.inner_scope = state.scope
    for var i in 0..vector::length(node.value.for_loop.body) {
        walk(node, vector::get(node.value.for_loop.body, i) !*parser::Node, state)
    }
    state.scope = scope::exit_scope(state.scope)
}

def walk_While(node: *parser::Node, state: *typechecking::State) {
    walk(node, node.value.while_loop.expr, state)
    state.scope = scope::enter_scope(state.scope)
    node.inner_scope = state.scope
    for var i in 0..vector::length(node.value.while_loop.body) {
        walk(node, vector::get(node.value.while_loop.body, i) !*parser::Node, state)
    }
    state.scope = scope::exit_scope(state.scope)
}

def walk_Loop(node: *parser::Node, state: *typechecking::State) {
    state.scope = scope::enter_scope(state.scope)
    node.inner_scope = state.scope
    for var i in 0..vector::length(node.value.body) {
        walk(node, vector::get(node.value.body, i) !*parser::Node, state)
    }
    state.scope = scope::exit_scope(state.scope)
}

def walk_StructLit(node: *parser::Node, state: *typechecking::State) {
    for var i in 0..vector::length(node.value.struct_lit.args) {
        walk(node, vector::get(node.value.struct_lit.args, i) !*parser::Node, state)
    }
    for var i in 0..vector::length(node.value.struct_lit.kwargs) {
        let named_arg = vector::get(node.value.struct_lit.kwargs, i) !*parser::Node
        walk(node, named_arg.value.named_arg.value, state)
    }
}

def walk_top(parent: *parser::Node, node: *parser::Node, state: *typechecking::State) {
    switch node.kind !int {
        case parser::NodeKind::IMPORT:
            walk_Import(node, state)
        case parser::NodeKind::DEF:
            walk_Def(node, state)
        case parser::NodeKind::TYPE_DECL:
            walk_TypeDecl(node, state)
        case parser::NodeKind::VAR_DECL:
            walk_top_VarDecl(node, state)
        case: do_walk(node, state)
    }
}

def walk(parent: *parser::Node, node: *parser::Node, state: *typechecking::State) {
    if not node { return }

    node.parent = parent
    node.scope = state.scope

    if parent.kind == parser::NodeKind::PROGRAM {
        walk_top(parent, node, state)
        return
    }
    do_walk(node, state)
}

def do_walk(node: *parser::Node, state: *typechecking::State) {
    switch node.kind !int {
        case parser::NodeKind::VAR_DECL:
            walk_VarDecl(node, state)
        case parser::NodeKind::ASSIGN:
            walk_Assign(node, state)
        case parser::NodeKind::RETURN:
            walk_Return(node, state)
        case parser::NodeKind::FUNC_CALL:
            walk_Call(node, state)
        case parser::NodeKind::SWITCH:
            walk_Switch(node, state)
        case parser::NodeKind::CASE:
            walk_Case(node, state)
        case parser::NodeKind::IF:
            walk_If(node, state)
        case parser::NodeKind::STATIC_IF:
            walk_StaticIf(node, state)
        case parser::NodeKind::FOR:
            walk_For(node, state)
        case parser::NodeKind::WHILE:
            walk_While(node, state)
        case parser::NodeKind::LOOP:
            walk_Loop(node, state)
        case parser::NodeKind::STRUCT_LIT:
            walk_StructLit(node, state)
        case parser::NodeKind::RANGE, parser::NodeKind::RANGE_INC, parser::NodeKind::MEMBER_ACCESS, parser::NodeKind::CAST, parser::NodeKind::ADD..=parser::NodeKind::OR, parser::NodeKind::BAND..=parser::NodeKind::SHR_EQ:
            walk_BinaryOp(node, state)
        case parser::NodeKind::SIZE_OF, parser::NodeKind::ALIGN_OF, parser::NodeKind::PTR..=parser::NodeKind::NOT:
            walk_UnaryOp(node, state)
    }
}

export def preprocess(module: *toolchain::Module) {
    let node = module.node
    assert(node.kind == parser::NodeKind::PROGRAM)

    let state = {
        filename = module.filename,
        module = module.module,
        scope = module.scope,
        function_stack = vector::make()
    } !typechecking::State

    if state.module != "cstd" and state.module != "std" {
        // import standard library
        let cstd_ident = parser::make_identifier(["cstd"])
        let cstd = toolchain::preprocess_module(cstd_ident)
        scope::insert_module(state.scope, cstd_ident, cstd)
        
        let std_ident = parser::make_identifier(["std"])
        let std = toolchain::preprocess_module(std_ident)
        scope::insert_module(state.scope, std_ident, std)
    }

    for var i in 0..vector::length(node.value.body) {
        walk(node, vector::get(node.value.body, i) !*parser::Node, *state)
    }
}