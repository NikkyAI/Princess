// This scans a file and predeclares every type, function and variable
// TODO This also needs to execute static if statements

import vector
import toolchain
import scope
import parser
import typechecking

def walk_Import(node: *parser::Node, state: *typechecking::State) {
    let imports = (@node).value.body
    for var i in 0..vector::length(imports) {
        let imprt = vector::get(imports, i) !*parser::Node
        var name = (@imprt).value.import_module.name
        var alias = (@imprt).value.import_module.alias
        if not alias {
            alias = name
        }
        let module = toolchain::preprocess_module(name)
        if not module {
            typechecking::errorn(name, "Module ")
            error(parser::identifier_to_str(name), " could not be found\n")
            return
        }
        scope::insert_module(state.scope, alias, module)
    }
}

def walk_Def(node: *parser::Node, state: *typechecking::State) {
    let share = node.value.def_.share
    let name = node.value.def_.name
    let params = node.value.def_.params
    let returns = node.value.def_.returns

    let parameter_t = vector::make()
    let return_t = vector::make()
    for var i in 0..vector::length(params) {
        let param = vector::get(params, i) !*parser::Node
        assert((@param).kind == parser::NodeKind::PARAMETER)
        
        let named = allocate(typechecking::NamedParameter)
        let name = (@param).value.param.name
        let tpe = typechecking::type_lookup_default((@param).value.param.tpe, state)
        (@named).name = last_ident_to_str(name)
        (@named).value = tpe
        (@named).varargs = (@param).value.param.varargs
        (@named).node = name
        vector::push(parameter_t, named)
    }
    for var i in 0..vector::length(returns) {
        vector::push(return_t, type_lookup_default(vector::get(returns, i) !*parser::Node, state))
    }

    let tpe = typechecking::make_function_type_n(name, parameter_t, return_t, true)

    scope::create_function(state.scope, name, share, tpe, true)
}

def walk(parent: *parser::Node, node: *parser::Node, state: *typechecking::State) {
    node.parent = parent
    node.scope = state.scope
    switch node.kind !int {
        case parser::NodeKind::IMPORT:
            walk_Import(node, state)
        case parser::NodeKind::DEF:
            walk_Def(node, state)
    }
}

export def preprocess(module: *toolchain::Module) {
    let node = module.node
    assert(node.kind == parser::NodeKind::PROGRAM)
    let state = {
        scope = module.scope,
        module = module.module
    } !typechecking::State

    if state.module != "cstd" and state.module != "std" {
        // import standard library
        let cstd_ident = parser::make_identifier(["cstd"])
        let cstd = toolchain::preprocess_module(cstd_ident)
        scope::insert_module(state.scope, cstd_ident, cstd)
        
        let std_ident = parser::make_identifier(["std"])
        let std = toolchain::preprocess_module(std_ident)
        scope::insert_module(state.scope, std_ident, std)
    }

    for var i in 0..vector::length(node.value.body) {
        walk(node, vector::get(node.value.body, i) !*parser::Node, *state)
    }
}