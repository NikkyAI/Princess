// This scans a file and predeclares every type, function and variable
// TODO This also needs to execute static if statements

import vector
import toolchain
import scope
import parser
import typechecking

// If we store the state we need to create a permanent copy
def copy_state(state: *typechecking::State) -> *typechecking::State {
    let new_state = allocate(typechecking::State)
    @new_state = @state
    new_state.function_stack = vector::copy(state.function_stack)
    return new_state
}

def walk_Import(node: *parser::Node, state: *typechecking::State) {
    let imports = (@node).value.body
    for var i in 0..vector::length(imports) {
        let imprt = vector::get(imports, i) !*parser::Node
        var name = (@imprt).value.import_module.name
        var alias = (@imprt).value.import_module.alias
        if not alias {
            alias = name
        }
        let module = toolchain::preprocess_module(name)
        if not module {
            typechecking::errorn(name, "Module ")
            error(parser::identifier_to_str(name), " could not be found\n")
            return
        }
        scope::insert_module(state.scope, alias, module)
    }
}

def walk_Def(node: *parser::Node, state: *typechecking::State) {
    let share = node.value.def_.share
    let name = node.value.def_.name
    let params = node.value.def_.params
    let returns = node.value.def_.returns
    let body = node.value.def_.body
    let extern = node.value.def_.extern

    let parameter_t = vector::make()
    let return_t = vector::make()
    for var i in 0..vector::length(params) {
        let param = vector::get(params, i) !*parser::Node
        assert(param.kind == parser::NodeKind::PARAMETER)
        
        let named = allocate(typechecking::NamedParameter)
        let name = param.value.param.name
        let tpe = typechecking::type_lookup(param.value.param.tpe, state, true)
        named.name = last_ident_to_str(name)
        named.value = tpe
        named.varargs = (@param).value.param.varargs
        named.node = name
        vector::push(parameter_t, named)
    }
    for var i in 0..vector::length(returns) {
        let n = vector::get(returns, i) !*parser::Node
        let tpe = typechecking::type_lookup(n, state, true)
        vector::push(return_t, tpe)
    }

    let tpe = typechecking::make_function_type_n(name, parameter_t, return_t, extern)
    if body {
        scope::create_function(state.scope, name, share, tpe, true, node, copy_state(state))
    } else {
        scope::create_function(state.scope, name, share, tpe, true)
    }
    node.tpe = tpe
}

def walk_TypeDecl(node: *parser::Node, state: *typechecking::State) {
    let share = node.value.type_decl.share
    let left = node.value.type_decl.left
    let right = node.value.type_decl.right

    for var i in 0..vector::length(left) {
        let name = vector::get(left, i) !*parser::Node

        var value: *parser::Node = null
        if i < vector::length(right) {
            value = vector::get(right, i) !*parser::Node
        }
        var tpe = typechecking::make_type(typechecking::TypeKind::STUB, name)

        if vector::length(name.value.body) > 1 {
            if value {
                typechecking::errorn(name, "Can't create type in sub scope\n")
                continue
            }
            let scpe = toolchain::get_forward_declared_scope(name)
            let last = vector::peek((@name).value.body) !*string
            let n = parser::copy_node(name)
            (@n).value.body = vector::make()
            vector::push((@n).value.body, last)
            tpe = scope::create_type(scpe, n, share, tpe)
        }

        if value {
            let typedef = parser::copy_node(node)
            typedef.value.type_decl.left = vector::make()
            vector::push(typedef.value.type_decl.left, name)
            typedef.value.type_decl.right = vector::make()
            vector::push(typedef.value.type_decl.right, value)

            scope::create_type(state.scope, name, share, tpe, true, typedef, copy_state(state))
        } else {
            scope::create_type(state.scope, name, share, tpe)
        }
        
    }
}

def walk_VarDecl(node: *parser::Node, state: *typechecking::State) {
    let share = node.value.var_decl.share
    let kw = node.value.var_decl.kw
    let left = node.value.var_decl.left
    let right = node.value.var_decl.right
    let extern = node.value.var_decl.extern

    for var i in 0..vector::length(left) {
        let n = vector::get(left, i) !*parser::Node
        if n.kind == parser::NodeKind::ID_DECL {
            scope::create_variable_ext(
                state.scope, n.value.id_decl.value, 
                share, kw, null, extern, null, true, node, copy_state(state)
            )
        }
    }
}

def walk(parent: *parser::Node, node: *parser::Node, state: *typechecking::State) {
    node.parent = parent
    node.scope = state.scope
    switch node.kind !int {
        case parser::NodeKind::IMPORT:
            walk_Import(node, state)
        case parser::NodeKind::DEF:
            walk_Def(node, state)
        case parser::NodeKind::TYPE_DECL:
            walk_TypeDecl(node, state)
        case parser::NodeKind::VAR_DECL:
            walk_VarDecl(node, state)
    }
}

export def preprocess(module: *toolchain::Module) {
    let node = module.node
    assert(node.kind == parser::NodeKind::PROGRAM)

    let state = {
        filename = module.filename,
        module = module.module,
        scope = module.scope,
        function_stack = vector::make()
    } !typechecking::State

    if state.module != "cstd" and state.module != "std" {
        // import standard library
        let cstd_ident = parser::make_identifier(["cstd"])
        let cstd = toolchain::preprocess_module(cstd_ident)
        scope::insert_module(state.scope, cstd_ident, cstd)
        
        let std_ident = parser::make_identifier(["std"])
        let std = toolchain::preprocess_module(std_ident)
        scope::insert_module(state.scope, std_ident, std)
    }

    for var i in 0..vector::length(node.value.body) {
        walk(node, vector::get(node.value.body, i) !*parser::Node, *state)
    }
}