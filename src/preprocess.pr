// This scans a file and predeclares every type, function and variable
// TODO This also needs to execute static if statements

import vector
import map
import toolchain
import scope
import parser
import typechecking
import compiler
import builtins
import util
import debug

export let const_module = zero_allocate(toolchain::Module)
@const_module = {
    module = "const",
    result = compiler::make_result(),
    imported = map::make()
} !toolchain::Module

// This is for compiling expressions
export let compiler_state = compiler::make_state(const_module)
const_module.result = compiler_state.result

import eval

export def make_value(value: compiler::Value) -> *scope::Value {
    let svalue = zero_allocate(scope::Value)
    let valuep = allocate(compiler::Value)
    @valuep = value
    svalue.value = valuep
    svalue.tpe = value.tpe
    return svalue
}

// If we store the state we need to create a permanent copy
def copy_state(state: *typechecking::State) -> *typechecking::State {
    let new_state = allocate(typechecking::State)
    @new_state = @state
    new_state.function_stack = vector::copy(state.function_stack)
    return new_state
}

def set_current_function {
    let block = compiler::make_block()
    let function = allocate(compiler::Function)
    @function = {
        name = "main",
        unmangled = "main",
        forward_declare = true,
        allocas = vector::make(),
        block = block
    } !compiler::Function
    compiler_state.current_function = function
    compiler_state.current_block = block
}

export def expr(node: *parser::Node, state: *typechecking::State) -> compiler::Value {
    if not node { return compiler::NO_VALUE }
    set_current_function()
    typechecking::walk(node.parent, node, state)
    var result = compiler::walk_expression(node, compiler_state)
    let estate = eval::eval(compiler_state)
    if not estate { return compiler::NO_VALUE }
    result = eval::get_value(result, estate)
    return result
}

export def boolean_expr(node: *parser::Node, state: *typechecking::State) -> compiler::Value {
    if not node { return compiler::NO_VALUE }
    set_current_function()
    typechecking::walk(node.parent, node, state)
    var result = compiler::walk_expression(node, compiler_state)
    result = compiler::convert_to(node, result, builtins::bool_, compiler_state)
    let estate = eval::eval(compiler_state)
    if not estate { return compiler::NO_VALUE }
    result = eval::get_value(result, estate)
    return result
}

def walk_IfExpr(node: *parser::Node, state: *typechecking::State) {
    walk(node, node.value.if_expr.if_true, state)
    walk(node, node.value.if_expr.cond, state)
    walk(node, node.value.if_expr.if_false, state)
}

def walk_StaticIf(node: *parser::Node, state: *typechecking::State) {
    let is_static = state.is_static
    state.is_static = true
    walk(node, node.value.if_.cond, state)
    state.is_static = is_static
    var result = boolean_expr(node.value.if_.cond, state)

    var body: *vector::Vector = null
    if result.i {
        body = node.value.if_.body
    } else {
        for var i in 0..vector::length(node.value.if_.else_if) {
            let else_if = vector::get(node.value.if_.else_if, i) !*parser::Node
            let is_static = state.is_static
            state.is_static = true
            walk(else_if, else_if.value.else_if.cond, state)
            state.is_static = is_static
            result = boolean_expr(else_if.value.else_if.cond, state)
            if result.i { 
                body = else_if.value.else_if.body
                break
            }
        }
        let else_ = node.value.if_.else_
        if not result.i and else_ {
            body = else_.value.body
        }
    }
    
    let index = vector::index_of(node.parent.body, node)
    vector::remove(node.parent.body, index)
    if body {
        vector::insert(node.parent.body, index, body)
        for var i in 0..vector::length(body) {
            walk(node.parent, vector::get(body, i) !*parser::Node, state)
        }
    }
}

def walk_Import(node: *parser::Node, state: *typechecking::State) {
    let imports = (@node).value.body
    for var i in 0..vector::length(imports) {
        let imprt = vector::get(imports, i) !*parser::Node
        var name = (@imprt).value.import_module.name
        var alias = (@imprt).value.import_module.alias
        if not alias {
            alias = name
        }
        let module = toolchain::preprocess_module(name)
        if not module {
            typechecking::errorn(name, "Module ")
            error(parser::identifier_to_str(name), " could not be found\n")
            return
        }
        scope::insert_module(state.scope, alias, module)
    }
}

def walk_Def(node: *parser::Node, state: *typechecking::State) {
    let share = node.value.def_.share
    let name = node.value.def_.name
    let params = node.value.def_.params
    let returns = node.value.def_.returns
    let body = node.value.def_.body
    let imported = (share !int & parser::ShareMarker::IMPORT !int) !bool

    if share !int & parser::ShareMarker::IMPORT !int {
        node.value.def_.is_used = true
    }

    let parameter_t = vector::make()
    let return_t = vector::make()
    for var i in 0..vector::length(params) {
        let param = vector::get(params, i) !*parser::Node
        assert(param.kind == parser::NodeKind::PARAMETER)
        
        let named = allocate(typechecking::NamedParameter)
        let name = param.value.param.name
        var value: *compiler::Value = null
        if param.value.param.value {
            set_current_function()
            typechecking::walk(node, param.value.param.value, state)
            var result = compiler::walk_expression(param.value.param.value, compiler_state)
            let gvalue = compiler::make_global_value(result.tpe, "default_param", null, compiler_state)
            let estate = eval::eval(compiler_state)
            result = eval::get_value(result, estate)
            eval::set_value(gvalue, result, estate)
            let global = eval::serialize_value(gvalue.name, state.module, compiler_state)
            map::put(state.module.result.globals, gvalue.name, global)

            let gvaluep = allocate(compiler::Value)
            @gvaluep = gvalue
            value = gvaluep
        }
        let tpe = typechecking::type_lookup(param.value.param.tpe, state, true)
        named.name = last_ident_to_str(name)
        named.tpe = tpe
        named.varargs = (@param).value.param.varargs
        named.node = name
        named.value = value
        vector::push(parameter_t, named)
    }
    for var i in 0..vector::length(returns) {
        let n = vector::get(returns, i) !*parser::Node
        let tpe = typechecking::type_lookup(n, state, true)
        vector::push(return_t, tpe)
    }

    let tpe = typechecking::make_function_type_n(name, parameter_t, return_t, true, imported)
    if body {
        scope::create_function(state.scope, name, share, tpe, scope::Phase::DEFINED, node, copy_state(state))
    } else {
        scope::create_function(state.scope, name, share, tpe, scope::Phase::DECLARED, null, null)
    }

    if body {
        let function = allocate(typechecking::Function)
        @function = {
            tpe = tpe,
            locals = map::make(),
            has_defer = false
        }
        typechecking::push_function(state, function)

        state.scope = scope::enter_function_scope(state.scope)
        node.inner_scope = state.scope
        for var i in 0..vector::length(body) {
            walk(node, vector::get(body, i) !*parser::Node, state)
        }
        state.scope = scope::exit_scope(state.scope)

        node.value.def_.locals = function.locals
        node.value.def_.has_defer = function.has_defer
        typechecking::pop_function(state)
    }

    node.tpe = tpe
}

def walk_TypeDecl(node: *parser::Node, state: *typechecking::State) {
    let share = node.value.type_decl.share
    let left = node.value.type_decl.left
    let right = node.value.type_decl.right

    for var i in 0..vector::length(left) {
        let name = vector::get(left, i) !*parser::Node

        var value: *parser::Node = null
        if i < vector::length(right) {
            value = vector::get(right, i) !*parser::Node
        }
        var tpe = typechecking::make_type(typechecking::TypeKind::STUB, name)

        if vector::length(name.value.body) > 1 {
            if value {
                typechecking::errorn(name, "Can't create type in sub scope\n")
                continue
            }
            let scpe = toolchain::get_forward_declared_scope(name)
            let last = vector::peek((@name).value.body) !*string
            let n = parser::copy_node(name)
            (@n).value.body = vector::make()
            vector::push((@n).value.body, last)
            tpe = scope::create_type(scpe, n, share, tpe)
        }

        if value {
            if value.kind == parser::NodeKind::ENUM_T {
                tpe = typechecking::copy(typechecking::type_lookup(value, state))
                tpe.name = parser::identifier_to_str(name)
                tpe.type_name = typechecking::append_module(tpe.name, value.loc.module)

                var constant: int64 = 0
                // Create all the constants
                state.scope = scope::enter_scope(state.scope)
                for var i in 0..vector::length(value.value.t_enum.body) {
                    let iddecl = vector::get(value.value.t_enum.body, i) !*parser::Node
                    if iddecl.value.id_decl_enum.value {
                        constant = expr(iddecl.value.id_decl_enum.value, state).i
                    }

                    let c = allocate(compiler::Value)
                    @c = { kind = compiler::ValueKind::INT, tpe = tpe.tpe, i = constant } !compiler::Value
                    scope::create_variable(state.scope, iddecl.value.id_decl_enum.ident, 
                        share, parser::VarDecl::CONST, tpe, c)

                    constant += 1
                }

                (@tpe).scope = state.scope
                state.scope = scope::exit_scope(state.scope)

                // Create to_string function
                let parameter_t = vector::make()
                let return_t = vector::make()
                let np = allocate(NamedParameter)
                @np = {
                    name = "enum",
                    tpe = tpe
                } !NamedParameter
                vector::push(parameter_t, np)
                vector::push(return_t, builtins::string_)

                let ident = parser::make_identifier(["to_string"])
                let ftpe = typechecking::make_function_type_n(ident, parameter_t, return_t, false, false)
                scope::create_function(state.scope, ident, parser::ShareMarker::EXPORT, ftpe)

                scope::create_type(state.scope, name, share, tpe)
            } else {
                let typedef = parser::copy_node(node)
                typedef.value.type_decl.left = vector::make()
                vector::push(typedef.value.type_decl.left, name)
                typedef.value.type_decl.right = vector::make()
                vector::push(typedef.value.type_decl.right, value)

                tpe = scope::create_type(state.scope, name, share, tpe, scope::Phase::DEFINED, typedef, copy_state(state))
            }
        } else {
            tpe = scope::create_type(state.scope, name, share, tpe, scope::Phase::DECLARED, null, null)
        }

        name.tpe = tpe
    }
}

def walk_top_VarDecl(node: *parser::Node, state: *typechecking::State) {
    let share = node.value.var_decl.share
    let kw = node.value.var_decl.kw
    let left = node.value.var_decl.left
    let right = node.value.var_decl.right
    let extern = node.value.var_decl.extern

    if kw == parser::VarDecl::CONST {
        for var i in 0..vector::length(right) {
            let is_static = state.is_static
            state.is_static = true
            walk(node, vector::get(right, i) !*parser::Node, state)
            state.is_static = is_static
        }

        set_current_function()
        typechecking::walk_VarDecl(node, state, true)
        let assign = compiler::walk_top_VarDecl(node, compiler_state, true)
        compiler::walk_expression(assign, compiler_state)
        eval::eval(compiler_state)

        for var i in 0..vector::length(left) {
            let n = vector::get(left, i) !*parser::Node
            if n.kind != parser::NodeKind::ID_DECL {
                typechecking::errorn(n, "Can't assign in const statement\n")
                return
            }
            let ident = n.value.id_decl.value
            let global = eval::serialize_value(ident.svalue.assembly_name, state.module, compiler_state)
            if global {
                ident.svalue.value = global.value
            }
        }

        return
    }

    for var i in 0..vector::length(left) {
        let n = vector::get(left, i) !*parser::Node
        if n.kind == parser::NodeKind::ID_DECL {
            scope::create_variable(
                state.scope, n.value.id_decl.value, 
                share, kw, typechecking::make_type_raw(typechecking::TypeKind::STUB), 
                extern, null, scope::Phase::DEFINED, node, copy_state(state)
            )
        } else {
            walk(node, n, state)
        }
    }
    for var i in 0..vector::length(right) {
        walk(node, vector::get(right, i) !*parser::Node, state)
    }
}

def walk_VarDecl(node: *parser::Node, state: *typechecking::State) {
    let kw = node.value.var_decl.kw
    let left = node.value.var_decl.left
    let right = node.value.var_decl.right

    if kw == parser::VarDecl::CONST and not state.is_compiling_function {
        for var i in 0..vector::length(right) {
            let is_static = state.is_static
            state.is_static = true
            walk(node, vector::get(right, i) !*parser::Node, state)
            state.is_static = is_static
        }

        set_current_function()
        typechecking::walk_VarDecl(node, state, true)
        compiler::walk_VarDecl(node, compiler_state, true)
        let estate = eval::eval(compiler_state)
        if not estate { return }
        let locals = eval::get_stack_frame(estate).locals

        for var i in 0..vector::length(left) {
            let n = vector::get(left, i) !*parser::Node
            if n.kind != parser::NodeKind::ID_DECL {
                typechecking::errorn(n, "Can't assign in const statement\n")
                return
            }
            let name = n.value.id_decl.value
            let value = scope::get(state.scope, name)
            // TODO We need to serialize these ones as well, move them out of the function
            let mem = map::get(locals, value.assembly_name) !*
            let ptr = eval::get(mem, typechecking::pointer(value.tpe))
            let constant = eval::get(ptr.i !*, value.tpe)

            let constantp = allocate(compiler::Value)
            @constantp = constant
            value.value = constantp
        }

        return
    }

    for var i in 0..vector::length(left) {
        let left = vector::get(left, i) !*parser::Node
        if left.kind != parser::NodeKind::ID_DECL {
            walk(node, left, state)
        }
    }
    for var i in 0..vector::length(right) {
        walk(node, vector::get(right, i) !*parser::Node, state)
    }
}

def walk_UnaryOp(node: *parser::Node, state: *typechecking::State) {
    walk(node, node.value.expr, state)
}

def walk_BinaryOp(node: *parser::Node, state: *typechecking::State) {
    walk(node, node.value.bin_op.left, state)
    walk(node, node.value.bin_op.right, state)
}

def walk_Assign(node: *parser::Node, state: *typechecking::State) {
    for var i in 0..vector::length(node.value.assign.left) {
        walk(node, vector::get(node.value.assign.left, i) !*parser::Node, state)
    }
    for var i in 0..vector::length(node.value.assign.right) {
        walk(node, vector::get(node.value.assign.right, i) !*parser::Node, state)
    }
}

def walk_Return(node: *parser::Node, state: *typechecking::State) {
    for var i in 0..vector::length(node.value.body) {
        walk(node, vector::get(node.value.body, i) !*parser::Node, state)
    }
}

def compile_function(func: *parser::Node, state: *typechecking::State) {
    if func and not map::contains(compiler_state.result.functions, func.tpe.type_name) {        
        let is_compiling_function = state.is_compiling_function
        state.is_compiling_function = true
        for var i in 0..vector::length(func.value.def_.body) {
            walk(func, vector::get(func.value.def_.body, i) !*parser::Node, state)
        }
        state.is_compiling_function = is_compiling_function

        compiler::predeclare_function(func.tpe, compiler_state)
        compiler::create_function(func, func.tpe, func.value.def_.body, func.inner_scope, null, compiler_state)
    }
}

def walk_Call(node: *parser::Node, state: *typechecking::State) {
    let left = node.value.func_call.left
    walk(node, left, state)
    if state.is_static {
        typechecking::walk(node.parent, node, state)
        let func = left.svalue.node
        compile_function(func, state)
    }
    for var i in 0..vector::length(node.value.func_call.args) {
        walk(node, vector::get(node.value.func_call.args, i) !*parser::Node, state)
    }
    for var i in 0..vector::length(node.value.func_call.kwargs) {
        let named_arg = vector::get(node.value.func_call.kwargs, i) !*parser::Node
        walk(node, named_arg.value.named_arg.value, state)
    }
}

def walk_Ptr(node: *parser::Node, state: *typechecking::State) {
    walk(node, node.value.expr, state)
    if state.is_static {
        typechecking::walk(node.parent, node, state)
        let func = node.value.expr.svalue.node
        compile_function(func, state)
    }
}

def walk_Switch(node: *parser::Node, state: *typechecking::State) {
    walk(node, node.value.switch_.expr, state)
    for var i in 0..vector::length(node.value.switch_.body) {
        walk(node, vector::get(node.value.switch_.body, i) !*parser::Node, state)
    }
}

def walk_Case(node: *parser::Node, state: *typechecking::State) {
    for var i in 0..vector::length(node.value.case_.expr) {
        walk(node, vector::get(node.value.case_.expr, i) !*parser::Node, state)
    }

    state.scope = scope::enter_scope(state.scope)
    node.inner_scope = state.scope
    let body = vector::copy(node.value.case_.body)
    for var i in 0..vector::length(body) {
        walk(node, vector::get(body, i) !*parser::Node, state)
    }
    state.scope = scope::exit_scope(state.scope)
}

def walk_Defer(node: *parser::Node, state: *typechecking::State) {
    state.scope = scope::enter_scope(state.scope)
    node.inner_scope = state.scope
    let body = vector::copy(node.value.body)
    for var i in 0..vector::length(body) {
        walk(node, vector::get(body, i) !*parser::Node, state)
    }
    state.scope = scope::exit_scope(state.scope)   
}

def walk_If(node: *parser::Node, state: *typechecking::State) {
    walk(node, node.value.if_.cond, state)
    
    state.scope = scope::enter_scope(state.scope)
    node.inner_scope = state.scope
    let body = vector::copy(node.value.if_.body)
    for var i in 0..vector::length(body) {
        walk(node, vector::get(body, i) !*parser::Node, state)
    }
    state.scope = scope::exit_scope(state.scope)

    for var i in 0..vector::length(node.value.if_.else_if) {
        let else_if = vector::get(node.value.if_.else_if, i) !*parser::Node
        walk(node, else_if.value.else_if.cond, state)
        
        state.scope = scope::enter_scope(state.scope)
        else_if.inner_scope = state.scope
        let body = vector::copy(else_if.value.else_if.body)
        for var i in 0..vector::length(body) {
            walk(node, vector::get(body, i) !*parser::Node, state)
        }
        state.scope = scope::exit_scope(state.scope)
    }
    if node.value.if_.else_ {
        let else_ = node.value.if_.else_
        state.scope = scope::enter_scope(state.scope)
        else_.inner_scope = state.scope
        let body = vector::copy(else_.value.body)
        for var i in 0..vector::length(body) {
            walk(node, vector::get(body, i) !*parser::Node, state)
        }
        state.scope = scope::exit_scope(state.scope)
    }
}

def walk_For(node: *parser::Node, state: *typechecking::State) {
    walk(node, node.value.for_loop.expr, state)
    state.scope = scope::enter_scope(state.scope)
    node.inner_scope = state.scope
    let body = vector::copy(node.value.for_loop.body)
    for var i in 0..vector::length(body) {
        walk(node, vector::get(body, i) !*parser::Node, state)
    }
    state.scope = scope::exit_scope(state.scope)
}

def walk_While(node: *parser::Node, state: *typechecking::State) {
    walk(node, node.value.while_loop.expr, state)
    state.scope = scope::enter_scope(state.scope)
    node.inner_scope = state.scope
    let body = vector::copy(node.value.while_loop.body)
    for var i in 0..vector::length(body) {
        walk(node, vector::get(body, i) !*parser::Node, state)
    }
    state.scope = scope::exit_scope(state.scope)
}

def walk_Loop(node: *parser::Node, state: *typechecking::State) {
    state.scope = scope::enter_scope(state.scope)
    node.inner_scope = state.scope
    let body = vector::copy(node.value.body)
    for var i in 0..vector::length(body) {
        walk(node, vector::get(body, i) !*parser::Node, state)
    }
    state.scope = scope::exit_scope(state.scope)
}

def walk_StructLit(node: *parser::Node, state: *typechecking::State) {
    for var i in 0..vector::length(node.value.struct_lit.args) {
        walk(node, vector::get(node.value.struct_lit.args, i) !*parser::Node, state)
    }
    for var i in 0..vector::length(node.value.struct_lit.kwargs) {
        let named_arg = vector::get(node.value.struct_lit.kwargs, i) !*parser::Node
        walk(node, named_arg.value.named_arg.value, state)
    }
}

def walk_Defined(node: *parser::Node, state: *typechecking::State) {
    let expr = node.value.expr

    let boolean_node = {
        kind = parser::NodeKind::BOOLEAN,
        parent = node.parent,
        loc = node.loc
    } !parser::Node

    if expr {
        let ident = scope::get(state.scope, expr)
        boolean_node.value.i = (not not ident) !int64
    }

    @node = boolean_node
}

def walk_Error(node: *parser::Node, state: *typechecking::State) {
    let expr = node.value.expr
    let is_static = state.is_static
    state.is_static = true
    walk(node, expr, state)
    state.is_static = is_static

    set_current_function()
    typechecking::walk(node, expr, state)
    var result = compiler::walk_expression(expr, compiler_state)
    let estate = eval::eval(compiler_state)
    if estate { 
        result = eval::get_value(result, estate)
        if not typechecking::equals(result.tpe, builtins::string_) {
            typechecking::errorn(node, "Error pragma expects string, got ")
            error(debug::type_to_str(result.tpe), "\n")
        } else {
            var ptr: *char = null
            if result.kind == compiler::ValueKind::ADDRESS {
                let mem = eval::get_address(@result.addr, estate)
                let val = eval::get(eval::get(mem, typechecking::pointer(result.tpe)).i !*, result.tpe)
                ptr = val.values[1].i !*char
            } else {
                ptr = result.values[1].i !*char
            } 
            typechecking::errorn(node, make_string(ptr))
        }
    }

    @node = {
        kind = parser::NodeKind::NULL,
        parent = node.parent,
        loc = node.loc
    } !parser::Node
}

def walk_top(parent: *parser::Node, node: *parser::Node, state: *typechecking::State) {
    switch node.kind !int {
        case parser::NodeKind::IMPORT:
            walk_Import(node, state)
        case parser::NodeKind::DEF:
            walk_Def(node, state)
        case parser::NodeKind::TYPE_DECL:
            walk_TypeDecl(node, state)
        case parser::NodeKind::VAR_DECL:
            walk_top_VarDecl(node, state)
        case: do_walk(node, state)
    }
}

def walk(parent: *parser::Node, node: *parser::Node, state: *typechecking::State) {
    if not node { return }

    node.parent = parent

    if not node.scope {
        node.scope = state.scope
    }

    if parent.kind == parser::NodeKind::PROGRAM {
        walk_top(parent, node, state)
        return
    }
    do_walk(node, state)
}

def do_walk(node: *parser::Node, state: *typechecking::State) {
    switch node.kind !int {
        case parser::NodeKind::VAR_DECL:
            walk_VarDecl(node, state)
        case parser::NodeKind::ASSIGN:
            walk_Assign(node, state)
        case parser::NodeKind::RETURN:
            walk_Return(node, state)
        case parser::NodeKind::FUNC_CALL:
            walk_Call(node, state)
        case parser::NodeKind::SWITCH:
            walk_Switch(node, state)
        case parser::NodeKind::CASE:
            walk_Case(node, state)
        case parser::NodeKind::IF:
            walk_If(node, state)
        case parser::NodeKind::STATIC_IF:
            walk_StaticIf(node, state)
        case parser::NodeKind::IF_EXPR:
            walk_IfExpr(node, state)
        case parser::NodeKind::FOR:
            walk_For(node, state)
        case parser::NodeKind::WHILE:
            walk_While(node, state)
        case parser::NodeKind::LOOP:
            walk_Loop(node, state)
        case parser::NodeKind::STRUCT_LIT:
            walk_StructLit(node, state)
        case parser::NodeKind::RANGE, parser::NodeKind::RANGE_INC, parser::NodeKind::MEMBER_ACCESS, parser::NodeKind::CAST, parser::NodeKind::ADD..=parser::NodeKind::OR, parser::NodeKind::BAND..=parser::NodeKind::SHR_EQ:
            walk_BinaryOp(node, state)
        case parser::NodeKind::PTR:
            walk_Ptr(node, state)
        case parser::NodeKind::SIZE_OF, parser::NodeKind::ALIGN_OF, parser::NodeKind::DEREF..=parser::NodeKind::NOT:
            walk_UnaryOp(node, state)
        case parser::NodeKind::IDENTIFIER:
            // walk_Identifier(node, state)
        case parser::NodeKind::DEFINED:
            walk_Defined(node, state)
        case parser::NodeKind::ERROR:
            walk_Error(node, state)
        case parser::NodeKind::DEFER:
            walk_Defer(node, state)
    }
}

export var time_spent: int64 = 0

export def preprocess(module: *toolchain::Module) {
    let start = util::millis()
    let node = module.node
    assert(node.kind == parser::NodeKind::PROGRAM)

    let state = {
        module = module,
        scope = module.scope,
        function_stack = vector::make()
    } !typechecking::State

    if state.module.module != "cstd" and state.module.module != "std" {
        // import standard library
        let cstd_ident = parser::make_identifier(["cstd"])
        let cstd = toolchain::preprocess_module(cstd_ident)
        scope::insert_module(state.scope, cstd_ident, cstd)
        
        let std_ident = parser::make_identifier(["std"])
        let std = toolchain::preprocess_module(std_ident)
        scope::insert_module(state.scope, std_ident, std)
    }

    let body = vector::copy(node.value.body)
    for var i in 0..vector::length(body) {
        walk(node, vector::get(body, i) !*parser::Node, *state)
    }

    compiler::predeclare_functions(module.scope, compiler_state)
    let end = util::millis()
    time_spent += end - start
}