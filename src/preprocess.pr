// This scans a file and predeclares every type, function and variable
// TODO This also needs to execute static if statements

import vector
import toolchain
import scope
import parser
import typechecking

def walk_Import(node: *parser::Node, state: *typechecking::State) {
    let imports = (@node).value.body
    for var i in 0..vector::length(imports) {
        let imprt = vector::get(imports, i) !*parser::Node
        var name = (@imprt).value.import_module.name
        var alias = (@imprt).value.import_module.alias
        if not alias {
            alias = name
        }
        let module = toolchain::preprocess_module(name)
        if not module {
            typechecking::errorn(name, "Module ")
            error(parser::identifier_to_str(name), " could not be found\n")
            return
        }
        scope::insert_module(state.scope, alias, module)
    }
}

def get_identifier_node(node: *parser::Node) -> *parser::Node {
    if not node { return null }
    switch node.kind !int {
        case parser::NodeKind::PTR_T..=parser::NodeKind::ARRAY_T:
            return get_identifier_node(node.value.t_parr.tpe)
        case parser::NodeKind::ARRAY_STATIC_T:
            return get_identifier_node(node.value.t_arrs.tpe)
        case parser::NodeKind::IDENTIFIER:
            return node
        case: return null
    }
}

def walk_Def(node: *parser::Node, state: *typechecking::State) {
    let share = node.value.def_.share
    let name = node.value.def_.name
    let params = node.value.def_.params
    let returns = node.value.def_.returns

    let parameter_t = vector::make()
    let return_t = vector::make()
    for var i in 0..vector::length(params) {
        let param = vector::get(params, i) !*parser::Node
        assert(param.kind == parser::NodeKind::PARAMETER)
        
        let named = allocate(typechecking::NamedParameter)
        let name = param.value.param.name
        let tpe = typechecking::type_lookup(param.value.param.tpe, state, true)
        named.name = last_ident_to_str(name)
        named.value = tpe
        named.varargs = (@param).value.param.varargs
        named.node = name
        vector::push(parameter_t, named)

        let ident = get_identifier_node(param.value.param.tpe)
        if ident and not scope::get(state.scope, ident) {
            scope::create_type(state.scope, ident, parser::ShareMarker::NONE, tpe)
        }
    }
    for var i in 0..vector::length(returns) {
        let n = vector::get(returns, i) !*parser::Node
        let tpe = typechecking::type_lookup(n, state, true)
        vector::push(return_t, tpe)

        let ident = get_identifier_node(n)
        if ident and not scope::get(state.scope, ident) {
            scope::create_type(state.scope, n, parser::ShareMarker::NONE, tpe)
        }
    }

    let tpe = typechecking::make_function_type_n(name, parameter_t, return_t, true)
    scope::create_function(state.scope, name, share, tpe, true, node, state)
}

def walk_TypeDecl(node: *parser::Node, state: *typechecking::State) {
    let share = node.value.type_decl.share
    let left = node.value.type_decl.left
    let right = node.value.type_decl.right

    for var i in 0..vector::length(left) {
        let name = vector::get(left, i) !*parser::Node
        let tpe = typechecking::make_type(typechecking::TypeKind::STUB, name)
        scope::create_type(state.scope, name, share, tpe, true, node, state)
    }
}

def walk_VarDecl(node: *parser::Node, state: *typechecking::State) {
    let share = node.value.var_decl.share
    let kw = node.value.var_decl.kw
    let left = node.value.var_decl.left
    let right = node.value.var_decl.right
    let extern = node.value.var_decl.extern

    for var i in 0..vector::length(left) {
        let n = vector::get(left, i) !*parser::Node
        if n.kind == parser::NodeKind::ID_DECL {
            scope::create_variable_ext(
                state.scope, n.value.id_decl.value, 
                share, kw, null, extern, null, true, node, state
            )
        }
    }
}

def walk(parent: *parser::Node, node: *parser::Node, state: *typechecking::State) {
    node.parent = parent
    node.scope = state.scope
    switch node.kind !int {
        case parser::NodeKind::IMPORT:
            walk_Import(node, state)
        case parser::NodeKind::DEF:
            walk_Def(node, state)
        case parser::NodeKind::TYPE_DECL:
            walk_TypeDecl(node, state)
        case parser::NodeKind::VAR_DECL:
            walk_VarDecl(node, state)
    }
}

export def preprocess(module: *toolchain::Module) {
    let node = module.node
    assert(node.kind == parser::NodeKind::PROGRAM)

    let state = allocate(typechecking::State)
    @state = {
        filename = module.filename,
        module = module.module,
        scope = module.scope,
        function_stack = vector::make()
    } !typechecking::State

    if state.module != "cstd" and state.module != "std" {
        // import standard library
        let cstd_ident = parser::make_identifier(["cstd"])
        let cstd = toolchain::preprocess_module(cstd_ident)
        scope::insert_module(state.scope, cstd_ident, cstd)
        
        let std_ident = parser::make_identifier(["std"])
        let std = toolchain::preprocess_module(std_ident)
        scope::insert_module(state.scope, std_ident, std)
    }

    for var i in 0..vector::length(node.value.body) {
        walk(node, vector::get(node.value.body, i) !*parser::Node, state)
    }
}