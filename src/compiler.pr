import buffer
import parser
import vector
import map
import scope
import util
import debug
import toolchain
import builtins
import typechecking
import consteval
import errors
import eval

export type Label = struct {
    name: string
}

export type DebugValueKind = enum {
    NULL; BOOL; INT; STRING; METADATA; CONST; DIEXP
}

export type DebugValue = struct {
    kind: DebugValueKind
    name: string
    s: string
    i: int64
}

export type DebugParam = struct {
    name: string
    value: DebugValue
}

export type ValueKind = enum {
    NULL; ZEROINITIALIZER; UNDEF; LOCAL; GLOBAL
    BOOL; INT; FLOAT; STRING; POINTER
    ARRAY; STRUCT; UNION; TYPE; ADDRESS
    METADATA; DEBUG_INFO; FUNCTION
}

export type Value = struct {
    kind: ValueKind
    metadata: bool
    distinct: bool
    name: string
    i: int64
    f: double
    s: string
    // This is the value of a type
    value_tpe: *typechecking::Type
    // Used for both struct and array
    values: [Value]
    // This is used for DEBUG_INFO
    debug_values: [DebugParam]
    // Address of a value
    addr: *Value
    tpe: *typechecking::Type
    function: *eval::FunctionPtr
}

export def copy(value: Value) -> Value {
    let ret = value
    if value.kind == ValueKind::STRING {
        let s = allocate(char, value.s.size)
        memcopy(value.s.value, s.value, value.s.size)
        ret.s = s
    } else if value.kind == ValueKind::ARRAY or value.kind == ValueKind::STRUCT {
        let values = allocate(Value, value.values.size)
        for var i in 0..value.values.size {
            values[i] = copy(value.values[i])
        }
        ret.values = values
    }
    return ret
}

export let NO_VALUE = { kind = ValueKind::NULL, tpe = null } !Value

export type InsnKind = enum {
    ADD; SUB; MUL; SREM; UREM; SDIV; UDIV
    FADD; FSUB; FMUL; FREM; FDIV; ASHR; LSHR
    SHL; AND; OR; XOR; FCMP; ICMP; FNEG
    RET; LOAD; STORE; ALLOCA
    INSERTVALUE; EXTRACTVALUE; GETELEMENTPTR
    TRUNC; ZEXT; SEXT; FPTRUNC; FPEXT
    FPTOUI; FPTOSI; UITOFP; SITOFP
    PTRTOINT; INTTOPTR; BITCAST; SWITCH
    CALL; BR_UNC; BR; UNREACHABLE
}

export type CompareFloat = enum {
    ueq; ugt; uge; ult; ule; une
}

export type CompareInt = enum {
    eq; ne; ugt; uge; ult; ule;
    sgt; sge; slt; sle
}

export type InsnFcmp = struct {
    op: CompareFloat
    ret: Value
    left: Value
    right: Value
}

export type InsnIcmp = struct {
    op: CompareInt
    ret: Value
    left: Value
    right: Value
}

export type SwitchValue = struct {
    value: Value
    label_: Label
}

export type InsnSwitch = struct {
    value: Value
    otherwise: Label
    // Vector of SwitchValue
    switch_values: *vector::Vector
}

export type InsnFneg = struct {
    ret: Value
    value: Value
}

export type InsnInsertValue = struct {
    ret: Value
    value: Value
    element: Value
    index: [int]
}

export def insert_value(state: *State, ret: *typechecking::Type, value: Value, element: Value, index: [int]) -> Value {
    return insert_value(state, ret, value, element, index, null)
}

export def insert_value(state: *State, ret: *typechecking::Type, value: Value, element: Value, index: [int], loc: *Value) -> Value {
    let iv_index = allocate(int, index.size)
    for var i in 0..index.size {
        iv_index[i] = index[i]
    }
    let iv_ret = make_local_value(ret, null, state)
    let iv = make_insn_dbg(InsnKind::INSERTVALUE, loc)
    iv.value.insert_value = {
        ret = iv_ret,
        value = value,
        element = element,
        index = iv_index
    } !InsnInsertValue
    push_insn(iv, state)
    
    return iv_ret
}

export type InsnGetElementPtr = struct {
    ret: Value
    // Here the type isn't the same as ret
    tpe: *typechecking::Type
    value: Value
    index: [Value]
}

export def gep(state: *State, ret: *typechecking::Type, tpe: *typechecking::Type, value: Value, index: [int]) -> Value {
    return gep(state, ret, tpe, value, index, null)
}

export def gep(state: *State, ret: *typechecking::Type, tpe: *typechecking::Type, value: Value, index: [int], loc: *Value) -> Value {
    let gep_index = allocate(Value, index.size)
    for var i in 0..index.size {
        gep_index[i] = make_int_value(index[i])
    }
    let gep_ret = make_local_value(ret, null, state)
    let gep = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    gep.value.gep = {
        ret = gep_ret,
        tpe = tpe,
        value = value,
        index = gep_index
    } !InsnGetElementPtr
    push_insn(gep, state)

    return gep_ret
}

export type InsnConvert = struct {
    ret: Value
    value: Value
}

export type InsnExtractValue = struct {
    ret: Value
    value: Value
    index: [int]
}

export def extract_value(state: *State, ret: *typechecking::Type, value: Value, index: [int]) -> Value {
    return extract_value(state, ret, value, index, null)
}

export def extract_value(state: *State, ret: *typechecking::Type, value: Value, index: [int], loc: *Value) -> Value {
    let ev_index = allocate(int, index.size)
    for var i in 0..index.size {
        ev_index[i] = index[i]
    }
    let ev_ret = make_local_value(ret, null, state)
    let ev = make_insn_dbg(InsnKind::EXTRACTVALUE, loc)
    ev.value.extract_value = {
        ret = ev_ret,
        value = value,
        index = ev_index
    } !InsnExtractValue
    push_insn(ev, state)

    return ev_ret
}

export type InsnStore = struct {
    value: Value
    loc: Value
}

// TODO This really shouldn't be necessary
export def store(state: *State, vloc: Value, value: Value) {
    store(state, vloc, value, null)
}

export def store(state: *State, vloc: Value, value: Value, loc: *Value) {
    let store = make_insn_dbg(InsnKind::STORE, loc)
    store.value.store = {
        loc = vloc,
        value = value
    } !InsnStore
    push_insn(store, state)
}

export type InsnLoad = struct {
    value: Value
    loc: Value
}

export def load(state: *State, tpe: *typechecking::Type, locv: Value) -> Value {
    return load(state, tpe, locv, null)
}

export def load(state: *State, tpe: *typechecking::Type, locv: Value, loc: *Value) -> Value {
    let load_ret = make_local_value(tpe, null, state)
    let load = make_insn_dbg(InsnKind::LOAD, loc)
    load.value.load = {
        loc = locv,
        value = load_ret
    } !InsnLoad
    push_insn(load, state)

    return load_ret
}

export def ret(state:* State, value: Value) {
    ret(state, value, null)
}

export def ret(state: *State, value: Value, loc: *Value) {
    let ret = make_insn_dbg(InsnKind::RET, loc)
    ret.value.ret.value = value
    push_insn(ret, state)
}

export type InsnReturn = struct {
    value: Value
}

export type InsnArithmetic = struct {
    ret: Value
    left: Value
    right: Value
}

export type InsnAlloca = struct {
    ret: Value
}

export type InsnCall = struct {
    name: Value
    ret: Value
    args: [Value]
    proto: [typechecking::NamedParameter]
}

export def call(state: *State, name: string, tpe: *typechecking::Type, args: [Value]) -> Value {
    return call(state, name, tpe, args, null)
}

export def call(state: *State, name: string, tpe: *typechecking::Type, args: [Value], loc: *Value) -> Value {
    let call_args = allocate(Value, args.size)
    for var i in 0..args.size {
        call_args[i] = args[i]
    }

    let ret = make_local_value(tpe, null, state) if tpe else NO_VALUE
    let call = make_insn_dbg(InsnKind::CALL, loc)
    call.value.call = {
        name = { kind = ValueKind::GLOBAL, name = name } !Value,
        ret = ret,
        args = call_args
    }
    push_insn(call, state)
    return ret
}

export type InsnBrUnc = struct {
    label_: Label
}

export type InsnBr = struct {
    cond: Value
    if_true: Label
    if_false: Label
}

export type InsnValue = struct #union {
    arith: InsnArithmetic
    ret: InsnReturn
    store: InsnStore
    load: InsnLoad
    alloca: InsnAlloca
    call: InsnCall
    br_unc: InsnBrUnc
    br: InsnBr
    insert_value: InsnInsertValue
    extract_value: InsnExtractValue
    gep: InsnGetElementPtr
    convert: InsnConvert
    icmp: InsnIcmp
    fcmp: InsnFcmp
    fneg: InsnFneg
    switch_: InsnSwitch
}

export type Insn = struct {
    kind: InsnKind
    value: InsnValue
    debug: *Value
}

// Block for CFG
export type Block = struct {
    label_: string
    counter: int
    // Vector of Insn
    insn: *vector::Vector
    next: *Block
}

export type Function = struct {
    module: *toolchain::Module
    imported: bool
    dllimport: bool
    // True if we have C style varargs
    varargs: bool
    name: string
    unmangled: string
    // Vector of typechecking::NamedParameter
    args: *vector::Vector
    ret: *typechecking::Type
    multiple_returns: bool
    forward_declare: bool
    // First node
    block: *Block
    debug: *Value
    allocas: *vector::Vector

    // Map of typechecking::Type
    locals: *map::Map
    has_defer: bool
    defers: *typechecking::Type
    env: *typechecking::Type

    is_compiled: bool
}

export type Result = struct {
    // Map of Function
    functions: *map::Map
    // Map of typechecking::Type
    structures: *map::Map
    // Map of Global
    globals: *map::Map
    // Map of Value
    metadata: *map::Map

    referenced: *map::Map
}

export type Global = struct {
    dllimport: bool 
    external: bool
    private: bool
    name: string
    tpe: *typechecking::Type
    value: *Value
    line: int
    debug: *Value
}

type LoopState = struct {
    break_insn: *Insn
    continue_insn: *Insn
}

export type State = struct {
    module: *toolchain::Module
    global_counter: int
    meta_counter: int
    local_counter: int
    // TODO Make this a stack for nested functions
    current_function: *Function
    current_block: *Block
    // Vector of LoopState 
    loops: *vector::Vector
    // Map of Value
    ditypes: *map::Map
    difile: *Value
    diunit: *Value
    // Vector of Value
    discope: *vector::Vector
    // Used by eval
    globals: *map::Map
    scope: *scope::Scope
}

export def make_block -> *Block {
    let block = allocate(Block)
    @block = {
        label_ = "start",
    	insn = vector::make()
    }
    return block
}

export def make_insn_dbg(kind: InsnKind, debug: *Value) -> *Insn {
    let insn = allocate(Insn)
    (@insn).kind = kind
    if toolchain::debug_sym {
        (@insn).debug = debug
    } else {
        (@insn).debug = null
    }
    return insn
}

export def make_insn(kind: InsnKind) -> *Insn {
    return make_insn_dbg(kind, null)
}

def get_break_insn(state: *State) -> *Insn {
    if vector::length((@state).loops) > 0 {
        return (@(vector::peek((@state).loops) !*LoopState)).break_insn
    }
    return null
}

def get_continue_insn(state: *State) -> *Insn {
    if vector::length((@state).loops) > 0 {
        return (@(vector::peek((@state).loops) !*LoopState)).continue_insn
    }
    return null
}

def push_loop_state(state: *State) {
    let loops = allocate(LoopState)

    let break_insn = make_insn(InsnKind::BR_UNC)
    let continue_insn = make_insn(InsnKind::BR_UNC)

    (@loops).break_insn = break_insn
    (@loops).continue_insn = continue_insn
    
    vector::push((@state).loops, loops)
}

def pop_loop_state(state: *State) {
    vector::pop((@state).loops)
}

def make_meta(state: *State) -> *Value {
    let s = util::int_to_str((@state).meta_counter)
    (@state).meta_counter += 1
    let value = allocate(Value)
    @value = {
        kind = ValueKind::METADATA,
        name = s
    } !Value
    return value
}

def push_meta(meta: *Value, state: *State) -> *Value {
    let val = make_meta(state)
    map::put(state.module.result.metadata, (@val).name, meta)
    return val
}

def meta_to_debug_value(meta: *Value) -> DebugValue {
    if not meta { return {} !DebugValue }
    
    assert((@meta).kind == ValueKind::METADATA)
    return {
        kind = DebugValueKind::METADATA,
        name = (@meta).name
    } !DebugValue
}

export def make_location(node: *parser::Node, state: *State) -> *Value {
    if not toolchain::debug_sym { return null }
    let debug_values = allocate(DebugParam, 3)
    debug_values[0] = {
        name = "line", value = { kind = DebugValueKind::INT, i = (@node).loc.line + 1 } !DebugValue
    } !DebugParam
    debug_values[1] = {
        name = "column", value = { kind = DebugValueKind::INT, i = (@node).loc.column + 1 } !DebugValue
    } !DebugParam
    debug_values[2] = {
        name = "scope", value = meta_to_debug_value(vector::peek((@state).discope) !*Value)
    } !DebugParam
    
    let di = allocate(Value)
    @di = {
        kind = ValueKind::DEBUG_INFO,
        name = "DILocation",
        debug_values = debug_values
    } !Value
    return push_meta(di, state)
}

export def make_label(state: *State) -> Label {
    let s = util::int_to_str(state.current_block.counter)
    state.current_block.counter += 1
    return { name = s } !Label
}

export def push_label(label_: Label, state: *State) {
    let block = allocate(Block)
    // TODO Might want to use the actual label here
    @block = {
        label_ = label_.name,
        insn = vector::make(),
        counter = state.current_block.counter
    }
    
    state.current_block.next = block
    state.current_block = block
}

export def push_insn(insn: *Insn, state: *State) {
    vector::push((@(@state).current_block).insn, insn)
}

def push_alloca(insn: *Insn, state: *State) {
    vector::push(state.current_function.allocas, insn)
}

def push_declare_arg(node: *parser::Node, val: Value, name: string, arg: int, state: *State) {
    if not toolchain::debug_sym { return }
    var line = (@node).loc.line

    var debug_values: [DebugParam]
    if arg >= 0 {
        debug_values = allocate(DebugParam, 6)
    } else {
        debug_values = allocate(DebugParam, 5)
    }

    debug_values[0] = {
        name = "name", value = { kind = DebugValueKind::STRING, s = name } !DebugValue
    } !DebugParam
    debug_values[1] = {
        name = "scope", value = meta_to_debug_value(vector::peek((@state).discope) !*Value)
    } !DebugParam
    debug_values[2] = {
        name = "file", value = meta_to_debug_value((@state).difile)
    } !DebugParam
    debug_values[3] = {
        name = "line", value = { kind = DebugValueKind::INT, i = line + 1 } !DebugValue
    } !DebugParam
    debug_values[4] = {
        name = "type", value = meta_to_debug_value(di_type((@val.tpe).tpe, state))
    } !DebugParam
    if arg >= 0 {
        debug_values[5] = {
            name = "arg", value = { kind = DebugValueKind::INT, i = arg } !DebugValue
        } !DebugParam
    }

    let value = allocate(Value)
    @value = {
        kind = ValueKind::DEBUG_INFO,
        name = "DILocalVariable",
        debug_values = debug_values
    } !Value

    // These all need metadata set to true
    let args = allocate(Value, 3)
    args[0] = val
    args[0].metadata = true
    args[1] = @push_meta(value, state)
    args[1].metadata = true
    args[2] = {
        metadata = true,
        kind = ValueKind::DEBUG_INFO,
        name = "DIExpression",
        debug_values = [] ![DebugParam]
    } !Value

    let call = make_insn_dbg(InsnKind::CALL, make_location(node, state))
    (@call).value.call = {
        name = { kind = ValueKind::GLOBAL, name = "llvm.dbg.declare" } !Value,
        ret = NO_VALUE,
        args = args
    } !InsnCall
    push_insn(call, state)
}

def push_declare(node: *parser::Node, val: Value, name: string, state: *State) {
    push_declare_arg(node, val, name, -1, state)
}

export def make_int_value(v: int) -> Value {
    let value = {
        kind = ValueKind::INT,
        i = v,
        tpe = builtins::int_
    } !Value
    return value
}

export def make_address_value(tpe: *typechecking::Type, addr: *Value, state: *State) -> Value {
    return {
        kind = ValueKind::ADDRESS,
        tpe = tpe,
        addr = addr
    } !Value
}

export def make_local_value(tpe: *typechecking::Type, addr: *Value, state: *State) -> Value {
    let s = util::int_to_str(state.current_block.counter)
    state.current_block.counter += 1
    return {
        kind = ValueKind::LOCAL,
        name = s,
        tpe = tpe,
        addr = addr
    } !Value
}

export def make_named_local(tpe: *typechecking::Type, addr: *Value, state: *State) -> Value {
    let buf = buffer::make_buffer()
    buffer::append_str(*buf, "tmp.")
    buffer::append_str(*buf, util::int_to_str(state.local_counter))
    let name = buffer::to_string(*buf)

    state.local_counter += 1

    return {
        kind = ValueKind::LOCAL,
        name = name,
        tpe = tpe,
        addr = addr
    } !Value
}

export def make_global_name(name: string, state: *State) -> string {
    let buf = buffer::make_buffer()
    buffer::append_str(*buf, state.module.module)
    buffer::append_str(*buf, "::")
    buffer::append_str(*buf, name)
    buffer::append_char(*buf, '.')
    buffer::append_str(*buf, util::int_to_str((@state).global_counter))
    (@state).global_counter += 1

    return buffer::to_string(*buf)
}

export def make_global_value(tpe: *typechecking::Type, name: string, value: *Value, state: *State) -> Value {
    let global = allocate(Global)
    name = make_global_name(name, state)

    @global = {
        private = true,
        name = name,
        tpe = tpe,
        value = value,
        line = -1
    } !Global
    map::put(state.module.result.globals, (@global).name, global)

    return {
        kind = ValueKind::GLOBAL,
        name = name,
        tpe = typechecking::pointer(tpe),
        addr = null
    } !Value
}

export def load_value(node: *parser::Node, value: Value, state: *State) -> Value {
    let loc = make_location(node, state)
    if value.addr {
        let ret = make_local_value(value.tpe, value.addr, state)
        let load = make_insn_dbg(InsnKind::LOAD, loc)
        (@load).value.load = {
            value = ret,
            loc = @value.addr
        } !InsnLoad
        push_insn(load, state)
        // TODO Temporary hack for builtin functions
        ret.value_tpe = value.value_tpe
        return ret
    } else {
        return value
    }
}

export def charp_str(value: Value, state: *State) -> Value {
    let local = make_local_value(typechecking::pointer(builtins::char_), null, state)

    let index = allocate(int, 1)
    index[0] = 1

    let extract = make_insn(InsnKind::EXTRACTVALUE)
    (@extract).value.extract_value = {
        ret = local,
        value = value,
        index = index
    } !InsnExtractValue

    push_insn(extract, state)

    return local
}

export def charp_static(global: *Value, state: *State) -> Value {
    let local = make_local_value(typechecking::pointer(builtins::char_), global, state)

    let index = allocate(Value, 2)
    index[0] = make_int_value(0)
    index[1] = make_int_value(0)

    let gep = make_insn(InsnKind::GETELEMENTPTR)
    (@gep).value.gep = {
        ret = local,
        tpe = (@(@global).tpe).tpe,
        value = @global,
        index = index
    } !InsnGetElementPtr

    push_insn(gep, state)

    return local
}

export def charp(str: string, state: *State) -> Value {
    let tpe = typechecking::make_type_raw(typechecking::TypeKind::STATIC_ARRAY)
    tpe.tpe = builtins::char_
    tpe.length = str.size
    tpe.size = tpe.length * (size_of char)
    tpe.align = align_of char

    let value = allocate(Value)
    @value = {
        kind = ValueKind::STRING,
        s = str,
        tpe = tpe
    } !Value

    let global = make_global_value(tpe, "str", value, state)
    let globalp = allocate(Value)
    @globalp = global
    return charp_static(globalp, state)
}

def push_scope(node: *parser::Node, state: *State) {
    if not toolchain::debug_sym { return }

    let debug_values = allocate(DebugParam, 4)
    debug_values[0] = {
        name = "scope", value = meta_to_debug_value(vector::peek((@state).discope) !*Value)
    } !DebugParam
    debug_values[1] = {
        name = "file", value = meta_to_debug_value((@state).difile)
    } !DebugParam
    debug_values[2] = {
        name = "line", value = { DebugValueKind::INT, i = (@node).loc.line + 1} !DebugValue
    } !DebugParam
    debug_values[3] = {
        name = "column", value = { DebugValueKind::INT, i = (@node).loc.column + 1} !DebugValue
    } !DebugParam

    let dilexical = allocate(Value)
    @dilexical = {
        kind = ValueKind::DEBUG_INFO,
        name = "DILexicalBlock",
        distinct = true,
        debug_values = debug_values
    } !Value

    vector::push((@state).discope, push_meta(dilexical, state))
}

def pop_scope(state: *State) {
    if toolchain::debug_sym {
        vector::pop((@state).discope)
    }
}

// TODO We might want to cache this somewhere
def make_return_type(tpe: *typechecking::Type) -> *typechecking::Type {
    let length = vector::length(tpe.return_t)
    let fields = allocate(typechecking::StructMember, length)

    for var i in 0..length {
        let t = vector::get(tpe.return_t, i) !*typechecking::Type
        // TODO Add an underscore in front for the debugger
        let name = util::int_to_str(i)

        fields[i] = { line = tpe.line, name = name, tpe = t } !typechecking::StructMember
    }

    return typechecking::make_struct_type(fields)
}

def import_structure(tpe: *typechecking::Type, module: *toolchain::Module) {
    let res = map::get(module.result.structures, tpe.type_name) !*typechecking::Type
    if not res or tpe.kind == typechecking::TypeKind::STUB {
        let size = tpe.fields.size
        if size > 0 {
            map::put(module.result.structures, tpe.type_name, tpe)
            for var i in 0..size {
                let field = tpe.fields[i]
                import_structures(field.tpe, module)
            }
        }
    }
}

export def import_structures(tpe: *typechecking::Type, module: *toolchain::Module) {
    if not tpe { return }
    switch tpe.kind !int {
        case typechecking::TypeKind::STRUCT..=typechecking::TypeKind::UNION:
            import_structure(tpe, module)
        case typechecking::TypeKind::ARRAY:
            import_structures(tpe.tpe, module)
        case typechecking::TypeKind::STATIC_ARRAY:
            import_structures(tpe.tpe, module)
        case typechecking::TypeKind::POINTER:
            import_structures(tpe.tpe, module)
        case typechecking::TypeKind::FUNCTION:
            for var i in 0..vector::length(tpe.parameter_t) {
                let param = vector::get(tpe.parameter_t, i) !*typechecking::NamedParameter
                import_structures((@param).tpe, module)
            }
            for var i in 0..vector::length(tpe.return_t) {
                let t = vector::get(tpe.return_t, i) !*typechecking::Type
                import_structures(t, module)
            }
        case typechecking::TypeKind::STUB:
            if not map::contains(module.result.structures, tpe.type_name) {
                map::put(module.result.structures, tpe.type_name, tpe)
            }
    }
}

export def walk_and_load_expression(node: *parser::Node, state: *State) -> Value {
    let expr = walk_expression(node, state)
    return load_value(node, expr, state)
}

def walk_Null(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    let value = {
        kind = ValueKind::NULL,
        tpe = tpe
    } !Value
    return value
}

def walk_Boolean(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    let value = {
        kind = ValueKind::BOOL,
        i = (@node).value.i,
        tpe = tpe
    } !Value
    return value
}

def walk_Integer(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    let value = {
        kind = ValueKind::INT,
        i = (@node).value.i,
        tpe = tpe
    } !Value
    return value
}

def walk_Float(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    let value = {
        kind = ValueKind::FLOAT,
        f = (@node).value.f,
        tpe = tpe
    } !Value
    return value
}

def walk_Char(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    let value = {
        kind = ValueKind::INT,
        i = (@node).value.i,
        tpe = tpe
    } !Value
    return value    
}

def walk_String(node: *parser::Node, state: *State) -> Value {
    let loc = make_location(node, state)
    let tpe = (@node).tpe

    let strtpe = typechecking::make_type_raw(typechecking::TypeKind::STATIC_ARRAY)
    (@strtpe).tpe = builtins::char_
    (@strtpe).length = (@node).value.str.size
    (@strtpe).size = (@strtpe).length * (size_of char)
    (@strtpe).align = align_of char
    
    let str_value = allocate(Value)
    @str_value = {
        kind = ValueKind::STRING,
        s = (@node).value.str,
        tpe = tpe
    } !Value

    let global = make_global_value(strtpe, "str", str_value, state)

    let alloca_ret = make_named_local(tpe, null, state)
    let alloca = make_insn_dbg(InsnKind::ALLOCA, loc)
    alloca.value.alloca = {
        ret = alloca_ret
    } !InsnAlloca
    push_alloca(alloca, state)
    alloca_ret.tpe = typechecking::pointer(tpe)
    
    let index = allocate(Value, 2)
    index[0] = make_int_value(0)
    index[0].tpe = builtins::size_t_
    index[1] = make_int_value(0)
    index[1].tpe = builtins::size_t_

    let gep_ret = make_local_value(typechecking::pointer(tpe.tpe), null, state)
    let gep = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    (@gep).value.gep = {
        ret = gep_ret,
        tpe = strtpe,
        value = global,
        index = index
    } !InsnGetElementPtr
    push_insn(gep, state)
    
    let alloca_retp = allocate(Value)
    @alloca_retp = alloca_ret
    let ret = make_local_value(tpe, alloca_retp, state)

    let values = allocate(Value, 2)
    values[0] = {
        kind = ValueKind::INT,
        tpe = builtins::size_t_,
        i = (@node).value.str.size
    } !Value
    values[1] = {
        kind = ValueKind::UNDEF,
        tpe = typechecking::pointer(tpe.tpe)
    } !Value

    let value = {
        kind = ValueKind::STRUCT,
        values = values,
        tpe = tpe
    } !Value

    let index2 = allocate(int, 1)
    index2[0] = 1
    let insert = make_insn_dbg(InsnKind::INSERTVALUE, loc)
    (@insert).value.insert_value = {
        ret = ret,
        value = value,
        element = gep_ret, 
        index = index2
    } !InsnInsertValue
    push_insn(insert, state)

    let store = make_insn_dbg(InsnKind::STORE, loc)
    store.value.store = {
        value = ret,
        loc = alloca_ret
    } !InsnStore
    push_insn(store, state)

    return ret
}

def convert_ref_to_ref(tpe: *typechecking::Type, value: Value, loc: *Value, state: *State) -> Value {
    let index1 = allocate(int, 1)
    index1[0] = 0
    
    let extract1_ret = make_local_value(typechecking::pointer(builtins::int64_), null, state)
    let extract1 = make_insn_dbg(InsnKind::EXTRACTVALUE, loc)
    extract1.value.extract_value = {
        ret = extract1_ret,
        value = value,
        index = index1
    } !InsnExtractValue
    push_insn(extract1, state)

    let index2 = allocate(int, 1)
    index2[0] = 1
    
    let extract2_ret = make_local_value(typechecking::pointer(value.tpe.tpe), null, state)
    let extract2 = make_insn_dbg(InsnKind::EXTRACTVALUE, loc)
    extract2.value.extract_value = {
        ret = extract2_ret,
        value = value,
        index = index2
    } !InsnExtractValue
    push_insn(extract2, state)

    let index3 = allocate(int, 1)
    index3[0] = 2
    
    let extract3_ret = make_local_value(typechecking::pointer(builtins::Type_), null, state)
    let extract3 = make_insn_dbg(InsnKind::EXTRACTVALUE, loc)
    extract3.value.extract_value = {
        ret = extract3_ret,
        value = value,
        index = index3
    } !InsnExtractValue
    push_insn(extract3, state) 

    let bitcast_ret = make_local_value(typechecking::pointer(tpe.tpe if tpe.tpe else builtins::int8_), null, state)
    let bitcast = make_insn_dbg(InsnKind::BITCAST, loc)
    bitcast.value.convert = {
        ret = bitcast_ret,
        value = extract2_ret
    } !InsnConvert
    push_insn(bitcast, state)

    var start = { kind = ValueKind::UNDEF, tpe = tpe } !Value

    let insert1_ret = make_local_value(tpe, null, state)
    let insert1 = make_insn_dbg(InsnKind::INSERTVALUE, loc)
    insert1.value.insert_value = {
        ret = insert1_ret,
        value = start,
        element = extract1_ret,
        index = index1
    } !InsnInsertValue
    push_insn(insert1, state)

    let insert2_ret = make_local_value(tpe, null, state)
    let insert2 = make_insn_dbg(InsnKind::INSERTVALUE, loc)
    insert2.value.insert_value = {
        ret = insert2_ret,
        value = insert1_ret,
        element = bitcast_ret,
        index = index2
    } !InsnInsertValue
    push_insn(insert2, state)

    let insert3_ret = make_local_value(tpe, null, state)
    let insert3 = make_insn_dbg(InsnKind::INSERTVALUE, loc)
    insert3.value.insert_value = {
        ret = insert3_ret,
        value = insert2_ret,
        element = extract3_ret,
        index = index3
    } !InsnInsertValue
    push_insn(insert3, state)

    return insert3_ret
}

// TODO This name is stupid
def do_create_type(tpe: *typechecking::Type, module: *toolchain::Module) -> Value {
    let value = create_type(tpe, module)
    if value { return @value }
    return { kind = ValueKind::NULL, tpe = typechecking::pointer(builtins::Type_) } !Value
}

export def convert_to(node: *parser::Node, value: Value, tpe: *typechecking::Type, state: *State) -> Value {
    if not value.tpe or not tpe { return value }
    let loc = make_location(node, state)
    
    if typechecking::equals(value.tpe, tpe) {
        return value
    }

    var kind: InsnKind
    if typechecking::is_ref(tpe) and typechecking::is_ref(value.tpe) {
        return convert_ref_to_ref(tpe, value, loc, state)
    } else if typechecking::is_ref(tpe) and typechecking::equals(value.tpe, builtins::Ref_) {
        return convert_ref_to_ref(tpe, value, loc, state)
    } else if typechecking::equals(tpe, builtins::Ref_) and typechecking::is_ref(value.tpe) {
        return convert_ref_to_ref(tpe, value, loc, state)
    } else if typechecking::is_pointer(tpe) and typechecking::is_ref(value.tpe) {

        let index = allocate(int, 1)
        index[0] = 1
        let extract_ret = make_local_value(typechecking::pointer(value.tpe.tpe), null, state)
        let extract = make_insn_dbg(InsnKind::EXTRACTVALUE, loc)
        extract.value.extract_value = {
            ret = extract_ret,
            value = value,
            index = index
        } !InsnExtractValue
        push_insn(extract, state)

        let bitcast_ret = make_local_value(typechecking::pointer(tpe.tpe), null, state)
        let bitcast = make_insn_dbg(InsnKind::BITCAST, loc)
        bitcast.value.convert = {
            ret = bitcast_ret,
            value = extract_ret
        } !InsnConvert
        push_insn(bitcast, state)

        return bitcast_ret

    } else if typechecking::is_ref(tpe) and (typechecking::is_assignable(tpe.tpe, value.tpe, state.module) or 
        typechecking::is_assignable(tpe, typechecking::reference(value.tpe), state.module) or 
        tpe.tpe == null or value.tpe.kind == typechecking::TypeKind::NULL) {

        var is_null = false
        if value.tpe.kind == typechecking::TypeKind::NULL { 
            value.tpe = tpe.tpe 
            is_null = true
        }

        map::put(state.module.imported, "malloc", map::sentinel)
        let svalue = do_create_type(typechecking::reference(value.tpe), state.module)

        let args1 = allocate(Value, 1)
        args1[0] = { kind = ValueKind::INT, tpe = builtins::int64_, i = builtins::int64_.size } !Value
        let call1_ret = make_local_value(typechecking::pointer(builtins::int8_), null, state)
        let call1 = make_insn_dbg(InsnKind::CALL, loc)
        call1.value.call = {
            name = {kind = ValueKind::GLOBAL, name = "malloc" } !Value,
            ret = call1_ret,
            args = args1
        } !InsnCall
        push_insn(call1, state)

        let refcount = make_local_value(typechecking::pointer(builtins::int64_), null, state)
        let bitcast1 = make_insn_dbg(InsnKind::BITCAST, loc)
        bitcast1.value.convert = {
            ret = refcount,
            value = call1_ret
        } !InsnConvert
        push_insn(bitcast1, state)

        let store1 = make_insn_dbg(InsnKind::STORE, loc)
        store1.value.store = {
            loc = refcount,
            value = { kind = ValueKind::INT, tpe = builtins::int64_, i = 0 } !Value
        } !InsnStore
        push_insn(store1, state)

        let start = { kind = ValueKind::UNDEF, tpe = tpe } !Value

        let index1 = allocate(int, 1)
        index1[0] = 0
        let ret_insert1 = make_local_value(tpe, null, state)
        let insert1 = make_insn_dbg(InsnKind::INSERTVALUE, loc)
        insert1.value.insert_value = {
            ret = ret_insert1,
            value = start,
            element = refcount,
            index = index1
        } !InsnInsertValue
        push_insn(insert1, state)

        var heapval: Value
        if not is_null {
            let args2 = allocate(Value, 1)
            args2[0] = { kind = ValueKind::INT, tpe = builtins::int64_, i = value.tpe.size } !Value
            let call2_ret = make_local_value(typechecking::pointer(builtins::int8_), null, state)
            let call2 = make_insn_dbg(InsnKind::CALL, loc)
            call2.value.call = {
                name = {kind = ValueKind::GLOBAL, name = "malloc" } !Value,
                ret = call2_ret,
                args = args2
            } !InsnCall
            push_insn(call2, state)
            
            heapval = make_local_value(typechecking::pointer(value.tpe), null, state)
            let bitcast2 = make_insn_dbg(InsnKind::BITCAST, loc)
            bitcast2.value.convert = {
                ret = heapval,
                value = call2_ret
            } !InsnConvert
            push_insn(bitcast2, state)

            let store2 = make_insn_dbg(InsnKind::STORE, loc)
            store2.value.store = {
                loc = heapval,
                value = value
            } !InsnStore
            push_insn(store2, state)

            if not typechecking::equals(tpe.tpe, value.tpe) {
                let bitcast2_ret = make_local_value(typechecking::pointer(tpe.tpe), null, state)
                let bitcast2 = make_insn_dbg(InsnKind::BITCAST, loc)
                bitcast2.value.convert = {
                    ret = bitcast2_ret,
                    value = heapval
                } !InsnConvert
                push_insn(bitcast2, state)
                heapval = bitcast2_ret
            }
        } else {
            heapval = { kind = ValueKind::NULL, tpe = typechecking::pointer(value.tpe) } !Value
        }
        
        let index2 = allocate(int, 1)
        index2[0] = 1
        let ret_insert2 = make_local_value(tpe, null, state)
        let insert2 = make_insn_dbg(InsnKind::INSERTVALUE, loc)
        insert2.value.insert_value = {
            ret = ret_insert2,
            value = ret_insert1,
            element = heapval,
            index = index2
        }
        push_insn(insert2, state)

        let index3 = allocate(int, 1)
        index3[0] = 2
        let ret_insert3 = make_local_value(tpe, null, state)
        let insert3 = make_insn_dbg(InsnKind::INSERTVALUE, loc)
        insert3.value.insert_value = {
            ret = ret_insert3,
            value = ret_insert2,
            element = svalue,
            index = index3
        }
        push_insn(insert3, state)

        return ret_insert3
    } else if tpe.kind == typechecking::TypeKind::ARRAY {
        if (@value.tpe).kind == typechecking::TypeKind::STATIC_ARRAY and
            (@value.tpe).length == 0 {

            let values = allocate(Value, 2)
            values[0] = {
                kind = ValueKind::INT,
                tpe = builtins::size_t_,
                i = (@value.tpe).length
            } !Value
            values[1] = {
                kind = ValueKind::NULL,
                tpe = typechecking::pointer(tpe.tpe)
            } !Value
            return {
                kind = ValueKind::STRUCT,
                values = values,
                tpe = tpe
            } !Value
        } else if (@value.tpe).kind == typechecking::TypeKind::STATIC_ARRAY and 
            (not tpe.tpe or typechecking::equals(tpe.tpe, (@value.tpe).tpe)) {

            var local = make_local_value(typechecking::pointer((@value.tpe).tpe), null, state)

            let index = allocate(Value, 2)
            index[0] = make_int_value(0)
            index[0].tpe = builtins::size_t_
            index[1] = make_int_value(0)
            index[1].tpe = builtins::size_t_

            let gep = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
            (@gep).value.gep = {
                ret = local,
                tpe = value.tpe,
                value = @value.addr,
                index = index
            } !InsnGetElementPtr

            push_insn(gep, state)

            if not tpe.tpe {
                let local1 = local
                local = make_local_value(typechecking::pointer(null), null, state)
                let bitcast = make_insn_dbg(InsnKind::BITCAST, loc)
                (@bitcast).value.convert = {
                    ret = local,
                    value = local1
                } !InsnConvert

                push_insn(bitcast, state)
            }

            let ret = make_local_value(tpe, null, state)

            let values = allocate(Value, 2)
            values[0] = {
                kind = ValueKind::INT,
                tpe = builtins::size_t_,
                i = (@value.tpe).length
            } !Value
            values[1] = {
                kind = ValueKind::UNDEF,
                tpe = typechecking::pointer(tpe.tpe)
            } !Value

            let value = {
                kind = ValueKind::STRUCT,
                values = values,
                tpe = tpe
            } !Value

            let index2 = allocate(int, 1)
            index2[0] = 1
            let insert = make_insn_dbg(InsnKind::INSERTVALUE, loc)
            (@insert).value.insert_value = {
                ret = ret,
                value = value,
                element = local, 
                index = index2
            } !InsnInsertValue

            push_insn(insert, state)

            return ret
        } else if not tpe.tpe and (@value.tpe).kind == typechecking::TypeKind::ARRAY {
            let index1 = allocate(int, 1)
            index1[0] = 0

            let size = make_local_value(builtins::size_t_, null, state)
            let extract1 = make_insn_dbg(InsnKind::EXTRACTVALUE, loc)
            (@extract1).value.extract_value = {
                ret = size,
                value = value,
                index = index1
            } !InsnExtractValue

            push_insn(extract1, state)

            let index2 = allocate(int, 1)
            index2[0] = 1

            let ptr = make_local_value(typechecking::pointer((@value.tpe).tpe), null, state)
            let extract2 = make_insn_dbg(InsnKind::EXTRACTVALUE, loc)
            (@extract2).value.extract_value = {
                ret = ptr,
                value = value,
                index = index2
            } !InsnExtractValue

            push_insn(extract2, state)

            let bitcast_ret = make_local_value(typechecking::pointer(null), null, state)
            let bitcast = make_insn_dbg(InsnKind::BITCAST, loc)
            (@bitcast).value.convert = {
                ret = bitcast_ret,
                value = ptr
            } !InsnConvert

            push_insn(bitcast, state)

            let insert1_ret = make_local_value(tpe, null, state)
            let insert1 = make_insn_dbg(InsnKind::INSERTVALUE, loc)
            (@insert1).value.insert_value = {
                ret = insert1_ret,
                value = { kind = ValueKind::UNDEF, tpe = tpe } !Value,
                element = size,
                index = index1
            } !InsnInsertValue

            push_insn(insert1, state)

            let insert2_ret = make_local_value(tpe, null, state)
            let insert2 = make_insn_dbg(InsnKind::INSERTVALUE, loc)
            (@insert2).value.insert_value = {
                ret = insert2_ret,
                value = insert1_ret,
                element = bitcast_ret,
                index = index2
            } !InsnInsertValue

            push_insn(insert2, state)

            return insert2_ret
        } else {
            return value
        }
    } else if tpe.kind == typechecking::TypeKind::BOOL {
        if typechecking::is_pointer(value.tpe) {
            // TODO This isn't the correct type, we need something like
            // intptr_t
            value = convert_to(node, value, builtins::size_t_, state)
        }
        if typechecking::is_float(value.tpe) {
            let ret = make_local_value(builtins::bool_, null, state)
            let insn = make_insn_dbg(InsnKind::FCMP, loc)
            (@insn).value.fcmp = {
                op = CompareFloat::une,
                ret = ret,
                left = value,
                right = {
                    kind = ValueKind::FLOAT,
                    tpe = value.tpe,
                    f = 0.0
                } !Value
            } !InsnFcmp
            push_insn(insn, state)
            return ret
        } else if typechecking::is_integer(value.tpe) {
            let ret = make_local_value(builtins::bool_, null, state)
            let insn = make_insn_dbg(InsnKind::ICMP, loc)
            (@insn).value.icmp = {
                op = CompareInt::ne,
                ret = ret,
                left = value,
                right = {
                    kind = ValueKind::INT,
                    tpe = value.tpe,
                    i = 0
                } !Value
            } !InsnIcmp
            push_insn(insn, state)
            return ret
        } else {
            // TODO Arrays and Co
            return value
        }
    } else if typechecking::is_integer(tpe) {
        if value.tpe.kind == typechecking::TypeKind::BOOL {
            kind = InsnKind::ZEXT
        } else if typechecking::is_integer(value.tpe) {
            if (@value.tpe).size == tpe.size {
                // Types only differ in sign, llvm doesn't treat them any different
                return value
            } else if (@value.tpe).size > tpe.size {
                kind = InsnKind::TRUNC
            } else if tpe.unsig {
                kind = InsnKind::ZEXT
            } else {
                kind = InsnKind::SEXT
            }
        } else if typechecking::is_float(value.tpe) {
            if tpe.unsig {
                kind = InsnKind::FPTOUI
            } else {
                kind = InsnKind::FPTOSI
            }
        } else if typechecking::is_pointer(value.tpe) {
            kind = InsnKind::PTRTOINT
        } else {
            return value
        }
    } else if typechecking::is_float(tpe) {
        if typechecking::is_integer(value.tpe) {
            if (@value.tpe).unsig {
                kind = InsnKind::UITOFP
            } else {
                kind = InsnKind::SITOFP
            }
        } else if typechecking::is_float(value.tpe) {
            if (@value.tpe).size > tpe.size {
                kind = InsnKind::FPTRUNC
            } else {
                kind = InsnKind::FPEXT
            }
        } else {
            return value
        }
    } else if typechecking::is_pointer(tpe) {
        if (@value.tpe).kind == typechecking::TypeKind::NULL {
            return { 
                kind = ValueKind::NULL, 
                tpe = tpe 
            } !Value
        } else if typechecking::is_pointer(value.tpe) or (@value.tpe).kind == typechecking::TypeKind::NULL {
            kind = InsnKind::BITCAST
        } else if typechecking::is_integer(value.tpe) {
            kind = InsnKind::INTTOPTR
        } else {
            return value
        }
    } else {
        return value
    }

    let ret = make_local_value(tpe, null, state)

    let insn = make_insn_dbg(kind, loc)
    (@insn).value.convert = {
        ret = ret,
        value = value
    } !InsnConvert

    push_insn(insn, state)

    return ret
}

def walk_Cast(node: *parser::Node, state: *State) -> Value {
    let value = walk_and_load_expression((@node).value.expr, state)
    import_structures((@node).tpe, state.module)
    return convert_to(node, value, (@node).tpe, state)
}

def walk_StructLitUnion(node: *parser::Node, state: *State) -> Value {
    let loc = make_location(node, state)
    let args = (@node).value.struct_lit.args
    let kwargs = (@node).value.struct_lit.kwargs
    let tpe = (@node).tpe

    let largs = vector::length(args)
    let lkwargs = vector::length(kwargs)
    if largs > 1 or lkwargs > 1 or largs == 1 and lkwargs == 1 {
        errors::errorn(node, "Union initalizer can only have one argument")
        return NO_VALUE
    } else if largs == 0 and lkwargs == 0 {
        let arraytpe = typechecking::make_static_array(builtins::char_, tpe.size)

        let values = allocate(Value, 1)
        values[0] = {
            kind = ValueKind::ZEROINITIALIZER,
            tpe = arraytpe
        } !Value

        return {
            kind = ValueKind::STRUCT,
            tpe = tpe,
            values = values
        } !Value
    }

    var arg: *parser::Node = null
    var arg_tpe: *typechecking::Type = null
    if largs == 1 {
        arg = vector::get(args, 0) !*parser::Node
        arg_tpe = tpe.fields[0].tpe
    } else {
        let kwarg = vector::get(kwargs, 0) !*parser::Node
        arg = (@kwarg).value.named_arg.value
        let name = typechecking::last_ident_to_str((@kwarg).value.named_arg.name)

        for var j in 0..tpe.fields.size {
            let field = tpe.fields[j]
            if field.name == name {
                arg_tpe = field.tpe
                break
            }
        }
    }

    let value = convert_to(arg, walk_and_load_expression(arg, state), arg_tpe, state)
    if typechecking::is_ref(arg_tpe) {
        increase_ref_count_of_value(value, loc, state)
    }

    let alloca_ret = make_named_local(tpe, null, state)
    let alloca = make_insn_dbg(InsnKind::ALLOCA, loc)
    (@alloca).value.alloca = {
        ret = alloca_ret
    } !InsnAlloca
    push_alloca(alloca, state)

    alloca_ret.tpe = typechecking::pointer(tpe)
    
    let index = allocate(Value, 3)
    index[0] = make_int_value(0)
    index[1] = make_int_value(0)
    index[2] = make_int_value(0)
    let gep_ret = make_local_value(typechecking::pointer(builtins::char_), null, state)
    let gep = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    (@gep).value.gep = {
        ret = gep_ret,
        tpe = tpe,
        value = alloca_ret,
        index = index
    } !InsnGetElementPtr
    push_insn(gep, state)

    let bitcast_ret = make_local_value(typechecking::pointer(arg_tpe), null, state)
    let bitcast = make_insn_dbg(InsnKind::BITCAST, loc)
    (@bitcast).value.convert = {
        ret = bitcast_ret,
        value = gep_ret
    } !InsnConvert
    push_insn(bitcast, state)

    let store = make_insn_dbg(InsnKind::STORE, loc)
    (@store).value.store = {
        loc = bitcast_ret,
        value = value
    } !InsnStore
    push_insn(store, state)

    let load_ret = make_local_value(tpe, null, state)
    let load = make_insn_dbg(InsnKind::LOAD, loc)
    (@load).value.load = {
        value = load_ret,
        loc = alloca_ret
    } !InsnLoad
    push_insn(load, state)

    return load_ret
}

def locals_to_insert_value(value: *Value, state: *State) {
    let values = value.values
    for var i in 0..values.size {
        let val = values[i]
        if val.kind == ValueKind::LOCAL or val.kind == ValueKind::GLOBAL {
            values[i] = {
                kind = ValueKind::UNDEF,
                tpe = val.tpe
            } !Value

            let ret = make_local_value(value.tpe, null, state)
            
            let index = allocate(int, 1)
            index[0] = i
            let insert = make_insn(InsnKind::INSERTVALUE)
            (@insert).value.insert_value = {
                ret = ret,
                value = @value,
                element = val,
                index = index
            } !InsnInsertValue
            
            push_insn(insert, state)
            @value = ret
        }
    }
}

def walk_StructLit(node: *parser::Node, state: *State) -> Value {
    let loc = make_location(node, state)
    let args = (@node).value.struct_lit.args
    let kwargs = (@node).value.struct_lit.kwargs

    let tpe = (@node).tpe
    if not tpe { return NO_VALUE }
    if tpe.kind == typechecking::TypeKind::UNION {
        return walk_StructLitUnion(node, state)
    }

    let values = allocate(Value, tpe.fields.size)
    for var i in 0..values.size {
        values[i] = {
            kind = ValueKind::ZEROINITIALIZER,
            tpe = tpe.fields[i].tpe
        } !Value
    }
    for var i in 0..vector::length(args) {
        let arg = vector::get(args, i) !*parser::Node
        let arg_tpe = tpe.fields[i].tpe
        let value = walk_and_load_expression(arg, state)
        values[i] = convert_to(arg, value, arg_tpe, state)
        if typechecking::is_ref(arg_tpe) {
            increase_ref_count_of_value(values[i], loc, state)
        }
    }
    for var i in 0..vector::length(kwargs) {
        let kwarg = vector::get(kwargs, i) !*parser::Node
        let name = typechecking::last_ident_to_str((@kwarg).value.named_arg.name)
        let value = walk_and_load_expression((@kwarg).value.named_arg.value, state)
        
        for var j in 0..tpe.fields.size {
            let field = tpe.fields[j]
            if field.name == name {
                values[j] = convert_to(kwarg, value, field.tpe, state)
                if typechecking::is_ref(field.tpe) {
                    increase_ref_count_of_value(values[j], loc, state)
                }
                break
            }
        }
    }
    var value = {
        kind = ValueKind::STRUCT,
        values = values,
        tpe = tpe
    } !Value

    locals_to_insert_value(*value, state)
    
    return value
}

def push_array_lit(tpe: *typechecking::Type, loc: *Value, values: [Value], state: *State) -> Value {
    var value = {
        kind = ValueKind::ARRAY,
        values = values,
        tpe = tpe
    } !Value

    for var i in 0..values.size {
        let val = values[i]

        if val.kind == ValueKind::LOCAL or val.kind == ValueKind::GLOBAL {
            values[i] = {
                kind = ValueKind::UNDEF,
                tpe = val.tpe
            } !Value

            let ret = make_local_value(tpe, null, state)
            
            let index = allocate(int, 1)
            index[0] = i
            let insert = make_insn_dbg(InsnKind::INSERTVALUE, loc)
            (@insert).value.insert_value = {
                ret = ret,
                value = value,
                element = val,
                index = index
            } !InsnInsertValue
            
            push_insn(insert, state)
            value = ret
        }
    }

    let ret = make_named_local(tpe, null, state)

    let alloca = make_insn_dbg(InsnKind::ALLOCA, loc)
    (@alloca).value.alloca = {
        ret = ret
    } !InsnAlloca
    push_alloca(alloca, state)

    ret.tpe = typechecking::pointer(tpe)
    let retp = allocate(Value)
    @retp = ret
    value.addr = retp

    let store = make_insn_dbg(InsnKind::STORE, loc)
    (@store).value.store = {
        value = value,
        loc = ret
    } !InsnStore
    push_insn(store, state)

    return value
}

def walk_ArrayLit(node: *parser::Node, state: *State) -> Value {
    let loc = make_location(node, state)
    let tpe = (@node).tpe

    let len = vector::length((@node).value.body)
    let values = allocate(Value, len)
    for var i in 0..len {
        let v = vector::get((@node).value.body, i) !*parser::Node
        values[i] = walk_and_load_expression(v, state)
    }

    return push_array_lit(tpe, loc, values, state)
}

def walk_ArithmeticOp(node: *parser::Node, insn_kind: InsnKind, tpe: *typechecking::Type, state: *State) -> Value {
    let loc = make_location(node, state)
    let left = convert_to(node, walk_and_load_expression((@node).value.bin_op.left, state), tpe, state)
    let right = convert_to(node, walk_and_load_expression((@node).value.bin_op.right, state), tpe, state)

    let value = make_local_value(tpe, null, state)
    let insn = make_insn_dbg(insn_kind, loc)
    (@insn).value.arith = {
        left = left,
        right = right,
        ret = value
    } !InsnArithmetic

    push_insn(insn, state)

    return value
}

def walk_USub(node: *parser::Node, state: *State) -> Value {
    let loc = make_location(node, state)
    let tpe = (@node).tpe
    let expr = walk_and_load_expression((@node).value.expr, state)

    let ret = make_local_value(tpe, null, state)
    if tpe.kind == typechecking::TypeKind::FLOAT {
        let fneg = make_insn_dbg(InsnKind::FNEG, loc)
        (@fneg).value.fneg = {
            ret = ret,
            value = expr
        } !InsnFneg
        push_insn(fneg, state)
    } else {
        let sub = make_insn_dbg(InsnKind::SUB, loc)
        (@sub).value.arith = {
            ret = ret,
            left = { kind = ValueKind::INT, i = 0, tpe = tpe } !Value,
            right = expr
        } !InsnArithmetic
        push_insn(sub, state)
    }
    return ret
}

def walk_UAdd(node: *parser::Node, state: *State) -> Value {
    return walk_and_load_expression((@node).value.expr, state)
}

def walk_Not(node: *parser::Node, state: *State) -> Value {
    let loc = make_location(node, state)
    let expr = convert_to(node, walk_and_load_expression((@node).value.expr, state), builtins::bool_, state)
    
    let ret = make_local_value(builtins::bool_, null, state)
    let xor = make_insn_dbg(InsnKind::XOR, loc)
    (@xor).value.arith = {
        ret = ret,
        left = expr,
        right = { kind = ValueKind::BOOL, i = 1, tpe = builtins::bool_ } !Value
    } !InsnArithmetic

    push_insn(xor, state)
    return ret
}

// TODO It would be nice if and/or could work by returning the values themselves
def walk_And(node: *parser::Node, state: *State) -> Value {
    let loc = make_location(node, state)
    let left = convert_to(node, walk_and_load_expression((@node).value.bin_op.left, state), builtins::bool_, state)

    let ret_alloca = make_named_local(builtins::bool_, null, state)
    let alloca = make_insn_dbg(InsnKind::ALLOCA, loc)
    (@alloca).value.alloca = {
        ret = ret_alloca
    } !InsnAlloca
    ret_alloca.tpe = typechecking::pointer(builtins::bool_)

    push_alloca(alloca, state)

    let br = make_insn_dbg(InsnKind::BR, loc)
    (@br).value.br = {
        cond = left
    } !InsnBr

    let to_end = make_insn_dbg(InsnKind::BR_UNC, loc)

    push_insn(br, state)

    let if_false = make_label(state)
    push_label(if_false, state)

    let store1 = make_insn_dbg(InsnKind::STORE, loc)
    (@store1).value.store = {
        value = { kind = ValueKind::BOOL, i = 0, tpe = builtins::bool_ } !Value,
        loc = ret_alloca
    } !InsnStore

    push_insn(store1, state)
    push_insn(to_end, state)

    let if_true = make_label(state)
    push_label(if_true, state)

    let right = convert_to(node, walk_and_load_expression((@node).value.bin_op.right, state), builtins::bool_, state)

    let store2 = make_insn_dbg(InsnKind::STORE, loc)
    (@store2).value.store = {
        value = right,
        loc = ret_alloca
    } !InsnStore

    push_insn(store2, state)
    push_insn(to_end, state)

    let end = make_label(state)
    push_label(end, state)

    (@br).value.br.if_true = if_true
    (@br).value.br.if_false = if_false
    (@to_end).value.br_unc.label_ = end

    let ret = make_local_value(builtins::bool_, null, state)
    let load = make_insn_dbg(InsnKind::LOAD, loc)
    (@load).value.load = {
        value = ret,
        loc = ret_alloca
    } !InsnLoad

    push_insn(load, state)

    return ret
}

def walk_Or(node: *parser::Node, state: *State) -> Value {
    let loc = make_location(node, state)
    let left = convert_to(node, walk_and_load_expression((@node).value.bin_op.left, state), builtins::bool_, state)

    let ret_alloca = make_named_local(builtins::bool_, null, state)
    let alloca = make_insn_dbg(InsnKind::ALLOCA, loc)
    (@alloca).value.alloca = {
        ret = ret_alloca
    } !InsnAlloca
    ret_alloca.tpe = typechecking::pointer(builtins::bool_)

    push_alloca(alloca, state)

    let br = make_insn_dbg(InsnKind::BR, loc)
    (@br).value.br = {
        cond = left
    } !InsnBr

    let to_end = make_insn_dbg(InsnKind::BR_UNC, loc)

    push_insn(br, state)

    let if_true = make_label(state)
    push_label(if_true, state)

    let store1 = make_insn_dbg(InsnKind::STORE, loc)
    (@store1).value.store = {
        value = { kind = ValueKind::BOOL, i = 1, tpe = builtins::bool_ } !Value,
        loc = ret_alloca
    } !InsnStore

    push_insn(store1, state)
    push_insn(to_end, state)

    let if_false = make_label(state)
    push_label(if_false, state)

    let right = convert_to(node, walk_and_load_expression((@node).value.bin_op.right, state), builtins::bool_, state)

    let store2 = make_insn_dbg(InsnKind::STORE, loc)
    (@store2).value.store = {
        value = right,
        loc = ret_alloca
    } !InsnStore

    push_insn(store2, state)
    push_insn(to_end, state)

    let end = make_label(state)
    push_label(end, state)

    (@br).value.br.if_true = if_true
    (@br).value.br.if_false = if_false
    (@to_end).value.br_unc.label_ = end

    let ret = make_local_value(builtins::bool_, null, state)
    let load = make_insn_dbg(InsnKind::LOAD, loc)
    (@load).value.load = {
        value = ret,
        loc = ret_alloca
    } !InsnLoad

    push_insn(load, state)

    return ret
}

def walk_Add(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    if not tpe { return NO_VALUE }

    var insn_kind = InsnKind::ADD
    if typechecking::is_float(tpe) {
        insn_kind = InsnKind::FADD
    }
    return walk_ArithmeticOp(node, insn_kind, tpe, state)
}

def walk_Sub(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    if not tpe { return NO_VALUE }

    var insn_kind = InsnKind::SUB
    if typechecking::is_float(tpe) {
        insn_kind = InsnKind::FSUB 
    }
    return walk_ArithmeticOp(node, insn_kind, tpe, state)
}

def walk_Mul(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    if not tpe { return NO_VALUE }

    var insn_kind = InsnKind::MUL
    if typechecking::is_float(tpe) {
        insn_kind = InsnKind::FMUL 
    }
    return walk_ArithmeticOp(node, insn_kind, tpe, state)
}

def walk_Mod(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    if not tpe { return NO_VALUE }

    var insn_kind = InsnKind::SREM
    if typechecking::is_float(tpe) {
        insn_kind = InsnKind::FREM 
    } else if tpe.unsig {
        insn_kind = InsnKind::UREM
    }
    return walk_ArithmeticOp(node, insn_kind, tpe, state)
}

def walk_Div(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    if not tpe { return NO_VALUE }

    var insn_kind = InsnKind::SDIV
    if typechecking::is_float(tpe) {
        insn_kind = InsnKind::FDIV 
    } else if tpe.unsig {
        insn_kind = InsnKind::UDIV
    }
    return walk_ArithmeticOp(node, insn_kind, tpe, state)
}

def walk_Shl(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    return walk_ArithmeticOp(node, InsnKind::SHL, tpe, state)
}

def walk_Shr(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    if tpe.unsig {
        return walk_ArithmeticOp(node, InsnKind::LSHR, tpe, state)
    } else {
        return walk_ArithmeticOp(node, InsnKind::ASHR, tpe, state)
    }
}

def walk_BAnd(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    return walk_ArithmeticOp(node, InsnKind::AND, tpe, state)
}

def walk_BOr(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    return walk_ArithmeticOp(node, InsnKind::OR, tpe, state)
}

def walk_BXor(node: *parser::Node, state: *State) -> Value {
    let tpe = (@node).tpe
    return walk_ArithmeticOp(node, InsnKind::XOR, tpe, state)
}

def walk_BNot(node: *parser::Node, state: *State) -> Value {
    let loc = make_location(node, state)
    let expr = walk_and_load_expression(node.value.expr, state)

    let ret = make_local_value(node.tpe, null, state)
    let xor = make_insn_dbg(InsnKind::XOR, loc)
    xor.value.arith = {
        ret = ret,
        left = expr,
        right = { kind = ValueKind::INT, i = -1, tpe = node.tpe } !Value
    } !InsnArithmetic

    push_insn(xor, state)
    return ret
}

// TODO Refactor this
def walk_Call(node: *parser::Node, state: *State) -> Value {
    let left = node.value.func_call.left
    var tpe = (@node).function
    var is_fp = false
    if typechecking::is_function_pointer(tpe) {
        tpe = tpe.tpe
        is_fp = true
    }
    if not tpe { return NO_VALUE }

    // Filter out type arguments
    let parameter_t = vector::make()
    let call_args = vector::make()
    let call_kwargs = vector::make()

    for var i in 0..vector::length(tpe.parameter_t) {
        let np = vector::get(tpe.parameter_t, i) !*NamedParameter
        if not np or not np.tpe or np.tpe.kind != typechecking::TypeKind::TYPE {
            vector::push(parameter_t, np)
        } 
    }
    for var i in 0..vector::length(node.value.func_call.args) {
        let n = vector::get(node.value.func_call.args, i)
        var np = vector::peek(tpe.parameter_t) !*NamedParameter
        if i < vector::length(tpe.parameter_t) {
            np = vector::get(tpe.parameter_t, i) !*NamedParameter
        }
        if not np.tpe or np.tpe.kind != typechecking::TypeKind::TYPE {
            vector::push(call_args, n)
        }
    }
    
    for var i in 0..vector::length(node.value.func_call.kwargs) {
        let n = vector::get(node.value.func_call.kwargs, i) !*parser::Node
        let name = typechecking::last_ident_to_str(n.value.named_arg.name)
        for var j in 0..vector::length(parameter_t) {
            let np = vector::get(parameter_t, j) !*typechecking::NamedParameter
            if np.name == name and (not np.tpe or np.tpe.kind != typechecking::TypeKind::TYPE) {
                vector::push(call_kwargs, n)
            }
        }
    }

    var args: [Value]
    var varargs: [Value]

    var len = vector::length(parameter_t)
    let last_np = vector::peek(parameter_t) !*typechecking::NamedParameter
    var pass_varargs_as_array = last_np and last_np.varargs and last_np.tpe
    var pass_array_as_varargs = false

    let last_arg = vector::peek(call_args) !*parser::Node
    if pass_varargs_as_array and last_arg and typechecking::is_array(last_arg.tpe) and
        typechecking::equals(last_arg.tpe.tpe, last_np.tpe) {
        pass_varargs_as_array = false
        pass_array_as_varargs = true
    }

    let total_defined_args = vector::length(call_args) + vector::length(call_kwargs)
    var total_args = total_defined_args
    if last_np and last_np.varargs {
        total_args = max(total_defined_args, len - 1) !int
    } else {
        total_args = max(total_defined_args, len) !int
    }
    let num_varargs = total_args - len + 1

    if pass_varargs_as_array {
        args = allocate(Value, len)
        varargs = allocate(Value, num_varargs)
    } else {
        args = allocate(Value, total_args)
    }

    for var i in 0..vector::length(call_args) {
        let n = vector::get(call_args, i) !*parser::Node
        if i == len - 1 and pass_array_as_varargs {
            var expr = walk_and_load_expression(n, state)
            expr = convert_to(n, expr, typechecking::array(last_np.tpe), state)
            args[i] = expr
        } else if i < len - 1 or i == len - 1 and not last_np.varargs {
            let p = vector::get(parameter_t, i) !*typechecking::NamedParameter
            var expr = walk_and_load_expression(n, state)
            expr = convert_to(n, expr, (@p).tpe, state)
            args[i] = expr
        } else if last_np.varargs {
            if last_np.tpe {
                var expr = walk_and_load_expression(n, state)
                expr = convert_to(n, expr, last_np.tpe, state)
                varargs[i - len + 1] = expr
            } else {
                args[i] = walk_and_load_expression(n, state)
            }
        } else {
            return NO_VALUE
        }
    }
    for var i in 0..vector::length(call_kwargs) {
        let n = vector::get(call_kwargs, i) !*parser::Node
        assert((@n).kind == parser::NodeKind::NAMED_ARG)
        // Find named parameter
        let name = typechecking::last_ident_to_str((@n).value.named_arg.name)
        let value = (@n).value.named_arg.value
        for var j in 0..vector::length(parameter_t) {
            let p = vector::get(parameter_t, j) !*typechecking::NamedParameter
            if (@p).name == name {
                var expr = walk_and_load_expression(value, state)
                expr = convert_to(n, expr, (@p).tpe, state)
                args[j] = expr
            }
        }
    }

    if not last_np or not last_np.varargs {
        for var i in total_defined_args..total_args {
            let arg = vector::get(parameter_t, i) !*typechecking::NamedParameter
            assert(arg.value != null)

            if arg.value.kind == ValueKind::GLOBAL {
                if not map::contains(state.module.result.globals, arg.value.name) {
                    let global = allocate(Global)
                    @global = @(map::get(left.svalue.node.module.result.globals, arg.value.name) !*Global)
                    global.value = null
                    global.external = true

                    map::put(state.module.result.globals, arg.value.name, global)
                    map::put(state.module.imported, arg.value.name, map::sentinel)
                }

                let ret = make_local_value(arg.tpe, null, state)
                let load = make_insn(InsnKind::LOAD)
                load.value.load = {
                    value = ret,
                    loc = @arg.value
                } !InsnLoad
                push_insn(load, state)

                args[i] = ret
            } else {
                args[i] = @arg.value
            }
        }
    }
   
    if pass_varargs_as_array {
        let sarray_t = typechecking::make_static_array(last_np.tpe, num_varargs)
        let value = push_array_lit(sarray_t, null, varargs, state)
        args[args.size - 1] = convert_to(node, value, typechecking::array(last_np.tpe), state)
    }

    var proto = [] ![NamedParameter]
    var name_v: Value
    var ret: *typechecking::Type = null
    if is_fp {
        if vector::length(tpe.return_t) > 1 {
            ret = make_return_type(tpe)
        } else {
            ret = vector::peek(tpe.return_t) !*typechecking::Type
        }
        name_v = walk_and_load_expression((@node).value.func_call.left, state)
        proto = allocate(NamedParameter, vector::length(parameter_t))
        for var i in 0..vector::length(parameter_t) {
            proto[i] = @(vector::get(parameter_t, i) !*NamedParameter)
        }
    } else {    
        var name = tpe.type_name
        let function = map::get(state.module.result.functions, name) !*Function
        //print(name, " ", function, "\n")
        if not function { return NO_VALUE }
        ret = (@function).ret
        
        import_structures(tpe, state.module)
        map::put(state.module.imported, name, map::sentinel)

        /*let svalue = node.value.func_call.left.svalue
        if svalue and svalue.state {
            map::put(svalue.state.module.imported, name, map::sentinel)
        }*/

        let len = vector::length(parameter_t)
        proto = allocate(NamedParameter, len)
        for var i in 0..len {
            proto[i] = @(vector::get(parameter_t, i) !*NamedParameter)
        }

        name_v = {
            kind = ValueKind::GLOBAL,
            name = name
        } !Value
    }

    var addr = NO_VALUE
    var value = NO_VALUE
    if ret {
        addr = make_named_local(ret, null, state)
        
        let alloca = make_insn(InsnKind::ALLOCA)
        (@alloca).value.alloca = {
            ret = addr
        } !InsnAlloca
        push_alloca(alloca, state)
        
        addr.tpe = typechecking::pointer(ret)
        let addrp = allocate(Value)
        (@addrp) = addr
        value = make_local_value(ret, addrp, state)
    }

    let insn = make_insn_dbg(InsnKind::CALL, make_location(node, state))
    (@insn).value.call = {
        name = name_v,
        ret = value,
        args = args,
        proto = proto
    } !InsnCall

    push_insn(insn, state)

    if ret {
        let store = make_insn(InsnKind::STORE)
        (@store).value.store = {
            value = value,
            loc = addr
        } !InsnStore
        push_insn(store, state)
    }

    return value
}

def walk_Identifier(node: *parser::Node, state: *State) -> Value {
    var val = (@node).svalue
    if not val { return NO_VALUE }

    if val.tpe and val.tpe.kind == typechecking::TypeKind::TYPE {
        val = change_value_to_type(node.tpe.tpe.tpe, state)
    }

    if (@val).value {
        return @val.value
    }
    let tpe = (@node).tpe
    import_structures(tpe, state.module)
    if (@val).global {
        map::put((@(@state).module).imported, (@val).assembly_name, map::sentinel)
    }

    let name = (@val).assembly_name
    var kind = ValueKind::LOCAL
    if (@val).global {
        kind = ValueKind::GLOBAL
    }

    let locv = allocate(Value)
    (@locv) = {
        kind = kind,
        name = name,
        tpe = typechecking::pointer(tpe)
    } !Value

    if not typechecking::is_function(tpe) {
        let value = make_address_value(tpe, locv, state)
        return value
    } else {
        (@locv).name = tpe.type_name
        let value = { 
            kind = ValueKind::LOCAL, 
            name = name, 
            tpe = tpe, 
            addr = locv
        } !Value
        return value
    }
}

def decrease_ref_count_scoped(scpe: *scope::Scope, loc: *Value, state: *State) {
    let keys = map::keys(scpe.fields)
    for var i in 0..keys.size {
        let key = keys[i]
        let value = map::get(scpe.fields, key) !*scope::Value
        if typechecking::is_ref(value.tpe) {
            let name = value.assembly_name
            var kind = ValueKind::LOCAL
            if value.global {
                kind = ValueKind::GLOBAL
            }
            decrease_ref_count({ kind = kind, tpe = typechecking::pointer(value.tpe), name = name } !Value, loc, state)
        }
    }
}

def decrease_ref_count(value: Value, loc: *Value, state: *State) {
    map::put(state.module.imported, "free", map::sentinel)

    let index1 = allocate(Value, 2)
    index1[0] = make_int_value(0)
    index1[1] = make_int_value(0)

    let gep1_ret = make_local_value(typechecking::pointer(typechecking::pointer(builtins::int64_)), null, state)
    let gep1 = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    gep1.value.gep = {
        ret = gep1_ret,
        tpe = value.tpe.tpe,
        value = value,
        index = index1
    } !InsnGetElementPtr
    push_insn(gep1, state)

    let index2 = allocate(Value, 2)
    index2[0] = make_int_value(0)
    index2[1] = make_int_value(1)

    let gep2_ret = make_local_value(typechecking::pointer(typechecking::pointer(value.tpe.tpe.tpe)), null, state)
    let gep2 = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    gep2.value.gep = {
        ret = gep2_ret,
        tpe = value.tpe.tpe,
        value = value,
        index = index2
    } !InsnGetElementPtr
    push_insn(gep2, state)

    let load1_ret = make_local_value(typechecking::pointer(builtins::int64_), null, state)
    let load1 = make_insn_dbg(InsnKind::LOAD, loc)
    load1.value.load = {
        value = load1_ret,
        loc = gep1_ret
    } !InsnLoad
    push_insn(load1, state)

    let ptr_to_int_ret = make_local_value(builtins::int64_, null, state)
    let ptr_to_int = make_insn_dbg(InsnKind::PTRTOINT, loc)
    ptr_to_int.value.convert = {
        ret = ptr_to_int_ret,
        value = load1_ret
    } !InsnConvert
    push_insn(ptr_to_int, state)

    let cmp1_ret = make_local_value(builtins::bool_, null, state)
    let cmp1 = make_insn_dbg(InsnKind::ICMP, loc)
    cmp1.value.icmp = {
        op = CompareInt::eq,
        ret = cmp1_ret,
        left = ptr_to_int_ret,
        right = { kind = ValueKind::INT, tpe = builtins::int64_, i = 0 } !Value
    } !InsnIcmp
    push_insn(cmp1, state)

    let np_label = make_label(state)
    
    let br1 = make_insn_dbg(InsnKind::BR, loc)
    br1.value.br = {
        cond = cmp1_ret,
        if_false = np_label
    } !InsnBr
    push_insn(br1, state)
    push_label(np_label, state)

    let load2_ret = make_local_value(builtins::int64_, null, state)
    let load2 = make_insn_dbg(InsnKind::LOAD, loc)
    load2.value.load = {
        value = load2_ret,
        loc = load1_ret
    }
    push_insn(load2, state)

    let dec_ret = make_local_value(builtins::int64_, null, state)
    let dec = make_insn_dbg(InsnKind::SUB, loc)
    dec.value.arith = {
        ret = dec_ret,
        left = load2_ret,
        right = { kind = ValueKind::INT, tpe = builtins::int64_, i = 1 } !Value
    } !InsnArithmetic
    push_insn(dec, state)

    let store1 = make_insn_dbg(InsnKind::STORE, loc)
    store1.value.store = {
        loc = load1_ret,
        value = dec_ret
    } !InsnStore
    push_insn(store1, state)

    let cmp2_ret = make_local_value(builtins::bool_, null, state)
    let cmp2 = make_insn_dbg(InsnKind::ICMP, loc)
    cmp2.value.icmp = {
        op = CompareInt::eq,
        ret = cmp2_ret,
        left = dec_ret,
        right = { kind = ValueKind::INT, tpe = builtins::int64_, i = 0 } !Value
    } !InsnIcmp
    push_insn(cmp2, state)

    let entry_label = make_label(state)

    let br2 = make_insn_dbg(InsnKind::BR, loc)
    br2.value.br = {
        cond = cmp2_ret,
        if_true = entry_label
    } !InsnBr
    push_insn(br2, state)
    push_label(entry_label, state)

    let bitcast1_ret = make_local_value(typechecking::pointer(builtins::int8_), null, state)
    let bitcast1 = make_insn_dbg(InsnKind::BITCAST, loc)
    bitcast1.value.convert = {
        ret = bitcast1_ret,
        value = load1_ret
    } !InsnConvert
    push_insn(bitcast1, state)

    let args1 = allocate(Value, 1)
    args1[0] = bitcast1_ret

    let call1 = make_insn_dbg(InsnKind::CALL, loc)
    call1.value.call = {
        name = { kind = ValueKind::GLOBAL, name = "free" } !Value,
        ret = NO_VALUE,
        args = args1
    }
    push_insn(call1, state)

    let load3_ret = make_local_value(typechecking::pointer(value.tpe.tpe.tpe), null, state)
    let load3 = make_insn_dbg(InsnKind::LOAD, loc)
    load3.value.load = {
        value = load3_ret,
        loc = gep2_ret
    }
    push_insn(load3, state)

    let bitcast2_ret = make_local_value(typechecking::pointer(builtins::int8_), null, state)
    let bitcast2 = make_insn_dbg(InsnKind::BITCAST, loc)
    bitcast2.value.convert = {
        ret = bitcast2_ret,
        value = load3_ret
    } !InsnConvert
    push_insn(bitcast2, state)

    let args2 = allocate(Value, 1)
    args2[0] = bitcast2_ret

    let call2  = make_insn_dbg(InsnKind::CALL, loc)
    call2.value.call = {
        name = { kind = ValueKind::GLOBAL, name = "free" } !Value,
        ret = NO_VALUE,
        args = args2
    }
    push_insn(call2, state)

    let exit_label = make_label(state)
    br1.value.br.if_true = exit_label
    br2.value.br.if_false = exit_label

    let br_unc = make_insn_dbg(InsnKind::BR_UNC, loc)
    br_unc.value.br_unc.label_ = exit_label
    push_insn(br_unc, state)

    push_label(exit_label, state)
}

def increase_pointer_by_one(value: Value, loc: *Value, state: *State) {
    let load2_ret = make_local_value(builtins::int64_, null, state)
    let load2 = make_insn_dbg(InsnKind::LOAD, loc)
    load2.value.load = {
        value = load2_ret,
        loc = value
    } !InsnLoad
    push_insn(load2, state)

    let add_ret = make_local_value(builtins::int64_, null, state)
    let add = make_insn_dbg(InsnKind::ADD, loc)
    add.value.arith = {
        ret = add_ret,
        left = load2_ret,
        right = { kind = ValueKind::INT, tpe = builtins::int64_, i = 1 } !Value
    } !InsnArithmetic
    push_insn(add, state)

    let store1 = make_insn_dbg(InsnKind::STORE, loc)
    store1.value.store = {
        loc = value,
        value = add_ret
    } !InsnStore
    push_insn(store1, state)
}

def increase_ref_count_of_value(value: Value, loc: *Value, state: *State) {
    let index = allocate(int, 1)
    index[0] = 0

    let extract_ret = make_local_value(typechecking::pointer(builtins::int64_), null, state)
    let extract = make_insn_dbg(InsnKind::EXTRACTVALUE, loc)
    extract.value.extract_value = {
        ret = extract_ret,
        value = value,
        index = index
    } !InsnExtractValue
    push_insn(extract, state)

    increase_pointer_by_one(extract_ret, loc, state)
}
 
def increase_ref_count(value: Value, loc: *Value, state: *State) {
    let index1 = allocate(Value, 2)
    index1[0] = make_int_value(0)
    index1[1] = make_int_value(0)
    
    let gep1_ret = make_local_value(typechecking::pointer(typechecking::pointer(builtins::int64_)), null, state)
    let gep1 = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    gep1.value.gep = {
        ret = gep1_ret,
        tpe = value.tpe.tpe,
        value = value,
        index = index1
    } !InsnGetElementPtr
    push_insn(gep1, state)

    let load1_ret = make_local_value(typechecking::pointer(builtins::int64_), null, state)
    let load1 = make_insn_dbg(InsnKind::LOAD, loc)
    load1.value.load = {
        value = load1_ret,
        loc = gep1_ret
    } !InsnLoad
    push_insn(load1, state)

    increase_pointer_by_one(load1_ret, loc, state)
}

def assign_ref(value: Value, addr: Value, loc: *Value, state: *State) {
    if not value.addr { return }

    // First increase the ref count of the assigned value
    increase_ref_count(@value.addr, loc, state)

    // Now decrease the ref count of the stored value
    decrease_ref_count(addr, loc, state)

    // Set the values for the new reference
    let index1 = allocate(Value, 2)
    index1[0] = make_int_value(0)
    index1[1] = make_int_value(0)

    let gep1_ret = make_local_value(typechecking::pointer(typechecking::pointer(builtins::int64_)), null, state)
    let gep1 = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    gep1.value.gep = {
        ret = gep1_ret,
        tpe = value.tpe,
        value = value,
        index = index1
    } !InsnGetElementPtr
    push_insn(gep1, state)

    let load1_ret = make_local_value(typechecking::pointer(builtins::int64_), null, state)
    let load1 = make_insn_dbg(InsnKind::LOAD, loc)
    load1.value.load = {
        value = load1_ret,
        loc = gep1_ret
    } !InsnLoad
    push_insn(load1, state)
    
    let gep2_ret = make_local_value(typechecking::pointer(typechecking::pointer(builtins::int64_)), null, state)
    let gep2 = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    gep2.value.gep = {
        ret = gep2_ret,
        tpe = addr.tpe.tpe,
        value = addr,
        index = index1
    } !InsnGetElementPtr
    push_insn(gep2, state)

    let index3 = allocate(Value, 2)
    index3[0] = make_int_value(0)
    index3[1] = make_int_value(1)

    let gep3_ret = make_local_value(typechecking::pointer(typechecking::pointer(addr.tpe.tpe.tpe)), null, state)
    let gep3 = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    gep3.value.gep = {
        ret = gep3_ret,
        tpe = addr.tpe.tpe,
        value = addr,
        index = index3
    } !InsnGetElementPtr
    push_insn(gep3, state)

    let index4 = allocate(Value, 2)
    index4[0] = make_int_value(0)
    index4[1] = make_int_value(2)

    let gep4_ret = make_local_value(typechecking::pointer(typechecking::pointer(builtins::Type_)), null, state)
    let gep4 = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    gep4.value.gep = {
        ret = gep4_ret,
        tpe = addr.tpe.tpe,
        value = addr,
        index = index4
    } !InsnGetElementPtr
    push_insn(gep4, state)

    let gep5_ret = make_local_value(typechecking::pointer(typechecking::pointer(value.tpe.tpe)), null, state)
    let gep5 = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    gep5.value.gep = {
        ret = gep5_ret,
        tpe = value.tpe,
        value = @value.addr,
        index = index3
    } !InsnGetElementPtr
    push_insn(gep5, state)

    let gep6_ret = make_local_value(typechecking::pointer(typechecking::pointer(builtins::Type_)), null, state)
    let gep6 = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    gep6.value.gep = {
        ret = gep6_ret,
        tpe = value.tpe,
        value = @value.addr,
        index = index4
    } !InsnGetElementPtr
    push_insn(gep6, state)

    let load3_ret = make_local_value(typechecking::pointer(value.tpe.tpe), null, state)
    let load3 = make_insn_dbg(InsnKind::LOAD, loc)
    load3.value.load = {
        value = load3_ret,
        loc = gep5_ret
    } !InsnLoad
    push_insn(load3, state)

    let bitcast_ret = make_local_value(typechecking::pointer(addr.tpe.tpe.tpe), null, state)
    let bitcast = make_insn_dbg(InsnKind::BITCAST, loc)
    bitcast.value.convert = {
        ret = bitcast_ret,
        value = load3_ret
    }
    push_insn(bitcast, state)

    let load4_ret = make_local_value(typechecking::pointer(builtins::Type_), null, state)
    let load4 = make_insn_dbg(InsnKind::LOAD, loc)
    load4.value.load = {
        value = load4_ret,
        loc = gep6_ret
    } !InsnLoad
    push_insn(load4, state)

    let store2 = make_insn_dbg(InsnKind::STORE, loc)
    store2.value.store = {
        loc = gep2_ret,
        value = load1_ret
    } !InsnStore
    push_insn(store2, state)

    let store3 = make_insn_dbg(InsnKind::STORE, loc)
    store3.value.store = {
        loc = gep3_ret,
        value = bitcast_ret
    } !InsnStore
    push_insn(store3, state)

    let store4 = make_insn_dbg(InsnKind::STORE, loc)
    store4.value.store = {
        loc = gep4_ret,
        value = load4_ret
    } !InsnStore
    push_insn(store4, state)
}

def walk_Assign(node: *parser::Node, state: *State) -> Value {
    // TODO Make this possible: a, b = c, d = e, f
    // Right now we can only return one value

    let loc = make_location(node, state)
    let right = (@node).value.assign.right
    let left = (@node).value.assign.left
    var last_value = NO_VALUE

    var j = 0
    for var i in 0..vector::length(right) {
        let n = vector::get(right, i) !*parser::Node
        if not n { break }
        var value = walk_and_load_expression(n, state)
        let tpe = (@n).tpe
        if not tpe { continue }
        if tpe.kind == typechecking::TypeKind::TUPLE {
            for var k in 0..vector::length(tpe.return_t) {
                let t = vector::get(tpe.return_t, k) !*typechecking::Type
                if j >= vector::length(left) { return NO_VALUE }
                let l = vector::get(left, j) !*parser::Node

                let addr = walk_expression(l, state).addr
                if not addr {
                    errors::errorn(l, "Can't assign, expression has no address")
                    return NO_VALUE
                }

                if l.svalue and l.svalue.name == "_" {
                    let alloca = make_insn_dbg(InsnKind::ALLOCA, loc)
                    alloca.value.alloca = {
                        ret = { kind = ValueKind::LOCAL, name = l.svalue.assembly_name, tpe = l.svalue.tpe } !Value
                    } !InsnAlloca
                    push_alloca(alloca, state)
                }

                let gep_ret = make_local_value(typechecking::pointer(t), null, state)

                let index = allocate(Value, 2)
                index[0] = make_int_value(0)
                index[1] = make_int_value(k)

                let gep = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
                (@gep).value.gep = {
                    ret = gep_ret,
                    tpe = value.tpe,
                    value = @value.addr,
                    index = index
                } !InsnGetElementPtr

                push_insn(gep, state)
                
                var ret = gep_ret

                if not typechecking::is_ref(l.tpe) {
                    let gep_retp = allocate(Value)
                    @gep_retp = gep_ret
                    ret = make_local_value(t, gep_retp, state)

                    let load = make_insn_dbg(InsnKind::LOAD, loc)
                    (@load).value.load = {
                        value = ret,
                        loc = gep_ret
                    } !InsnLoad

                    push_insn(load, state)
                }
                
                ret = convert_to(n, ret, (@l).tpe, state)

                if typechecking::is_ref(l.tpe) and typechecking::is_ref(ret.tpe) {
                    assign_ref(ret, @addr, loc, state)
                } else {
                    if typechecking::is_ref(l.tpe) {
                        decrease_ref_count(@addr, loc, state)
                    }

                    let store = make_insn_dbg(InsnKind::STORE, loc)
                    (@store).value.store = {
                        value = ret,
                        loc = @addr
                    } !InsnStore

                    push_insn(store, state)

                    if typechecking::is_ref(l.tpe) {
                        increase_ref_count(@addr, loc, state)
                    }
                }
                
                last_value = ret
                j += 1
            }
        } else {
            if j >= vector::length(left) { return NO_VALUE }
            let l = vector::get(left, j) !*parser::Node
            let addr = walk_expression(l, state).addr
            if not addr { 
                errors::errorn(l, "Can't assign, expression has no address")
                return NO_VALUE 
            }

            if l.svalue and l.svalue.name == "_" {
                let alloca = make_insn_dbg(InsnKind::ALLOCA, loc)
                alloca.value.alloca = {
                    ret = { kind = ValueKind::LOCAL, name = l.svalue.assembly_name, tpe = l.svalue.tpe } !Value
                } !InsnAlloca
                push_alloca(alloca, state)
            }

            value = convert_to(n, value, (@l).tpe, state)

            if typechecking::is_ref(l.tpe) and value.addr and typechecking::is_ref(value.addr.tpe) {
                assign_ref(@value.addr, @addr, loc, state)
            } else {
                if typechecking::is_ref(l.tpe) {
                    decrease_ref_count(@addr, loc, state)
                }

                let store = make_insn_dbg(InsnKind::STORE, loc)
                (@store).value.store = {
                    value = value,
                    loc = @addr
                } !InsnStore

                push_insn(store, state)

                if typechecking::is_ref(l.tpe) {
                    increase_ref_count(@addr, loc, state)
                }
            }

            last_value = value
            j += 1
        }
    }
    return last_value
}

def walk_AssignEq(node: *parser::Node, state: *State) -> Value {
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right

    var kind: parser::NodeKind
    switch (@node).kind !int {
        case parser::NodeKind::PADD_EQ: kind = parser::NodeKind::PADD
        case parser::NodeKind::PSUB_EQ: kind = parser::NodeKind::PSUB
        case parser::NodeKind::ADD_EQ:  kind = parser::NodeKind::ADD
        case parser::NodeKind::SUB_EQ:  kind = parser::NodeKind::SUB
        case parser::NodeKind::MUL_EQ:  kind = parser::NodeKind::MUL
        case parser::NodeKind::DIV_EQ:  kind = parser::NodeKind::DIV
        case parser::NodeKind::MOD_EQ:  kind = parser::NodeKind::MOD
        case parser::NodeKind::AND_EQ:  kind = parser::NodeKind::BAND
        case parser::NodeKind::OR_EQ:   kind = parser::NodeKind::BOR
        case parser::NodeKind::XOR_EQ:  kind = parser::NodeKind::BXOR
        case parser::NodeKind::SHL_EQ:  kind = parser::NodeKind::SHL
        case parser::NodeKind::SHR_EQ:  kind = parser::NodeKind::SHR
        case: assert(false)
    }

    let arithmetic = allocate(parser::Node)
    @arithmetic = {
        kind = kind,
        loc = (@node).loc,
        scope = (@node).scope,
        tpe = (@node).tpe
    } !parser::Node
    
    arithmetic.value.bin_op = {
        left = left,
        right = right
    } !parser::NodeBinaryOp

    let left_vec = vector::make()
    vector::push(left_vec, left)
    let right_vec = vector::make()
    vector::push(right_vec, arithmetic)

    let assign_eq_node = allocate(parser::Node)
    @assign_eq_node = {
        kind = parser::NodeKind::ASSIGN,
        loc = (@node).loc,
        scope = (@node).scope
    }
    
    assign_eq_node.value.assign = {
        left = left_vec,
        right = right_vec
    } !parser::NodeAssign

    return walk_and_load_expression(assign_eq_node, state)
}

def walk_Deref(node: *parser::Node, state: *State) -> Value {
    let loc = make_location(node, state)
    var value = walk_and_load_expression((@node).value.expr, state)
    let tpe = value.tpe
    if not tpe { return NO_VALUE }

    if typechecking::is_ref(tpe) {
        let index = allocate(int, 1)
        index[0] = 1
        let extract_ret = make_local_value(typechecking::pointer(tpe.tpe), null, state)
        let extract = make_insn_dbg(InsnKind::EXTRACTVALUE, make_location(node, state))
        extract.value.extract_value = {
            ret = extract_ret,
            value = value,
            index = index
        } !InsnExtractValue
        push_insn(extract, state)

        value = extract_ret
    }

    let addr = allocate(Value)
    (@addr) = value
    let ret = make_address_value(tpe.tpe, addr, state)
    return ret
}

def walk_Ptr(node: *parser::Node, state: *State) -> Value {
    let value = walk_expression((@node).value.expr, state)
    if not value.addr { return NO_VALUE }

    return @(value.addr)
}

def walk_MemberAccess_gep(node: *parser::Node, tpe: *typechecking::Type, 
    mtpe: *typechecking::Type, value: Value, index: [Value], state: *State) -> Value {

    let loc = make_location(node, state)
    let gep_ret = make_local_value(typechecking::pointer(mtpe), null, state) 
    let gep = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    (@gep).value.gep = {
        ret = gep_ret,
        tpe = tpe,
        value = @value.addr,
        index = index
    } !InsnGetElementPtr
    push_insn(gep, state)

    let addr = allocate(Value)
    @addr = gep_ret

    let ret = make_address_value(mtpe, addr, state)
    return ret
}

type Member = struct {
    index: int
    tpe: *typechecking::Type
}

// This list needs to be reversed to find the actual indices
def resolve_member(vec: *vector::Vector, tpe: *typechecking::Type, name: string) -> bool {
    let fields = tpe.fields
    for var i in 0..fields.size {
        let field = fields[i]
        if length(field.name) > 0 {
            if field.name == name {
                let member = allocate(Member)
                @member = {
                    index = i,
                    tpe = field.tpe
                } !Member
                vector::push(vec, member)
                return true
            }
        } else {
            let found = resolve_member(vec, field.tpe, name)
            if found {
                let member = allocate(Member)
                @member = {
                    index = i,
                    tpe = field.tpe
                } !Member
                vector::push(vec, member)
                return true
            }
        }
    }
    return false
}

def walk_MemberAccess_struct(node: *parser::Node, tpe: *typechecking::Type, member: *Member, value: Value, state: *State) -> Value {
    let loc = make_location(node, state)
    
    if tpe.kind == typechecking::TypeKind::UNION {

        let index = allocate(Value, 3)
        index[0] = make_int_value(0)
        index[1] = make_int_value(0)
        index[2] = make_int_value(0)

        let gep_ret = make_local_value(typechecking::pointer(builtins::char_), null, state)
        let gep = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
        (@gep).value.gep = {
            ret = gep_ret,
            tpe = tpe,
            value = @value.addr,
            index = index
        } !InsnGetElementPtr
        push_insn(gep, state)

        let bitcast_ret = make_local_value(typechecking::pointer((@member).tpe), null, state)
        let bitcast = make_insn_dbg(InsnKind::BITCAST, loc)
        (@bitcast).value.convert = {
            ret = bitcast_ret,
            value = gep_ret
        } !InsnConvert
        push_insn(bitcast, state)

        let addr = allocate(Value)
        (@addr) = bitcast_ret
        let ret = make_address_value((@member).tpe, addr, state)
        return ret
    } else {
        let index = allocate(Value, 2)
        index[0] = make_int_value(0)
        index[1] = make_int_value((@member).index)
        return walk_MemberAccess_gep(node, tpe, (@member).tpe, value, index, state)
    }
}

def walk_MemberAccess(node: *parser::Node, state: *State) -> Value {
    let loc = make_location(node, state)
    if not (@node).tpe { return NO_VALUE }

    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    var tpe = (@left).tpe

    var value = walk_expression(left, state)
    if not value.addr {
        if typechecking::equals(value.tpe, typechecking::pointer(builtins::Type_)) {
            // TODO This should be handled in typechecking
            value.addr = allocate(Value)
            @value.addr = value
        } else {
            errors::errorn(node, "Can't use member access, expression has no address")
            return NO_VALUE
        }
    }

    // TODO This might double error
    let name = typechecking::last_ident_to_str(right)

    if tpe.kind == typechecking::TypeKind::STATIC_ARRAY {
        if name == "size" {
            let i = make_int_value(tpe.length !int)
            i.tpe = builtins::size_t_
            return i
        } else if name == "value" {
            let index = allocate(Value, 2)
            index[0] = make_int_value(0)
            index[0].tpe = builtins::size_t_
            index[1] = make_int_value(0)
            index[1].tpe = builtins::size_t_

            let gep_ret = make_local_value((@node).tpe, null, state)
            let gep = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
            (@gep).value.gep = {
                ret = gep_ret,
                tpe = tpe,
                value = @value.addr,
                index = index
            } !InsnGetElementPtr

            push_insn(gep, state)
            return gep_ret
        } else { assert(false) }
    } else if tpe.kind == typechecking::TypeKind::ARRAY {
        let index = allocate(Value, 2)
        index[0] = make_int_value(0)

        if name == "size" {
            index[1] = make_int_value(0)
        } else if name == "value" {
            index[1] = make_int_value(1)
        } else {
            assert(false)
        }

        return walk_MemberAccess_gep(node, tpe, (@node).tpe, value, index, state)
    } else {
        let vec = vector::make()
        if not resolve_member(vec, tpe, name) {
            assert(false)
        }
        let len = vector::length(vec)
        for var i in 0..len {
            let j = len - i - 1
            let member = vector::get(vec, j) !*Member
            value = walk_MemberAccess_struct(node, tpe, member, value, state)
            tpe = (@member).tpe
        }
        return value
    }
}

// TODO Lots of duplicate code
def walk_ArraySubscript(node: *parser::Node, state: *State) -> Value {
    if not (@node).tpe { return NO_VALUE }
    let loc = make_location(node, state)

    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right
    
    let array_tpe = (@left).tpe
    var left_value = walk_expression(left, state)
    let right_value = walk_and_load_expression(right, state)

    if (@array_tpe).kind == typechecking::TypeKind::ARRAY {
        let index1 = allocate(Value, 2)
        index1[0] = make_int_value(0)
        index1[1] = make_int_value(1)

        let gep_ret1 = make_local_value(typechecking::pointer(typechecking::pointer((@node).tpe)), null, state)
        
        let gep1 = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
        (@gep1).value.gep = {
            ret = gep_ret1,
            tpe = array_tpe,
            value = @left_value.addr,
            index = index1
        } !InsnGetElementPtr

        let load1_value = make_local_value(typechecking::pointer((@node).tpe), null, state)

        let load1 = make_insn_dbg(InsnKind::LOAD, loc)
        (@load1).value.load = {
            value = load1_value,
            loc = gep_ret1
        } !InsnLoad

        let index2 = allocate(Value, 1)
        index2[0] = right_value

        let gep_ret2 = make_local_value(typechecking::pointer((@node).tpe), null, state)

        let gep2 = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
        (@gep2).value.gep = {
            ret = gep_ret2,
            tpe = (@node).tpe,
            value = load1_value,
            index = index2
        } !InsnGetElementPtr
        
        let addr = allocate(Value)
        (@addr) = gep_ret2
        let ret = make_address_value((@node).tpe, addr, state)

        push_insn(gep1, state)
        push_insn(load1, state)
        push_insn(gep2, state)
        
        return ret
    } else if (@array_tpe).kind == typechecking::TypeKind::STATIC_ARRAY {  
        var index = allocate(Value, 2)
        index[0] = make_int_value(0)
        index[1] = right_value

        let gep_ret = make_local_value(typechecking::pointer((@node).tpe), null, state)

        let gep = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
        (@gep).value.gep = {
            ret = gep_ret,
            tpe = array_tpe,
            value = @left_value.addr,
            index = index
        } !InsnGetElementPtr

        let addr = allocate(Value)
        (@addr) = gep_ret
        let ret = make_address_value((@node).tpe, addr, state)

        push_insn(gep, state)
        return ret
    } else if typechecking::is_pointer(array_tpe) {
        left_value = load_value(node, left_value, state)

        var index = allocate(Value, 1)
        index[0] = right_value

        let gep_ret = make_local_value(typechecking::pointer((@node).tpe), null, state)

        let gep = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
        (@gep).value.gep = {
            ret = gep_ret,
            tpe = (@node).tpe,
            value = left_value,
            index = index
        } !InsnGetElementPtr

        let addr = allocate(Value)
        (@addr) = gep_ret
        let ret = make_address_value((@node).tpe, addr, state)

        push_insn(gep, state)        
        return ret
    } else {
        assert(false)
    }
}

def walk_SizeOf(node: *parser::Node, state: *State) -> Value {
    if not node.value.expr { return NO_VALUE }
    var tpe = (@(@node).value.expr).tpe
    if not tpe {
        errors::errorn(node, "Invalid expression")
        return NO_VALUE
    }
    let value = make_int_value(tpe.size !int)
    value.tpe = builtins::size_t_
    
    return value
}

def walk_AlignOf(node: *parser::Node, state: *State) -> Value {
    if not node.value.expr { return NO_VALUE }
    var tpe = (@(@node).value.expr).tpe
    if not tpe {
        errors::errorn(node, "Invalid expression")
        return NO_VALUE
    }
    let value = make_int_value(tpe.align !int)
    value.tpe = builtins::size_t_
    
    return value
}

def compare(node: *parser::Node, left: Value, right: Value, state: *State) -> Value {
    if not left.tpe or not right.tpe { return NO_VALUE }
    let loc = make_location(node, state)

    if typechecking::equals(left.tpe, right.tpe) { 
        if typechecking::equals(left.tpe, builtins::string_) {
            map::put((@(@state).module).imported, "strcmp", map::sentinel)

            let args = allocate(Value, 2)
            args[0] = charp_str(left, state)
            args[1] = charp_str(right, state)

            let call_ret = make_local_value(builtins::int_, null, state)
            let call = make_insn_dbg(InsnKind::CALL, loc)
            (@call).value.call = {
                name = {
                    kind = ValueKind::GLOBAL,
                    name = "strcmp"
                } !Value,
                ret = call_ret,
                args = args
            } !InsnCall
            push_insn(call, state)

            var op: CompareInt
            switch (@node).kind !int {
                case parser::NodeKind::EQ:  op = CompareInt::eq
                case parser::NodeKind::NEQ: op = CompareInt::ne
                case parser::NodeKind::GT:  op = CompareInt::ugt
                case parser::NodeKind::LT:  op = CompareInt::ult
                case parser::NodeKind::GEQ: op = CompareInt::uge
                case parser::NodeKind::LEQ: op = CompareInt::ule
                case: assert(false)
            }

            let cmp_ret = make_local_value(builtins::bool_, null, state)
            let cmp = make_insn_dbg(InsnKind::ICMP, loc)
            (@cmp).value.icmp = {
                op = op,
                ret = cmp_ret,
                left = call_ret,
                right = {
                    kind = ValueKind::INT,
                    tpe = builtins::int_,
                    i = 0
                } !Value
            } !InsnIcmp
            push_insn(cmp, state)

            return cmp_ret
            // TODO There might be better ways of handling this
        } else if builtins::Type_ and typechecking::equals(left.tpe, typechecking::pointer(builtins::Type_)) {
            let svalue = scope::get(toolchain::runtime.scope, parser::make_identifier(["equals"]))
            predeclare_function(svalue.tpe, state.module)
            map::put(state.module.imported, svalue.tpe.type_name, map::sentinel)

            let args = allocate(Value, 2)
            args[0] = left
            args[1] = right

            let call_ret = make_local_value(builtins::bool_, null, state)
            let call = make_insn_dbg(InsnKind::CALL, loc)
            call.value.call = {
                name = { kind = ValueKind::GLOBAL, name = svalue.tpe.type_name } !Value,
                ret = call_ret,
                args = args
            } !InsnCall
            push_insn(call, state)

            var ret: Value
            if node.kind == parser::NodeKind::NEQ {
                ret = make_local_value(builtins::bool_, null, state)
                let xor = make_insn_dbg(InsnKind::XOR, loc)
                (@xor).value.arith = {
                    ret = ret,
                    left = call_ret,
                    right = { kind = ValueKind::BOOL, i = 1, tpe = builtins::bool_ } !Value
                } !InsnArithmetic
                push_insn(xor, state)
            } else if node.kind == parser::NodeKind::EQ {
                ret = call_ret
            } else {
                errors::errorn(node, "Can't compare types")
                return NO_VALUE
            }

            return ret
        }
    }

    var tpe: *typechecking::Type = null
    if typechecking::is_enum(left.tpe) {
        left.tpe = (@left.tpe).tpe
    }
    if typechecking::is_enum(right.tpe) {
        right.tpe = (@right.tpe).tpe
    }
    if typechecking::is_pointer(left.tpe) {
        // TODO We need something like intptr_t, but for now size_t will suffice
        left = convert_to(node, left, builtins::size_t_, state)
    }
    if typechecking::is_pointer(right.tpe) {
        right = convert_to(node, right, builtins::size_t_, state)
    }
    if (@left.tpe).kind == typechecking::TypeKind::NULL {
        left = make_int_value(0)
        left.tpe = builtins::size_t_
    }
    if (@right.tpe).kind == typechecking::TypeKind::NULL {
        right = make_int_value(0)
        right.tpe = builtins::size_t_
    }
    if typechecking::is_arithmetic(left.tpe) and typechecking::is_arithmetic(right.tpe) {
        tpe = typechecking::common_type(left.tpe, right.tpe)
        if not tpe {
            errors::errorn(node, "Can't compare ", debug::type_to_str(left.tpe), " and ", debug::type_to_str(right.tpe))
            return NO_VALUE
        }

        left = convert_to(node, left, tpe, state)
        right = convert_to(node, right, tpe, state)

        let ret = make_local_value((@node).tpe, null, state)

        var insn: *Insn = null
        if typechecking::is_float(tpe) {
            var op: CompareFloat
            switch (@node).kind !int {
                case parser::NodeKind::EQ:  op = CompareFloat::ueq
                case parser::NodeKind::NEQ: op = CompareFloat::une
                case parser::NodeKind::GT:  op = CompareFloat::ugt
                case parser::NodeKind::LT:  op = CompareFloat::ult
                case parser::NodeKind::GEQ: op = CompareFloat::uge
                case parser::NodeKind::LEQ: op = CompareFloat::ule
                case: assert(false)
            }
            insn = make_insn_dbg(InsnKind::FCMP, loc)
            (@insn).value.fcmp = {
                op = op,
                ret = ret,
                left = left,
                right = right
            } !InsnFcmp
        } else {
            var op: CompareInt
            if tpe.unsig {
                switch (@node).kind !int {
                    case parser::NodeKind::EQ:  op = CompareInt::eq
                    case parser::NodeKind::NEQ: op = CompareInt::ne
                    case parser::NodeKind::GT:  op = CompareInt::ugt
                    case parser::NodeKind::LT:  op = CompareInt::ult
                    case parser::NodeKind::GEQ: op = CompareInt::uge
                    case parser::NodeKind::LEQ: op = CompareInt::ule
                    case: assert(false)
                }
            } else {
                switch (@node).kind !int {
                    case parser::NodeKind::EQ:  op = CompareInt::eq
                    case parser::NodeKind::NEQ: op = CompareInt::ne
                    case parser::NodeKind::GT:  op = CompareInt::sgt
                    case parser::NodeKind::LT:  op = CompareInt::slt
                    case parser::NodeKind::GEQ: op = CompareInt::sge
                    case parser::NodeKind::LEQ: op = CompareInt::sle
                    case: assert(false)
                }
            }
            insn = make_insn_dbg(InsnKind::ICMP, loc)
            (@insn).value.icmp = {
                op = op,
                ret = ret,
                left = left,
                right = right
            } !InsnIcmp
        }

        push_insn(insn, state)

        return ret
    }
    return NO_VALUE
}

def walk_ComparisionOp(node: *parser::Node, state: *State) -> Value {
    let loc = make_location(node, state)
    let left = (@node).value.bin_op.left
    let right = (@node).value.bin_op.right

    if not left or not right { return NO_VALUE }
    if not (@left).tpe or not (@right).tpe { return NO_VALUE }

    if (@left).kind >= parser::NodeKind::EQ and (@left).kind <= parser::NodeKind::LEQ {
        let value_left = walk_and_load_expression(left, state)
        // These two values get compared
        let value_leftc = walk_and_load_expression((@left).value.bin_op.right, state)
        let value_rightc = walk_and_load_expression(right, state)
        let value = compare(node, value_leftc, value_rightc, state)
        
        let ret = make_local_value(builtins::bool_, null, state)

        let insn_and = make_insn_dbg(InsnKind::AND, loc)
        (@insn_and).value.arith = {
            ret = ret,
            left = value_left,
            right = value
        } !InsnArithmetic

        push_insn(insn_and, state)

        return ret
    } else {
        let value_left = walk_and_load_expression(left, state)
        let value_right = walk_and_load_expression(right, state)
        return compare(node, value_left, value_right, state)
    }
}

def walk_PointerOp(node: *parser::Node, kind: InsnKind, state: *State) -> Value {
    let loc = make_location(node, state)
    // TODO This is not the correct type
    let value_left = convert_to(node, walk_and_load_expression((@node).value.bin_op.left, state), builtins::size_t_, state)
    let value_right = convert_to(node, walk_and_load_expression((@node).value.bin_op.right, state), builtins::size_t_, state)

    let ret_arith = make_local_value(builtins::size_t_, null, state)

    let arith = make_insn_dbg(kind, loc)
    (@arith).value.arith = {
        ret = ret_arith,
        left = value_left,
        right = value_right
    } !InsnArithmetic
    push_insn(arith, state)

    let ret_inttoptr = make_local_value((@node).tpe, null, state)

    let inttoptr = make_insn_dbg(InsnKind::INTTOPTR, loc)
    (@inttoptr).value.convert = {
        ret = ret_inttoptr,
        value = ret_arith
    } !InsnConvert
    push_insn(inttoptr, state)

    return ret_inttoptr
}

def walk_IfExpr(node: *parser::Node, state: *State) -> Value {
    let loc = make_location(node, state)
    let cond = convert_to(node, walk_and_load_expression(node.value.if_expr.cond, state), builtins::bool_, state)
    let if_true = node.value.if_expr.if_true
    let if_false = node.value.if_expr.if_false

    let ret_alloca = make_named_local(if_true.tpe, null, state)
    let alloca = make_insn_dbg(InsnKind::ALLOCA, loc)
    alloca.value.alloca = {
        ret = ret_alloca
    } !InsnAlloca
    push_insn(alloca, state)
    ret_alloca.tpe = typechecking::pointer(ret_alloca.tpe)

    let entry_label = make_label(state)
    let br = make_insn_dbg(InsnKind::BR, loc)
    br.value.br = {
        cond = cond,
        if_true = entry_label
    } !InsnBr
    push_insn(br, state)
    push_label(entry_label, state)
    
    let true_value = walk_and_load_expression(if_true, state)
    let store1 = make_insn_dbg(InsnKind::STORE, make_location(if_true, state))
    store1.value.store = {
        loc = ret_alloca,
        value = true_value
    }
    push_insn(store1, state)

    let exit = make_insn_dbg(InsnKind::BR_UNC, loc)
    push_insn(exit, state)

    let false_label = make_label(state)
    br.value.br.if_false = false_label
    push_label(false_label, state)

    let false_value = walk_and_load_expression(if_false, state)
    let store2 = make_insn_dbg(InsnKind::STORE, make_location(if_false, state))
    store2.value.store = {
        loc = ret_alloca,
        value = false_value
    }
    push_insn(store2, state)
    push_insn(exit, state)

    let exit_label = make_label(state)
    push_label(exit_label, state)
    exit.value.br_unc.label_ = exit_label

    let addrp = allocate(Value)
    @addrp = ret_alloca

    // TODO This is not really a local
    return { kind = ValueKind::LOCAL, tpe = if_true.tpe, addr = addrp } !Value
}

def walk_Type(node: *parser::Node, state: *State) -> Value {
    let expr = node.value.t_parr.tpe
    node.svalue = change_value_to_type(node.tpe.tpe, state)
    if not node.svalue { return NO_VALUE }
    return @node.svalue.value
}

def walk_TypeOfT(node: *parser::Node, state: *State) -> Value {
    let expr = node.value.expr
    node.svalue = change_value_to_type(expr.tpe, state)
    if not node.svalue { return NO_VALUE }
    return @node.svalue.value
}

export def walk_expression(node: *parser::Node, state: *State) -> Value {
    if not node { return NO_VALUE }
    switch (@node).kind !int {
        case parser::NodeKind::NULL:
            return walk_Null(node, state)
        case parser::NodeKind::IDENTIFIER:
            return walk_Identifier(node, state)
        case parser::NodeKind::INTEGER:
            return walk_Integer(node, state)
        case parser::NodeKind::FLOAT:
            return walk_Float(node, state)
        case parser::NodeKind::BOOLEAN:
            return walk_Boolean(node, state)
        case parser::NodeKind::CHAR:
            return walk_Char(node, state)
        case parser::NodeKind::STRING:
            return walk_String(node, state)
        case parser::NodeKind::SIZE_OF:
            return walk_SizeOf(node, state)
        case parser::NodeKind::ALIGN_OF:
            return walk_AlignOf(node, state)
        case parser::NodeKind::CAST:
            return walk_Cast(node, state)
        case parser::NodeKind::USUB:
            return walk_USub(node, state)
        case parser::NodeKind::UADD:
            return walk_UAdd(node, state)
        case parser::NodeKind::NOT:
            return walk_Not(node, state)
        case parser::NodeKind::AND:
            return walk_And(node, state)
        case parser::NodeKind::OR:
            return walk_Or(node, state)
        case parser::NodeKind::ADD:
            return walk_Add(node, state)
        case parser::NodeKind::SUB:
            return walk_Sub(node, state)
        case parser::NodeKind::MUL:
            return walk_Mul(node, state)
        case parser::NodeKind::MOD:
            return walk_Mod(node, state)
        case parser::NodeKind::DIV:
            return walk_Div(node, state)
        case parser::NodeKind::SHL:
            return walk_Shl(node, state)
        case parser::NodeKind::SHR:
            return walk_Shr(node, state)
        case parser::NodeKind::BAND:
            return walk_BAnd(node, state)
        case parser::NodeKind::BOR:
            return walk_BOr(node, state)
        case parser::NodeKind::BXOR:
            return walk_BXor(node, state)
        case parser::NodeKind::BNOT:
            return walk_BNot(node, state)
        case parser::NodeKind::PADD:
            return walk_PointerOp(node, InsnKind::ADD, state)
        case parser::NodeKind::PSUB:
            return walk_PointerOp(node, InsnKind::SUB, state)
        case parser::NodeKind::EQ..=parser::NodeKind::LEQ:
            return walk_ComparisionOp(node, state)
        case parser::NodeKind::FUNC_CALL:
            return walk_Call(node, state)
        case parser::NodeKind::ASSIGN:
            return walk_Assign(node, state)
        case parser::NodeKind::PADD_EQ..=parser::NodeKind::SHR_EQ:
            return walk_AssignEq(node, state)
        case parser::NodeKind::DEREF:
            return walk_Deref(node, state)
        case parser::NodeKind::PTR:
            return walk_Ptr(node, state)
        case parser::NodeKind::MEMBER_ACCESS:
            return walk_MemberAccess(node, state)
        case parser::NodeKind::ARRAY_SUBSCRIPT:
            return walk_ArraySubscript(node, state)
        case parser::NodeKind::STRUCT_LIT:
            return walk_StructLit(node, state)
        case parser::NodeKind::ARRAY_LIT:
            return walk_ArrayLit(node, state)
        case parser::NodeKind::ARRAY_STATIC_T, parser::NodeKind::PTR_T,
            parser::NodeKind::REF_T, parser::NodeKind::ARRAY_T, parser::NodeKind::FUNCTION_T:
            return walk_Type(node, state)
        case parser::NodeKind::TYPE_OF_T:
            return walk_TypeOfT(node, state)
        case parser::NodeKind::IF_EXPR:
            return walk_IfExpr(node, state)
        case:
            error((@node).kind, "\n")
            assert(false)
    }
}

def walk_If(node: *parser::Node, state: *State) {
    let loc = make_location(node, state)

    let cond = convert_to((@node).value.if_.cond, walk_and_load_expression((@node).value.if_.cond, state), builtins::bool_, state)
    let entry_label = make_label(state)
    var entry = make_insn_dbg(InsnKind::BR, loc)
    (@entry).value.br = {
        cond = cond,
        if_true = entry_label
    } !InsnBr

    let exit = make_insn_dbg(InsnKind::BR_UNC, loc)

    push_insn(entry, state)
    push_label(entry_label, state)
    push_scope(node, state)
    var last_node = node
    for var i in 0..vector::length((@node).value.if_.body) {
        let stmt = vector::get((@node).value.if_.body, i) !*parser::Node
        walk(stmt, state)
        last_node = stmt
    }
    decrease_ref_count_scoped(node.inner_scope, make_location(last_node, state), state)
    pop_scope(state)
    push_insn(exit, state)

    for var i in 0..vector::length((@node).value.if_.else_if) {
        let br_label = make_label(state)
        (@entry).value.br.if_false = br_label
        push_label(br_label, state)
        
        let else_if = vector::get((@node).value.if_.else_if, i) !*parser::Node
        let cond = convert_to((@else_if).value.else_if.cond, walk_and_load_expression((@else_if).value.else_if.cond, state), builtins::bool_, state)

        entry = make_insn_dbg(InsnKind::BR, make_location(else_if, state))
        (@entry).value.br = {
            cond = cond
        } !InsnBr
        push_insn(entry, state)
        let entry_label = make_label(state)
        (@entry).value.br.if_true = entry_label

        push_label(entry_label, state)
        push_scope(else_if, state)
        var last_node = else_if
        for var i in 0..vector::length((@else_if).value.else_if.body) {
            let stmt = vector::get((@else_if).value.else_if.body, i) !*parser::Node
            walk(stmt, state)
            last_node = stmt
        }
        decrease_ref_count_scoped(else_if.inner_scope, make_location(last_node, state), state)
        pop_scope(state)
        push_insn(exit, state)
    }

    let else_ = (@node).value.if_.else_
    if else_ {
        let entry_label = make_label(state)
        (@entry).value.br.if_false = entry_label
        push_label(entry_label, state)
        push_scope(else_, state)
        var last_node = else_
        for var i in 0..vector::length((@else_).value.body) {
            let stmt = vector::get((@else_).value.body, i) !*parser::Node
            walk(stmt, state)
            last_node = stmt
        }
        decrease_ref_count_scoped(node.inner_scope, make_location(last_node, state), state)
        pop_scope(state)
        push_insn(exit, state)
    }

    let exit_label = make_label(state)
    if not else_ {
        (@entry).value.br.if_false = exit_label
    }
    (@exit).value.br_unc.label_ = exit_label
    push_label(exit_label, state)
}

let max_cases = 25

def walk_Switch(node: *parser::Node, state: *State) {
    let loc = make_location(node, state)
    let swexpr = walk_and_load_expression((@node).value.switch_.expr, state)
    let tpe = (@(@node).value.switch_.expr).tpe
    
    let switch_values = vector::make()
    let swtch = make_insn_dbg(InsnKind::SWITCH, loc)
    (@swtch).value.switch_ = {
        value = swexpr,
        switch_values = switch_values
    } !InsnSwitch
    push_insn(swtch, state)

    let end = make_insn_dbg(InsnKind::BR_UNC, loc)

    var otherwise: *parser::Node = null
    let if_stmts = vector::make()

    // TODO We need to check if the ranges overlap
    for var i in 0..vector::length((@node).value.switch_.body) {
        let cse = vector::get((@node).value.switch_.body, i) !*parser::Node
        let len = vector::length((@cse).value.case_.expr)

        if len == 0 {
            if otherwise {
                errors::errorn(cse, "More than one default case")
                return
            } else {
                otherwise = cse
            }
        } else {
            var out_of_bounds = false
            for var j in 0..len {
                let expr = vector::get((@cse).value.case_.expr, j) !*parser::Node
                if (@expr).kind == parser::NodeKind::RANGE or
                    (@expr).kind == parser::NodeKind::RANGE_INC {
                    let left = (@expr).value.bin_op.left
                    let right = (@expr).value.bin_op.right
                    var min = left.svalue.value.i
                    var max = right.svalue.value.i
                    if (max >= min) and (max - min > max_cases) {
                        vector::push(if_stmts, cse)
                        out_of_bounds = true
                        break
                    }
                }
            }
            if not out_of_bounds {
                let start = make_label(state)
                push_label(start, state)

                for var j in 0..len {
                    let expr = vector::get((@cse).value.case_.expr, j) !*parser::Node
                    if (@expr).kind == parser::NodeKind::RANGE or
                        (@expr).kind == parser::NodeKind::RANGE_INC {
                        let left = (@expr).value.bin_op.left
                        let right = (@expr).value.bin_op.right
                        var min = left.svalue.value.i
                        var max = right.svalue.value.i
                        if (max >= min) {
                            if (@expr).kind == parser::NodeKind::RANGE_INC {
                                max += 1
                            }
                            for var k in min..max {
                                let svalue = allocate(SwitchValue)
                                (@svalue).label_ = start
                                (@svalue).value = { kind = ValueKind::INT, i = k, tpe = tpe } !Value
                                vector::push(switch_values, svalue)
                            } 
                        } else {
                            errors::errorn(expr, "Invalid range")
                            return
                        }
                    } else {
                        let value = expr.svalue.value.i
                        let svalue = allocate(SwitchValue)
                        (@svalue).label_ = start
                        (@svalue).value = { kind = ValueKind::INT, i = value, tpe = tpe } !Value
                        vector::push(switch_values, svalue)
                    }
                }
                
                push_scope(cse, state)
                for var j in 0..vector::length((@cse).value.case_.body) {
                    let expr = vector::get((@cse).value.case_.body, j) !*parser::Node
                    walk(expr, state)
                }
                pop_scope(state)

                push_insn(end, state)
            }
        }  
    }

    let olabel = make_label(state)
    push_label(olabel, state)

    for var i in 0..vector::length(if_stmts) {
        let cse = vector::get(if_stmts, i) !*parser::Node
        let len = vector::length((@cse).value.case_.expr)

        let brs = vector::make()
        var last: *Insn = null
        for var j in 0..len {
            if last {
                let lbl = make_label(state)
                push_label(lbl, state)
                (@last).value.br.if_false = lbl
            }
            let expr = vector::get((@cse).value.case_.expr, j) !*parser::Node
            if (@expr).kind == parser::NodeKind::RANGE or 
                (@expr).kind == parser::NodeKind::RANGE_INC {
                let left = (@expr).value.bin_op.left
                let right = (@expr).value.bin_op.right
                var min = left.svalue.value.i
                var max = right.svalue.value.i

                if max < min {
                    errors::errorn(expr, "Invalid range")
                    return
                }
                
                let sub_ret = make_local_value(tpe, null, state)
                let sub = make_insn_dbg(InsnKind::SUB, loc)
                (@sub).value.arith = {
                    ret = sub_ret,
                    left = swexpr,
                    right = { kind = ValueKind::INT, i = min, tpe = tpe } !Value
                } !InsnArithmetic
                push_insn(sub, state)

                var op = CompareInt::ule
                if (@expr).kind == parser::NodeKind::RANGE {
                    op = CompareInt::ult
                }
                let cmp_ret = make_local_value(builtins::bool_, null, state)
                let cmp = make_insn_dbg(InsnKind::ICMP, loc)
                (@cmp).value.icmp = {
                    op = op,
                    ret = cmp_ret,
                    left = sub_ret,
                    right = { kind = ValueKind::INT, i = max - min, tpe = tpe } !Value
                } !InsnIcmp
                push_insn(cmp, state)

                let br = make_insn_dbg(InsnKind::BR, loc)
                (@br).value.br = {
                    cond = cmp_ret
                } !InsnBr
                push_insn(br, state)
                
                last = br
                vector::push(brs, br)
            } else {
                let value = expr.svalue.value.i

                let cmp_ret = make_local_value(builtins::bool_, null, state)
                let cmp = make_insn_dbg(InsnKind::ICMP, loc)
                (@cmp).value.icmp = {
                    op = CompareInt::eq,
                    ret = cmp_ret,
                    left = swexpr,
                    right = { kind = ValueKind::INT, i = value, tpe = tpe } !Value
                } !InsnIcmp
                push_insn(cmp, state)

                let br = make_insn_dbg(InsnKind::BR, loc)
                (@br).value.br = {
                    cond = cmp_ret
                } !InsnBr
                push_insn(br, state)
                
                last = br
                vector::push(brs, br)
            }
        }

        let lbl = make_label(state)
        push_label(lbl, state)

        for var i in 0..vector::length(brs) {
            let br = vector::get(brs, i) !*Insn
            (@br).value.br.if_true = lbl
        }

        push_scope(cse, state)
        var last_node = cse
        for var j in 0..vector::length((@cse).value.case_.body) {
            let expr = vector::get((@cse).value.case_.body, j) !*parser::Node
            walk(expr, state)
            last_node = expr
        }
        decrease_ref_count_scoped(cse.inner_scope, make_location(last_node, state), state)
        pop_scope(state)

        push_insn(end, state)

        if last {
            let lbl = make_label(state)
            push_label(lbl, state)
            (@last).value.br.if_false = lbl
        }
    }

    if otherwise {
        push_scope(otherwise, state)
        for var i in 0..vector::length((@otherwise).value.case_.body) {
            let expr = vector::get((@otherwise).value.case_.body, i) !*parser::Node
            walk(expr, state)
        }
        pop_scope(state)
    }

    push_insn(end, state)
    (@swtch).value.switch_.otherwise = olabel

    let end_label = make_label(state)
    push_label(end_label, state)
    (@end).value.br_unc.label_ = end_label
}

def walk_Return(node: *parser::Node, state: *State) {
    let loc = make_location(node, state)
    let current_function = (@state).current_function
    if not current_function { return }

    var value = NO_VALUE
    if (@current_function).multiple_returns {
        let ret_args = allocate(Value, vector::length((@node).value.body))
        for var i in 0..ret_args.size {
            let n = vector::get((@node).value.body, i) !*parser::Node
            let tpe = (@(@current_function).ret).fields[i].tpe
            ret_args[i] = convert_to(n, walk_and_load_expression(n, state), tpe, state)
        }
        value = {
            kind = ValueKind::STRUCT,
            values = ret_args,
            tpe = (@current_function).ret
        } !Value

        locals_to_insert_value(*value, state)
    } else {
        let tpe = (@current_function).ret
        if tpe {
            let arg = vector::peek((@node).value.body) !*parser::Node
            value = convert_to(arg, walk_and_load_expression(arg, state), tpe, state)
        }
    }

    if current_function.has_defer {
        defer_unroll(node, state)
    }

    var scpe = state.scope
    while not scpe.is_function {
        decrease_ref_count_scoped(scpe, loc, state)
        scpe = scpe.parent 
    }
    //decrease_ref_count_scoped(scpe, loc, state)


    let ret = make_insn_dbg(InsnKind::RET, loc)
    (@ret).value.ret.value = value

    push_insn(ret, state)
    push_label(make_label(state), state)
}

def walk_Break(node: *parser::Node, state: *State) {
    let break_insn = get_break_insn(state)
    if not break_insn {
        errors::errorn(node, "break used outside of a loop")
        return
    }
    push_insn(break_insn, state)
    push_label(make_label(state), state)
}

def walk_Continue(node: *parser::Node, state: *State) {
    let continue_insn = get_continue_insn(state)
    if not continue_insn {
        errors::errorn(node, "continue used outside of a loop")
        return
    }
    push_insn(continue_insn, state)
    push_label(make_label(state), state)
}

def walk_Loop(node: *parser::Node, state: *State) {
    push_loop_state(state)
    let continue_insn = get_continue_insn(state)
    let break_insn = get_break_insn(state)

    push_insn(continue_insn, state)
    let start_label = make_label(state)
    push_label(start_label, state)
    push_scope(node, state)
    var last_node = node
    for var i in 0..vector::length((@node).value.body) {
        let n = vector::get((@node).value.body, i) !*parser::Node
        walk(n, state)
        last_node = n
    }
    decrease_ref_count_scoped(node.inner_scope, make_location(last_node, state), state)
    pop_scope(state)
    push_insn(continue_insn, state)
    let end_label = make_label(state)
    push_label(end_label, state)

    (@continue_insn).value.br_unc.label_ = start_label
    (@break_insn).value.br_unc.label_ = end_label
    pop_loop_state(state)
}

def walk_While(node: *parser::Node, state: *State) {
    let loc = make_location(node, state)
    push_loop_state(state)
    let continue_insn = get_continue_insn(state)
    let break_insn = get_break_insn(state)

    push_insn(continue_insn, state)
    let start_label = make_label(state)
    push_label(start_label, state)

    let cond = convert_to(node, walk_and_load_expression((@node).value.while_loop.expr, state), builtins::bool_, state)
    
    let br = make_insn_dbg(InsnKind::BR, loc)
    (@br).value.br = {
        cond = cond
    } !InsnBr
    
    push_insn(br, state)

    let inner = make_label(state)
    push_label(inner, state)
    (@br).value.br.if_true = inner

    push_scope(node, state)
    var last_node = node
    for var i in 0..vector::length((@node).value.while_loop.body) {
        let n = vector::get((@node).value.while_loop.body, i) !*parser::Node
        walk(n, state)
        last_node = n
    }
    decrease_ref_count_scoped(node.inner_scope, make_location(last_node, state), state)
    pop_scope(state)

    push_insn(continue_insn, state)
    let end_label = make_label(state)
    push_label(end_label, state)
    (@br).value.br.if_false = end_label

    (@continue_insn).value.br_unc.label_ = start_label
    (@break_insn).value.br_unc.label_ = end_label
    pop_loop_state(state)
}

// TODO Allow arrays
// TODO The locations seem off for this
def walk_For(node: *parser::Node, state: *State) {
    let range = (@node).value.for_loop.expr
    assert((@range).kind == parser::NodeKind::RANGE or (@range).kind == parser::NodeKind::RANGE_INC)
    
    var op = CompareInt::slt
    if (@range).kind == parser::NodeKind::RANGE_INC {
        op = CompareInt::sle
    }
    let iddecl = (@node).value.for_loop.iddecl
    let tpe = (@iddecl).tpe

    let left = (@range).value.bin_op.left
    let right = (@range).value.bin_op.right
    let startv = convert_to(left, walk_and_load_expression((@range).value.bin_op.left, state), tpe, state)
    let endv = convert_to(right, walk_and_load_expression(right, state), tpe, state)

    push_scope(node, state)
    let loc = make_location(node, state)
    var locv: Value
    if (@iddecl).kind == parser::NodeKind::FOR_ID_DECL {
        let value = scope::get((@iddecl).scope, (@iddecl).value.for_id_decl.ident)
        if not value { return }

        let ret = {
            kind = ValueKind::LOCAL,
            name = (@value).assembly_name,
            tpe = tpe
        } !Value

        let alloca = make_insn_dbg(InsnKind::ALLOCA, loc)
        (@alloca).value.alloca = {
            ret = ret
        } !InsnAlloca
        push_alloca(alloca, state)

        ret.tpe = typechecking::pointer(tpe)
        push_declare((@iddecl).value.for_id_decl.ident, ret, (@value).name, state)

        locv = {
            kind = ValueKind::LOCAL,
            name = (@value).assembly_name,
            tpe = typechecking::pointer(tpe)
        } !Value
    } else {
        let addr = walk_and_load_expression(iddecl, state).addr
        if not addr { return }
        locv = @addr
    }
    
    let store = make_insn_dbg(InsnKind::STORE, loc)
    (@store).value.store = {
        loc = locv,
        value = startv
    } !InsnStore

    push_insn(store, state)

    push_loop_state(state)
    let continue_insn = get_continue_insn(state)
    let break_insn = get_break_insn(state)
    let start_insn = make_insn_dbg(InsnKind::BR_UNC, loc)

    push_insn(start_insn, state)
    let start_label = make_label(state)
    push_label(start_label, state)

    let load_ret = make_local_value(builtins::int_, null, state)
    let load = make_insn_dbg(InsnKind::LOAD, loc)
    (@load).value.load = {
        value = load_ret,
        loc = locv
    } !InsnLoad

    push_insn(load, state)

    let tpe2 = typechecking::common_type(load_ret.tpe, endv.tpe)
    let left2 = convert_to(node, load_ret, tpe2, state)
    let right2 = convert_to(node, endv, tpe2, state)

    let cmp_ret = make_local_value(builtins::bool_, null, state)
    let cmp = make_insn_dbg(InsnKind::ICMP, loc)
    (@cmp).value.icmp = {
        op = op,
        ret = cmp_ret,
        left = left2,
        right = right2
    } !InsnIcmp

    push_insn(cmp, state)

    let br = make_insn_dbg(InsnKind::BR, loc)
    (@br).value.br = {
        cond = cmp_ret
    } !InsnBr
    
    push_insn(br, state)

    let inner = make_label(state)
    push_label(inner, state)
    (@br).value.br.if_true = inner

    var last_node = node
    for var i in 0..vector::length((@node).value.for_loop.body) {
        let n = vector::get((@node).value.for_loop.body, i) !*parser::Node
        walk(n, state)
        last_node = n
    }
    decrease_ref_count_scoped(node.inner_scope, make_location(last_node, state), state)

    push_insn(continue_insn, state)
    let inc_label = make_label(state)
    push_label(inc_label, state)

    let add_ret = make_local_value(builtins::int_, null, state)
    let add = make_insn_dbg(InsnKind::ADD, loc)
    (@add).value.arith = {
        ret = add_ret,
        left = load_ret,
        right = { kind = ValueKind::INT, i = 1, tpe = builtins::int_ } !Value
    } !InsnArithmetic

    push_insn(add, state)

    let store2 = make_insn_dbg(InsnKind::STORE, loc)
    (@store2).value.store = {
        loc = locv,
        value = add_ret
    } !InsnStore

    push_insn(store2, state)

    push_insn(start_insn, state)
    let end_label = make_label(state)
    push_label(end_label, state)
    (@br).value.br.if_false = end_label

    (@start_insn).value.br_unc.label_ = start_label
    (@continue_insn).value.br_unc.label_ = inc_label
    (@break_insn).value.br_unc.label_ = end_label
    pop_loop_state(state)

    pop_scope(state)
}

def push_ref_init(value: Value, loc: *Value, state: *State) {
    map::put(state.module.imported, "malloc", map::sentinel)
    let ref_tpe = value.tpe.tpe.tpe

    let svalue = do_create_type(value.tpe.tpe, state.module)

    let args = allocate(Value, 1)
    args[0] = make_int_value(builtins::int64_.size !int)
    args[0].tpe = builtins::int64_
    let ret_call = make_local_value(typechecking::pointer(builtins::int8_), null, state)
    let call = make_insn_dbg(InsnKind::CALL, loc)
    call.value.call = {
        name = { kind = ValueKind::GLOBAL, name = "malloc" } !Value,
        ret = ret_call,
        args = args
    } !InsnCall
    push_insn(call, state)

    let bitcast_ret = make_local_value(typechecking::pointer(builtins::int64_), null, state)
    let bitcast = make_insn_dbg(InsnKind::BITCAST, loc)
    bitcast.value.convert = {
        ret = bitcast_ret,
        value = ret_call
    } !InsnConvert
    push_insn(bitcast, state)

    let store1 = make_insn_dbg(InsnKind::STORE, loc)
    store1.value.store = {
        value = { kind = ValueKind::INT, tpe = builtins::int64_, i = 1 } !Value,
        loc = bitcast_ret
    } !InsnStore
    push_insn(store1, state)

    let index1 = allocate(Value, 2)
    index1[0] = make_int_value(0)
    index1[1] = make_int_value(0)

    let ret_gep1 = make_local_value(typechecking::pointer(typechecking::pointer(builtins::int64_)), null, state)
    let gep1 = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    gep1.value.gep = {
        ret = ret_gep1,
        tpe = value.tpe.tpe,
        value = value,
        index = index1
    } !InsnGetElementPtr
    push_insn(gep1, state)

    let store2 = make_insn_dbg(InsnKind::STORE, loc)
    store2.value.store = {
        value = bitcast_ret,
        loc = ret_gep1
    } !InsnStore
    push_insn(store2, state)

    let index2 = allocate(Value, 2)
    index2[0] = make_int_value(0)
    index2[1] = make_int_value(1)

    let ret_gep2 = make_local_value(typechecking::pointer(typechecking::pointer(ref_tpe)), null, state)
    let gep2 = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    gep2.value.gep = {
        ret = ret_gep2,
        tpe = value.tpe.tpe,
        value = value,
        index = index2
    }
    push_insn(gep2, state)

    let store3 = make_insn_dbg(InsnKind::STORE, loc)
    store3.value.store = {
        value = { kind = ValueKind::NULL, tpe = typechecking::pointer(ref_tpe) } !Value,
        loc = ret_gep2
    }
    push_insn(store3, state)

    let index3 = allocate(Value, 2)
    index3[0] = make_int_value(0)
    index3[1] = make_int_value(2)

    let ret_gep3 = make_local_value(typechecking::pointer(typechecking::pointer(builtins::Type_)), null, state)
    let gep3 = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    gep3.value.gep = {
        ret = ret_gep3,
        tpe = value.tpe.tpe,
        value = value,
        index = index3
    }
    push_insn(gep3, state)

    let store4 = make_insn_dbg(InsnKind::STORE, loc)
    store4.value.store = {
        value = svalue,
        loc = ret_gep3
    }
    push_insn(store4, state)
}

export def walk_VarDecl(node: *parser::Node, state: *State, set_constant: bool = false) {
    let left = node.value.var_decl.left
    let right = node.value.var_decl.right
    let kw = node.value.var_decl.kw

    if kw == parser::VarDecl::CONST and not set_constant {
        return
    }

    let loc = make_location(node, state)
    let assign_left = vector::make()

    for var i in 0..vector::length(left) {
        let n = vector::get(left, i) !*parser::Node
        if (@n).kind == parser::NodeKind::ID_DECL {
            let v = (@n).value.id_decl.value
            let tpe = (@v).tpe
            import_structures(tpe, state.module)

            let value = v.svalue
            if not value { continue }
            if value.name != "_" {
                let ret = {
                    kind = ValueKind::LOCAL,
                    name = value.assembly_name,
                    tpe = tpe
                } !Value

                let insn = make_insn_dbg(InsnKind::ALLOCA, loc)
                (@insn).value.alloca = {
                    ret = ret
                } !InsnAlloca
                push_alloca(insn, state)

                ret.tpe = typechecking::pointer(tpe)
                if typechecking::is_ref(tpe) {
                    push_ref_init(ret, loc, state)
                }

                push_declare(v, ret, (@value).name, state)
            }

            vector::push(assign_left, v)
        } else {
            vector::push(assign_left, (@n).value.expr)
        }
    }

    if vector::length(right) > 0 {
        let assign = allocate(parser::Node)
        @assign = {
            kind = parser::NodeKind::ASSIGN,
            loc = (@node).loc,
            scope = (@node).scope
        } !parser::Node
        
        (@assign).value.assign = {
            left = assign_left,
            right = right
        } !parser::NodeAssign
        walk_Assign(assign, state)
    }
}

def walk_Defer(node: *parser::Node, state: *State) {
    let current_function = state.current_function
    let current_block = state.current_block
    if not current_function.locals { return }

    let buf = buffer::make_buffer()
    buffer::append_str(*buf, current_function.name)
    buffer::append_str(*buf, ".defer.")
    buffer::append_str(*buf, util::int_to_str(state.global_counter))
    state.global_counter += 1
    let defer_name = buffer::to_string(*buf)

    let parameter_t = vector::make()
    let np = allocate(typechecking::NamedParameter)
    @np = {
        name = "__env",
        tpe = typechecking::pointer(current_function.env)
    }
    vector::push(parameter_t, np)

    let tpe = typechecking::make_function_type_n(parser::make_identifier(["defer"]), parameter_t, vector::make(), false, false)

    let keys_locals = map::keys(current_function.locals)
    
    var env = { kind = ValueKind::UNDEF, tpe = current_function.env } !Value
    for var i in 0..keys_locals.size {
        let key = keys_locals[i]
        let tpe = map::get(current_function.locals, key) !*typechecking::Type

        let load = make_insn(InsnKind::LOAD)
        let value = make_local_value(tpe, null, state)
        load.value.load = {
            loc = { kind = ValueKind::LOCAL, tpe = typechecking::pointer(tpe), name = key } !Value,
            value = value
        } !InsnLoad
        push_insn(load, state)

        let index = allocate(int, 1)
        index[0] = i
        let ret = make_local_value(current_function.env, null, state)
        let insert = make_insn(InsnKind::INSERTVALUE)
        insert.value.insert_value = {
            ret = ret,
            value = env,
            element = value,
            index = index
        } !InsnInsertValue
        push_insn(insert, state)
        env = ret
    }

    let alloca_ret = make_local_value(current_function.defers, null, state)
    let alloca = make_insn(InsnKind::ALLOCA)
    alloca.value.alloca = {
        ret = alloca_ret
    } !InsnAlloca
    push_insn(alloca, state)
    alloca_ret.tpe = typechecking::pointer(alloca_ret.tpe)

    let load_ret = make_local_value(typechecking::pointer(current_function.defers), null, state)
    let load = make_insn(InsnKind::LOAD)
    load.value.load = {
        loc = { kind = ValueKind::LOCAL, tpe = typechecking::pointer(typechecking::pointer(current_function.defers)), name = "__defers" } !Value,
        value = load_ret
    } !InsnLoad
    push_insn(load, state)

    let index1 = allocate(int, 1)
    index1[0] = 0
    let insert1_ret = make_local_value(current_function.defers, null, state)
    let insert1 = make_insn(InsnKind::INSERTVALUE)
    insert1.value.insert_value = {
        ret = insert1_ret,
        value = { kind = ValueKind::UNDEF, tpe = current_function.defers } !Value,
        element = env,
        index = index1
    } !InsnInsertValue
    push_insn(insert1, state)

    let index2 = allocate(int, 1)
    index2[0] = 1
    let insert2_ret = make_local_value(current_function.defers, null, state)
    let insert2 = make_insn(InsnKind::INSERTVALUE)
    insert2.value.insert_value = {
        ret = insert2_ret,
        value = insert1_ret,
        element = { kind = ValueKind::GLOBAL, tpe = typechecking::pointer(tpe), name = defer_name } !Value,
        index = index2
    } !InsnInsertValue
    push_insn(insert2, state)
    
    let index3 = allocate(int, 1)
    index3[0] = 2
    let insert3_ret = make_local_value(current_function.defers, null, state)
    let insert3 = make_insn(InsnKind::INSERTVALUE)
    insert3.value.insert_value = {
        ret = insert3_ret,
        value = insert2_ret,
        element = load_ret,
        index = index3
    } !InsnInsertValue
    push_insn(insert3, state)

    let store1 = make_insn(InsnKind::STORE)
    store1.value.store = {
        value = insert3_ret,
        loc = alloca_ret
    } !InsnStore
    push_insn(store1, state)

    let store2 = make_insn(InsnKind::STORE)
    store2.value.store = {
        value = alloca_ret,
        loc = { kind = ValueKind::LOCAL, tpe = typechecking::pointer(typechecking::pointer(current_function.defers)), name = "__defers" } !Value
    }
    push_insn(store2, state)

    let block = make_block()
    let function = allocate(Function)
    @function = {
        name = defer_name,
        unmangled = "defer",
        args = parameter_t,
        allocas = vector::make(),
        block = block,
        module = state.module
    }

    let scope = vector::pop(state.discope)
    create_debug_info(node, function, tpe, state)

    state.current_block = function.block
    state.current_function = function

    for var i in 0..keys_locals.size {
        let key = keys_locals[i]
        let tpe = map::get(current_function.locals, key) !*typechecking::Type

        let index = allocate(Value, 2)
        index[0] = make_int_value(0)
        index[1] = make_int_value(i)

        let gep = make_insn(InsnKind::GETELEMENTPTR)
        gep.value.gep = {
            ret = { kind = ValueKind::LOCAL, tpe = tpe, name = key } !Value,
            tpe = current_function.env,
            value = { kind = ValueKind::LOCAL, tpe = typechecking::pointer(current_function.env), name = "__env.value" } !Value,
            index = index
        }
        push_insn(gep, state)
    }
    
    for var i in 0..vector::length(node.value.body) {
        walk(vector::get(node.value.body, i) !*parser::Node, state)
    }

    let ret = make_insn(InsnKind::RET)
    ret.value.ret.value = NO_VALUE
    push_insn(ret, state)

    state.current_block = current_block
    state.current_function = current_function
    pop_scope(state)
    if scope and toolchain::debug_sym { vector::push(state.discope, scope) }

    vector::insert(function.block.insn, 0, function.allocas)
    map::put(state.module.imported, function.name, map::sentinel)
    map::put(state.module.result.functions, function.name, function)
}

def walk_Assert(node: *parser::Node, state: *State) {
    let loc = make_location(node, state)

    let cond = node.value.assert_.cond
    let msg = node.value.assert_.message

    import_structures(scope::get(state.module.scope, parser::make_identifier(["fprintf"])).tpe, state.module)

    let std_module = map::get(toolchain::modules, "std") !*toolchain::Module
    let stderr_fun = scope::get(std_module.scope, parser::make_identifier(["stderr"])).tpe
    //let fun = predeclare_function(stderr_fun, std_module)
    //map::put(state.module.result.functions, stderr_fun.type_name, fun)

    map::put(state.module.imported, stderr_fun.type_name, map::sentinel)
    map::put(state.module.imported, "fprintf", map::sentinel)
    map::put(state.module.imported, "abort", map::sentinel)

    var br: *Insn
    var fmt: string
    var args: [Value]

    if cond {
        let expr = convert_to(cond, walk_and_load_expression(cond, state), builtins::bool_, state)
        let if_false = make_label(state)
    
        br = make_insn_dbg(InsnKind::BR, loc)
        br.value.br = {
            cond = expr,
            if_false = if_false
        } !InsnBr
        push_insn(br, state)

        push_label(if_false, state)

        if msg {
            args = allocate(Value, 7)
            fmt = "%s:%d:%s: Assertion %s failed! %s\n"

            args[6] = charp_str(walk_and_load_expression(msg, state), state)
        } else {
            args = allocate(Value, 6)
            fmt = "%s:%d:%s: Assertion %s failed!\n"
        }

        let buf = buffer::make_buffer()
        
        var line = cond.loc.lines[cond.loc.line]
        var str: string
        str.value = line.value ++ cond.loc.column
        if cond.loc.end_line == cond.loc.line {
            str.size = cond.loc.end_column - cond.loc.column + 1
        } else {
            str.size = line.size - cond.loc.column - 1
        }
        buffer::append_str(*buf, str)

        // TODO This doesn't work at all
        for var i in cond.loc.line..(cond.loc.end_line - 1) {
            buffer::append_str(*buf, cond.loc.lines[i])
        }
        if cond.loc.end_line > cond.loc.line {
            line = cond.loc.lines[cond.loc.end_line]
            str.value = line.value
            str.size = cond.loc.end_column
            buffer::append_str(*buf, str)
        }
        buffer::append_char(*buf, '\0')
    	
        args[5] = charp(buffer::to_string(*buf), state)
    } else {
        args = allocate(Value, 5)
        fmt = "%s:%d:%s: Unreachable!\n"
    }

    let stderr = make_local_value(builtins::File_, null, state)
    let call = make_insn_dbg(InsnKind::CALL, loc)
    call.value.call = {
        name = {
            kind = ValueKind::GLOBAL,
            name = stderr_fun.type_name
        } !Value,
        ret = stderr,
        args = allocate(Value, 0)
    } !InsnCall
    push_insn(call, state)

    args[0] = stderr
    args[1] = charp(fmt, state)
    args[2] = charp(node.loc.filename, state)
    args[3] = { kind = ValueKind::INT, tpe = builtins::int_, i = node.loc.line + 1 } !Value

    var current_function = "main"
    if state.current_function {
        current_function = state.current_function.unmangled
    }

    args[4] = charp(current_function, state)
    
    let proto = allocate(typechecking::NamedParameter, 3)
    proto[0] = { tpe = builtins::File_ } !typechecking::NamedParameter
    proto[1] = { tpe = typechecking::pointer(builtins::char_) } !typechecking::NamedParameter
    proto[2] = { varargs = true } !typechecking::NamedParameter

    let fprintf = make_insn_dbg(InsnKind::CALL, loc)
    fprintf.value.call = {
        name = { kind = ValueKind::GLOBAL, name = "fprintf" } !Value,
        ret = make_local_value(builtins::int_, null, state),
        args = args,
        proto = proto
    } !InsnCall
    push_insn(fprintf, state)

    let abort = make_insn_dbg(InsnKind::CALL, loc)
    abort.value.call = {
        name = { kind = ValueKind::GLOBAL, name = "abort" } !Value,
        ret = NO_VALUE,
        args = allocate(Value, 0)
    } !InsnCall
    push_insn(abort, state)

    let unreachable = make_insn(InsnKind::UNREACHABLE)
    push_insn(unreachable, state)
    
    let if_true = make_label(state)
    push_label(if_true, state)
    
    if cond {
        br.value.br.if_true = if_true
    }
}

export def walk(node: *parser::Node, state: *State) {
    let scpe = state.scope
    if node.scope {
        state.scope = node.scope
    }

    if not node { return }
    switch (@node).kind !int {
        case parser::NodeKind::DEF:
            // TODO Nested functions not implemented
            null
        case parser::NodeKind::VAR_DECL:
            walk_VarDecl(node, state)
        case parser::NodeKind::RETURN:
            walk_Return(node, state)
        case parser::NodeKind::BREAK:
            walk_Break(node, state)
        case parser::NodeKind::CONTINUE:
            walk_Continue(node, state)
        case parser::NodeKind::IF:
            walk_If(node, state)
        case parser::NodeKind::SWITCH:
            walk_Switch(node, state)
        case parser::NodeKind::LOOP:
            walk_Loop(node, state)
        case parser::NodeKind::WHILE:
            walk_While(node, state)
        case parser::NodeKind::FOR:
            walk_For(node, state)
        case parser::NodeKind::DEFER:
            walk_Defer(node, state)
        case parser::NodeKind::ASSERT:
            walk_Assert(node, state)
        case parser::NodeKind::TYPE_DECL:
            walk_TypeDecl(node, state)
        case: walk_expression(node, state)
    }
    state.scope = scpe
}

def di_basic_type(tpe: *typechecking::Type, name: string, c: string, state: *State) -> *Value {
    let debug_values = allocate(DebugParam, 4)
    debug_values[0] = {
        name = "name", value = { kind = DebugValueKind::STRING, s = name } !DebugValue
    } !DebugParam
    debug_values[1] = {
        name = "size", value = { kind = DebugValueKind::INT, i = tpe.size * 8 } !DebugValue
    } !DebugParam
    debug_values[2] = {
        name = "align", value = { kind = DebugValueKind::INT, i = tpe.align * 8 } !DebugValue
    } !DebugParam
    debug_values[3] = {
        name = "encoding", value = { kind = DebugValueKind::CONST, name = c } !DebugValue
    } !DebugParam
    let di = allocate(Value)
    @di = {
        kind = ValueKind::DEBUG_INFO,
        name = "DIBasicType",
        debug_values = debug_values
    } !Value
    return di
}

def di_composite_type(value: *Value, tpe: *typechecking::Type, name: string, c: string, state: *State) -> *Value {
    let elementsarr = allocate(Value, tpe.fields.size)
    for var i in 0..tpe.fields.size {
        let elem = tpe.fields[i]
        let debug_values = allocate(DebugParam, 8)
        debug_values[0] = {
            name = "tag", value = { kind = DebugValueKind::CONST, name = "DW_TAG_member" } !DebugValue
        } !DebugParam
        debug_values[1] = {
            name = "name", value = { kind = DebugValueKind::STRING, s = elem.name } !DebugValue
        } !DebugParam
        debug_values[2] = {
            name = "scope", value = meta_to_debug_value(value)
        } !DebugParam
        debug_values[3] = {
            name = "file", value = meta_to_debug_value((@state).difile)
        } !DebugParam
        debug_values[4] = {
            name = "line", value = { kind = DebugValueKind::INT, i = elem.line + 1 } !DebugValue
        } !DebugParam
        debug_values[5] = {
            name = "baseType", value = meta_to_debug_value(di_type(elem.tpe, state))
        } !DebugParam
        debug_values[6] = {
            name = "size", value = { kind = DebugValueKind::INT, i = (@elem.tpe).size * 8 } !DebugValue
        } !DebugParam
        let type_member = vector::get(tpe.field_types, elem.index) !*typechecking::TypeMember
        debug_values[7] = {
            name = "offset", value = { kind = DebugValueKind::INT, i = type_member.offset * 8 } !DebugValue
        } !DebugParam

        let di = allocate(Value)
        @di = {
            kind = ValueKind::DEBUG_INFO,
            name = "DIDerivedType",
            debug_values = debug_values
        } !Value
        elementsarr[i] = @push_meta(di, state)
    }
    
    let elements = allocate(Value)
    @elements = {
        kind = ValueKind::STRUCT,
        metadata = true,
        values = elementsarr
    } !Value
    let elementsp = push_meta(elements, state)

    let debug_values = allocate(DebugParam, 6)
    debug_values[0] = {
        name = "tag", value = { kind = DebugValueKind::CONST, name = c } !DebugValue
    } !DebugParam
    debug_values[1] = {
        name = "file", value = meta_to_debug_value((@state).difile)
    } !DebugParam
    debug_values[2] = {
        name = "line", value = { kind = DebugValueKind::INT, i = tpe.line + 1 } !DebugValue
    } !DebugParam
    debug_values[3] = {
        name = "size", value = { kind = DebugValueKind::INT, i = tpe.size * 8 } !DebugValue
    } !DebugParam
    debug_values[4] = {
        name = "elements", value = meta_to_debug_value(elementsp)
    } !DebugParam
    debug_values[5] = {
        name = "name", value = { kind = DebugValueKind::STRING, s = name } !DebugValue
    } !DebugParam

    let di = allocate(Value)
    @di = {
        kind = ValueKind::DEBUG_INFO,
        name = "DICompositeType",
        debug_values = debug_values
    } !Value
    return di
}

def di_forward_declare(tpe: *typechecking::Type, name: string, state: *State) -> *Value {
    let debug_values = allocate(DebugParam, 5)
    debug_values[0] = {
        name = "tag", value = { kind = DebugValueKind::CONST, name = "DW_TAG_structure_type" } !DebugValue
    } !DebugParam
    debug_values[1] = {
        name = "file", value = meta_to_debug_value((@state).difile)
    } !DebugParam
    debug_values[2] = {
        name = "line", value = { kind = DebugValueKind::INT, i = tpe.line + 1 } !DebugValue
    } !DebugParam
    debug_values[3] = {
        name = "name", value = { kind = DebugValueKind::STRING, s = name } !DebugValue
    } !DebugParam
    debug_values[4] = {
        name = "flags", value = { kind = DebugValueKind::CONST, name = "DIFlagFwdDecl" } !DebugValue
    } !DebugParam

    let di = allocate(Value)
    @di = {
        kind = ValueKind::DEBUG_INFO,
        name = "DICompositeType",
        debug_values = debug_values
    } !Value
    return di
}

def di_subroutine_type(tpe: *typechecking::Type, state: *State) -> *Value {
    let values = allocate(Value, vector::length(tpe.parameter_t) + 1)

    var ret_tpe: *typechecking::Type = null
    if vector::length(tpe.return_t) > 1 {
        ret_tpe = make_return_type(tpe)
    } else if vector::length(tpe.return_t) == 1 {
        ret_tpe = vector::get(tpe.return_t, 0) !*typechecking::Type
    }

    if ret_tpe {
        values[0] = @di_type(ret_tpe, state)
    } else {
        values[0] = NO_VALUE
    }

    for var i in 0..vector::length(tpe.parameter_t) {
        let np = vector::get(tpe.parameter_t, i) !*typechecking::NamedParameter
        values[i + 1] = @di_type((@np).tpe, state)
    }

    let types = allocate(Value)
    @types = {
        kind = ValueKind::STRUCT,
        metadata = true,
        values = values
    } !Value
    let typesp = push_meta(types, state)

    let debug_values = allocate(DebugParam, 1)
    debug_values[0] = {
        name = "types", value = meta_to_debug_value(typesp)
    } !DebugParam

    let di = allocate(Value)
    @di = {
        kind = ValueKind::DEBUG_INFO,
        name = "DISubroutineType",
        debug_values = debug_values
    } !Value

    return push_meta(di, state)
}

def di_function_type(tpe: *typechecking::Type, state: *State) -> *Value {
    let diftpe = di_subroutine_type(tpe, state)

    let debug_values = allocate(DebugParam, 3)
    debug_values[0] = {
        name = "tag", value = { kind = DebugValueKind::CONST, name = "DW_TAG_pointer_type" } !DebugValue
    } !DebugParam
    debug_values[1] = {
        name = "baseType", value = meta_to_debug_value(diftpe)
    } !DebugParam
    debug_values[2] = {
        name = "size", value = { kind = DebugValueKind::INT, i = (size_of type () -> ()) * 8 } !DebugValue
    } !DebugParam

    let di = allocate(Value)
    @di = {
        kind = ValueKind::DEBUG_INFO,
        name = "DIDerivedType",
        debug_values = debug_values
    } !Value
    return di
}

def di_pointer_type(tpe: *typechecking::Type, state: *State) -> *Value {
    let debug_values = allocate(DebugParam, 3)
    debug_values[0] = {
        name = "tag", value = { kind = DebugValueKind::CONST, name = "DW_TAG_pointer_type" } !DebugValue
    } !DebugParam
    debug_values[1] = {
        name = "baseType", value = meta_to_debug_value(di_type(tpe.tpe, state))
    } !DebugParam
    debug_values[2] = {
        name = "size", value = { kind = DebugValueKind::INT, i = (size_of type *) * 8 } !DebugValue
    } !DebugParam

    let di = allocate(Value)
    @di = {
        kind = ValueKind::DEBUG_INFO,
        name = "DIDerivedType",
        debug_values = debug_values
    } !Value
    return di
}

// TODO More dimensions
def di_static_array_type(tpe: *typechecking::Type, state: *State) -> *Value {
    
    let debug_values1 = allocate(DebugParam, 1)
    debug_values1[0] = {
        name = "count", value = { kind = DebugValueKind::INT, i = tpe.length } !DebugValue
    } !DebugParam
    let value = allocate(Value)
    @value = {
        kind = ValueKind::DEBUG_INFO,
        name = "DISubrange",
        debug_values = debug_values1
    } !Value

    let values = allocate(Value, 1)
    values[0] = @push_meta(value, state)
    let elements = allocate(Value)
    @elements = {
        kind = ValueKind::STRUCT,
        metadata = true,
        values = values
    } !Value

    let debug_values = allocate(DebugParam, 4)
    debug_values[0] = {
        name = "tag", value = { kind = DebugValueKind::CONST, name = "DW_TAG_array_type" } !DebugValue
    } !DebugParam
    debug_values[1] = {
        name = "baseType", value = meta_to_debug_value(di_type(tpe.tpe, state))
    } !DebugParam
    debug_values[2] = {
        name = "size", value = { kind = DebugValueKind::INT, i = tpe.size * 8 } !DebugValue
    } !DebugParam
    debug_values[3] = {
        name = "elements", value = meta_to_debug_value(push_meta(elements, state))
    } !DebugParam

    let di = allocate(Value)
    @di = {
        kind = ValueKind::DEBUG_INFO,
        name = "DICompositeType",
        debug_values = debug_values
    } !Value
    return di
}

def di_array_type(value: *Value, tpe: *typechecking::Type, state: *State) -> *Value {
    // TODO This should probably be an array type instead (see documentation)
    let fields = allocate(typechecking::StructMember, 2)
    fields[0] = { name = "size", tpe = builtins::size_t_ } !typechecking::StructMember
    fields[1] = { name = "value", tpe = typechecking::pointer(tpe.tpe) } !typechecking::StructMember
    return di_composite_type(value, typechecking::make_struct_type(fields), "<array>", "DW_TAG_structure_type", state)
}

def di_ref_type(value: *Value, tpe: *typechecking::Type, state: *State) -> *Value {
    let fields = allocate(StructMember, 3)
    fields[0] = { name = "ref_count", tpe = typechecking::pointer(builtins::int64_) } !StructMember
    fields[1] = { name = "value", tpe = typechecking::pointer(tpe.tpe) } !StructMember
    fields[2] = { name = "tpe", tpe = typechecking::pointer(builtins::Type_) } !StructMember
    let ref = typechecking::make_struct_type(fields)
 
    return di_composite_type(value, ref, "<ref>", "DW_TAG_structure_type", state)
}

def di_type(tpe: *typechecking::Type, state: *State) -> *Value {
    if not tpe { return null }

    let anonymous = length(tpe.type_name) == 0
    var ditpe: *Value = null
    if not anonymous {
        ditpe = map::get((@state).ditypes, tpe.type_name) !*Value
    }
    if ditpe { return ditpe }

    var name = tpe.type_name
    if anonymous {
        name = "<anonymous>"
    }

    ditpe = allocate(Value)
    let ditpep = push_meta(ditpe, state)
    if not anonymous {
        map::put((@state).ditypes, tpe.type_name, ditpep)
    }

    switch tpe.kind !int {
        // TODO compare with char for special casing
        case typechecking::TypeKind::WORD:
            if tpe.unsig {
                @ditpe = @di_basic_type(tpe, name, "DW_ATE_unsigned", state)
            } else {
                @ditpe = @di_basic_type(tpe, name, "DW_ATE_signed", state)
            }
        case typechecking::TypeKind::CHAR:
            @ditpe = @di_basic_type(tpe, name, "DW_ATE_unsigned", state)
        case typechecking::TypeKind::FLOAT:
            @ditpe = @di_basic_type(tpe, name, "DW_ATE_float", state)
        case typechecking::TypeKind::BOOL:
            @ditpe = @di_basic_type(tpe, name, "DW_ATE_unsigned", state)
        case typechecking::TypeKind::STRUCT:
            @ditpe = @di_composite_type(ditpep, tpe, name, "DW_TAG_structure_type", state)
        case typechecking::TypeKind::UNION:
            @ditpe = @di_composite_type(ditpep, tpe, name, "DW_TAG_union_type", state)
        case typechecking::TypeKind::ENUM:
            // TODO Use enumeration type
            if (@tpe.tpe).unsig {
                @ditpe = @di_basic_type(tpe.tpe, name, "DW_ATE_unsigned", state)
            } else {
                @ditpe = @di_basic_type(tpe.tpe, name, "DW_ATE_signed", state)
            }
        case typechecking::TypeKind::FUNCTION:
            @ditpe = @di_function_type(tpe, state)
        case typechecking::TypeKind::POINTER:
            @ditpe = @di_pointer_type(tpe, state)
        case typechecking::TypeKind::REFERENCE:
            @ditpe = @di_ref_type(ditpep, tpe, state)
        case typechecking::TypeKind::STATIC_ARRAY:
            @ditpe = @di_static_array_type(tpe, state)
        case typechecking::TypeKind::ARRAY:
            @ditpe = @di_array_type(ditpep, tpe, state)
        case typechecking::TypeKind::STUB:
            @ditpe = @di_forward_declare(tpe, name, state)
        case typechecking::TypeKind::TYPE:
            @ditpe = @di_composite_type(ditpep, builtins::Type_, "<type>", "DW_TAG_structure_type", state)
        case:
            error(tpe.kind, "\n") 
            assert(false)
    }
    return ditpep
}

def generate_defer_types(state: *State) {
    let function = state.current_function
    if not function.has_defer { return }

    var buf = buffer::make_buffer()
    buffer::append_str(*buf, function.name)
    buffer::append_str(*buf, ".env")
    let env_name = buffer::to_string(*buf)
    let env_fields = allocate(typechecking::StructMember, map::size(function.locals))

    let keys = map::keys(function.locals)
    for var i in 0..keys.size {
        let tpe = map::get(function.locals, keys[i]) !*typechecking::Type
        env_fields[i] = {
            tpe = tpe
        } !typechecking::StructMember
    }
    
    let env = typechecking::make_struct_type(env_fields)
    env.type_name = env_name

    map::put(state.module.result.structures, env_name, env)
    function.env = env

    buf = buffer::make_buffer()
    buffer::append_str(*buf, function.name)
    buffer::append_str(*buf, ".defers")
    let defers_name = buffer::to_string(*buf)
    let defers_fields = allocate(typechecking::StructMember, 3)

    defers_fields[0] = {
        tpe = env
    } !typechecking::StructMember

    let defer_function = typechecking::make_type_raw(typechecking::TypeKind::FUNCTION)
    defer_function.parameter_t = vector::make()
    let p = allocate(typechecking::NamedParameter)
    @p = {
        name = "",
        tpe = typechecking::pointer(env)
    } !typechecking::NamedParameter
    vector::push(defer_function.parameter_t, p)
    defer_function.return_t = vector::make()
    defer_function.align = align_of type ->
    defer_function.size = size_of type ->
    
    let defer_functionp = typechecking::pointer(defer_function)
    defers_fields[1] = {
        tpe = defer_functionp
    } !typechecking::StructMember

    let defersp = typechecking::pointer(null)

    defers_fields[2] = {
        tpe = defersp
    } !typechecking::StructMember

    let defers = typechecking::make_struct_type(defers_fields)
    defers.type_name = defers_name
    defersp.tpe = defers
    map::put(state.module.result.structures, defers_name, defers)
    function.defers = defers

    // Generate defer stack
    let alloca = make_insn(InsnKind::ALLOCA)
    alloca.value.alloca = {
        ret = { kind = ValueKind::LOCAL, tpe = typechecking::pointer(defers), name = "__defers" } !Value
    } !InsnAlloca
    push_insn(alloca, state)

    let store = make_insn(InsnKind::STORE)
    store.value.store = {
        value = { kind = ValueKind::NULL, tpe = typechecking::pointer(defers) } !Value,
        loc = { kind = ValueKind::LOCAL, tpe = typechecking::pointer(typechecking::pointer(defers)), name = "__defers" } !Value
    } !InsnStore
    push_insn(store, state)
}

def defer_unroll(node: *parser::Node, state: *State) {
    let parameter_t = vector::make()
    let np = allocate(typechecking::NamedParameter)
    @np = {
        name = "__env",
        tpe = typechecking::pointer(state.current_function.env)
    }
    vector::push(parameter_t, np)
    let tpe = typechecking::make_function_type_n(parser::make_identifier(["defer"]), parameter_t, vector::make(), false, false)

    let br_to_start = make_insn(InsnKind::BR_UNC)
    push_insn(br_to_start, state)

    let start_label = make_label(state)
    push_label(start_label, state)    
    br_to_start.value.br_unc.label_ = start_label

    let current_defer_ret = make_local_value(typechecking::pointer(state.current_function.defers), null, state)
    let current_defer = make_insn(InsnKind::LOAD)
    current_defer.value.load = {
        value = current_defer_ret,
        loc = { kind = ValueKind::LOCAL, tpe = typechecking::pointer(typechecking::pointer(state.current_function.defers)), name = "__defers" } !Value 
    } !InsnLoad
    push_insn(current_defer, state)

    let ptr_to_int_ret = make_local_value(builtins::int64_, null, state)
    let ptr_to_int = make_insn(InsnKind::PTRTOINT)
    ptr_to_int.value.convert = {
        ret = ptr_to_int_ret,
        value = current_defer_ret
    } !InsnConvert
    push_insn(ptr_to_int, state)

    let icmp_ret = make_local_value(builtins::bool_, null, state)
    let icmp = make_insn(InsnKind::ICMP)
    icmp.value.icmp = {
        op = CompareInt::ne,
        ret = icmp_ret,
        left = ptr_to_int_ret,
        right = { kind = ValueKind::INT, tpe = builtins::int64_, i = 0 } !Value
    } !InsnIcmp
    push_insn(icmp, state)

    let br = make_insn(InsnKind::BR)
    br.value.br.cond = icmp_ret
    push_insn(br, state)

    let label_body = make_label(state)
    push_label(label_body, state)
    br.value.br.if_true = label_body

    let index1 = allocate(Value, 2)
    index1[0] = make_int_value(0)
    index1[1] = make_int_value(0)
    let gep_env_ret = make_local_value(typechecking::pointer(state.current_function.env), null, state)
    let gep_env = make_insn(InsnKind::GETELEMENTPTR)
    gep_env.value.gep = {
        ret = gep_env_ret,
        tpe = state.current_function.defers,
        value = current_defer_ret,
        index = index1
    } !InsnGetElementPtr
    push_insn(gep_env, state)

    let index2 = allocate(Value, 2)
    index2[0] = make_int_value(0)
    index2[1] = make_int_value(1)
    let gep_fun_ret = make_local_value(typechecking::pointer(typechecking::pointer(tpe)), null, state)
    let gep_fun = make_insn(InsnKind::GETELEMENTPTR)
    gep_fun.value.gep = {
        ret = gep_fun_ret,
        tpe = state.current_function.defers,
        value = current_defer_ret,
        index = index2
    } !InsnGetElementPtr
    push_insn(gep_fun, state)

    let index3 = allocate(Value, 2)
    index3[0] = make_int_value(0)
    index3[1] = make_int_value(2)
    let gep_defer_ret = make_local_value(typechecking::pointer(typechecking::pointer(state.current_function.defers)), null, state)
    let gep_defer = make_insn(InsnKind::GETELEMENTPTR)
    gep_defer.value.gep = {
        ret = gep_defer_ret,
        tpe = state.current_function.defers,
        value = current_defer_ret,
        index = index3
    } !InsnGetElementPtr
    push_insn(gep_defer, state)

    let load_fun_ret = make_local_value(typechecking::pointer(tpe), null, state)
    let load_fun = make_insn(InsnKind::LOAD)
    load_fun.value.load = {
        value = load_fun_ret,
        loc = gep_fun_ret
    } !InsnLoad
    push_insn(load_fun, state)

    let load_defer_ret = make_local_value(typechecking::pointer(state.current_function.defers), null, state)
    let load_defer = make_insn(InsnKind::LOAD)
    load_defer.value.load = {
        value = load_defer_ret,
        loc = gep_defer_ret
    } !InsnLoad
    push_insn(load_defer, state)

    let args = allocate(Value, 1)
    args[0] = gep_env_ret
    let call = make_insn_dbg(InsnKind::CALL, make_location(node, state))
    call.value.call = {
        name = load_fun_ret,
        ret = NO_VALUE,
        args = args
    } !InsnCall
    push_insn(call, state)

    let store_env = make_insn(InsnKind::STORE)
    store_env.value.store = {
        value = load_defer_ret,
        loc = { kind = ValueKind::LOCAL, tpe = typechecking::pointer(typechecking::pointer(state.current_function.defers)), name = "__defers"} !Value
    } !InsnStore
    push_insn(store_env, state)

    push_insn(br_to_start, state)

    let label_end = make_label(state)
    push_label(label_end, state)
    br.value.br.if_false = label_end
}

export def predeclare_function(tpe: *typechecking::Type, module: *toolchain::Module) -> *Function {
    var function = map::get(module.result.functions, tpe.type_name) !*Function
    if function {
        return function 
    }

    function = allocate(Function)
    @function = {
        name = tpe.type_name,
        unmangled = tpe.name,
        forward_declare = true,
        allocas = vector::make(),
        imported = tpe.imported,
        module = module,
        dllimport = tpe.dllimport
    } !Function

    if vector::length(tpe.parameter_t) > 0 {
        let last_parameter = vector::peek(tpe.parameter_t) !*typechecking::NamedParameter
        if last_parameter.varargs and not last_parameter.tpe {
            function.varargs = true
        }
    }
    
    if vector::length(tpe.return_t) > 1 {
        function.ret = make_return_type(tpe)
        function.multiple_returns = true
    } else {
        function.ret = vector::peek(tpe.return_t) !*typechecking::Type
    }

    (@function).args = vector::make()
    for var i in 0..vector::length(tpe.parameter_t) {
        let np = allocate(typechecking::NamedParameter)
        (@np) = @(vector::get(tpe.parameter_t, i) !*typechecking::NamedParameter)
        if not np.tpe or np.tpe.kind != typechecking::TypeKind::TYPE {
            vector::push((@function).args, np)
        }
    }

    map::put(module.result.functions, (@function).name, function)

    return function
}

def create_debug_info(node: *parser::Node, function: *Function, tpe: *typechecking::Type, state: *State) {
    if not toolchain::debug_sym { return }

    var line = -1
    if node { line = (@node).loc.line }

    let debug_values = allocate(DebugParam, 7)
    debug_values[0] = {
        name = "name", value = { kind = DebugValueKind::STRING, s = (@function).name } !DebugValue
    } !DebugParam
    debug_values[1] = {
        name = "scope", value = meta_to_debug_value(vector::peek((@state).discope) !*Value)
    } !DebugParam
    debug_values[2] = {
        name = "file", value = meta_to_debug_value((@state).difile)
    } !DebugParam
    debug_values[3] = {
        name = "line", value = { kind = DebugValueKind::INT, i = line + 1 } !DebugValue
    } !DebugParam
    debug_values[4] = {
        name = "type", value = meta_to_debug_value(di_subroutine_type(tpe, state))
    } !DebugParam
    debug_values[5] = {
        name = "scopeLine", value = { kind = DebugValueKind::INT, i = line + 1 } !DebugValue
    } !DebugParam
    debug_values[6] = {
        name = "unit", value = meta_to_debug_value((@state).diunit)
    } !DebugParam

    let disub = allocate(Value)
    @disub = {
        kind = ValueKind::DEBUG_INFO,
        name = "DISubprogram",
        distinct = true,
        debug_values = debug_values
    } !Value
    let disubp = push_meta(disub, state)
    (@function).debug = disubp

    vector::push((@state).discope, disubp)
}
 
// block and body may be null
export def create_function(
    node: *parser::Node, 
    tpe: *typechecking::Type, 
    body: *vector::Vector, 
    scpe: *scope::Scope, 
    block: *Block, 
    state: *State,
    no_cleanup: bool = false
) {
    state.scope = scpe
    
    let function = map::get(state.module.result.functions, tpe.type_name) !*Function
    if not function { return }

    function.forward_declare = false
    function.locals = node.value.def_.locals
    function.has_defer = node.value.def_.has_defer
    function.allocas = vector::make()

    if body {
        import_structures(tpe, state.module)
        map::put(state.module.imported, tpe.type_name, map::sentinel)
        create_debug_info(node, function, tpe, state)

        let previous_function = state.current_function
        (@state).current_function = function
        if not block {
            block = make_block()
        }

        (@function).block = block
        let previous_block = state.current_block
        (@state).current_block = block

        // Create function arguments
        for var i in 0..vector::length((@function).args) {
            let np = vector::get((@function).args, i) !*typechecking::NamedParameter
            var value = np.tpe
            if np.varargs and value {
                value = typechecking::array(value)
            }
            if value.kind == typechecking::TypeKind::TYPE { continue }
            /*let vars = map::keys((@scpe).fields)
            for var i in 0..vars.size {
                let v = vars[i]
                print(v, "\n")
            }*/
            let old_name = (@np).name
            let name = (@scope::get(scpe, parser::make_identifier([old_name]))).assembly_name
            let buf = buffer::make_buffer()
            buffer::append_str(*buf, old_name)
            buffer::append_str(*buf, ".value")
            let new_name = buffer::to_string(*buf)
            // Insert alloca and store instructions

            let ret = {
                kind = ValueKind::LOCAL,
                name = name,
                tpe = value
            } !Value

            let alloca = make_insn(InsnKind::ALLOCA)
            (@alloca).value.alloca = {
                ret = ret
            } !InsnAlloca
            push_alloca(alloca, state)

            ret.tpe = typechecking::pointer(value)
            if (@np).node {
                push_declare_arg((@np).node, ret, old_name, i + 1, state)
            }
            
            let store = make_insn(InsnKind::STORE)
            (@store).value.store = {
                value = {
                    kind = ValueKind::LOCAL,
                    name = new_name,
                    tpe = value
                } !Value,
                loc = {
                    kind = ValueKind::LOCAL,
                    name = name,
                    tpe = typechecking::pointer(value)
                } !Value
            } !InsnStore

            push_insn(store, state)

            if typechecking::is_ref(value) {
                increase_ref_count(ret, null, state)
            }
        }

        generate_defer_types(state)

        var last_node: *Node = node
        for var i in 0..vector::length(body) {
            let node = vector::get(body, i) !*parser::Node
            walk(node, state)
            last_node = node
        }

        if not no_cleanup {
            decrease_ref_count_scoped(scpe, make_location(last_node, state), state)
        }

        vector::insert(function.block.insn, 0, function.allocas)

        // TODO Make another compiler pass that checks for missing return statements and dead code
        // Check for missing return statement
        let last_insn = vector::peek((@(@state).current_block).insn) !*Insn
        if not last_insn or (@last_insn).kind != InsnKind::RET {
            if function.has_defer {
                defer_unroll(last_node, state)
            }

            var value = NO_VALUE
            if (@function).ret {
                value = {
                    kind = ValueKind::UNDEF,
                    tpe = (@function).ret
                } !Value
            }
            
            let ret = make_insn(InsnKind::RET)
            (@ret).value.ret.value = value
            push_insn(ret, state)
        }

        pop_scope(state)

        state.current_function = previous_function
        state.current_block = previous_block
        function.is_compiled = true
    }
}

def make_string(str: string, state: *State) -> Value {
    let cp = charp(str, state)
    
    let values = allocate(Value, 2)
    values[0] = { kind = ValueKind::INT, tpe = builtins::size_t_, i = str.size } !Value
    values[1] = { kind = ValueKind::UNDEF, tpe = typechecking::pointer(builtins::char_) } !Value
    let ret = make_local_value(builtins::string_, null, state)
    let index = allocate(int, 1)
    index[0] = 1
    let insert = make_insn(InsnKind::INSERTVALUE)
    (@insert).value.insert_value = {
        ret = ret,
        value = { 
            kind = ValueKind::STRUCT, 
            tpe = builtins::string_,
            values = values 
        } !Value,
        element = cp,
        index = index
    } !InsnInsertValue
    push_insn(insert, state)
    return ret
}

// TODO This is not going to work for nested type decls (we don't reset the state)
def walk_TypeDecl(node: *parser::Node, state: *State) {
    let left = (@node).value.type_decl.left
    for var i in 0..vector::length(left) {
        let n = vector::get(left, i) !*parser::Node
        let tpe = (@n).tpe
        if not tpe { continue }
        if typechecking::is_struct(tpe) {
            import_structures(tpe, state.module)
        } else if typechecking::is_enum(tpe) {
            let parameter_t = vector::make()
            let np = allocate(typechecking::NamedParameter)
            @np = {
                name = "enum",
                tpe = tpe
            } !typechecking::NamedParameter
            vector::push(parameter_t, np)

            let svalue = scope::get_function((@node).scope, parser::make_identifier(["to_string"]), parameter_t)
            let type_name = (@(@svalue).tpe).type_name

            let function = allocate(Function)
            @function = {
                name = type_name,
                unmangled = "to_string",
                args = parameter_t,
                ret = builtins::string_,
                module = state.module
            } !Function

            let block = make_block()
            (@function).block = block
            (@state).current_block = block
            (@state).current_function = function

            let switch_values = vector::make()
            let swtch = make_insn(InsnKind::SWITCH)
            (@swtch).value.switch_ = {
                value = { 
                    kind = ValueKind::LOCAL, 
                    name = "enum.value",
                    tpe = tpe.tpe
                } !Value,
                switch_values = switch_values
            } !InsnSwitch
            push_insn(swtch, state)
            
            // Create enum strings
            let scpe = tpe.scope
            let keys = map::keys((@scpe).fields)
            let used = map::make()
            for var i in 0..keys.size {
                let name = keys[i]
                let value = map::get((@scpe).fields, name) !*scope::Value

                let int_key = util::int_to_str(value.value.i)
                if map::contains(used, int_key) {
                    continue
                } else {
                    map::put(used, int_key, map::sentinel)
                }

                let label_ = make_label(state)
                push_label(label_, state)

                let sv = allocate(SwitchValue)
                (@sv).value = @value.value
                (@sv).label_ = label_
                vector::push(switch_values, sv)
            
                let ret = make_string(name, state)
                let retinsn = make_insn(InsnKind::RET)
                (@retinsn).value.ret.value = ret
                push_insn(retinsn, state)
            }
            let otherwise = make_label(state)
            (@swtch).value.switch_.otherwise = otherwise
            push_label(otherwise, state)
            
            let invalid = "INVALID!!"
            let ret = make_string(invalid, state)
            let retinsn = make_insn(InsnKind::RET)
            (@retinsn).value.ret.value = ret
            push_insn(retinsn, state)
            
            import_structures((@svalue).tpe, state.module)
            map::put((@(@state).module).imported, (@function).name, map::sentinel)
            map::put(state.module.result.functions, (@function).name, function)
        }
    }
}

export def walk_top_VarDecl(node: *parser::Node, state: *State, set_constant: bool) -> *parser::Node {
    let share = node.value.var_decl.share
    let kw = node.value.var_decl.kw
    let right = node.value.var_decl.right

    if kw == parser::VarDecl::CONST and not set_constant {
        return null
    }

    let left = vector::make()
    var external = false
    if share !int & parser::ShareMarker::IMPORT !int {
        external = true
    }

    for var i in 0..vector::length((@node).value.var_decl.left) {
        let n = vector::get((@node).value.var_decl.left, i) !*parser::Node
        if (@n).kind == parser::NodeKind::ID_DECL {
            let v = (@n).value.id_decl.value
            
            let value = scope::get((@node).scope, v)
            if not value { continue }
            
            import_structures((@v).tpe, state.module)
            let name = (@value).assembly_name

            let global = allocate(Global)
            @global = {
                external = external,
                name = name,
                tpe = (@v).tpe,
                line = (@v).loc.line,
                dllimport = value.dllimport
            } !Global

            if typechecking::is_ref(v.tpe) {
                let v2 = { kind = ValueKind::GLOBAL, name = name, tpe = typechecking::pointer(v.tpe) } !Value
                push_ref_init(v2, make_location(n, state), state)
                map::put(state.module.imported, global.name, map::sentinel)
            }
            
            map::put(state.module.result.globals, (@global).name, global)
            vector::push(left, (@n).value.id_decl.value)
        } else {
            vector::push(left, (@n).value.expr)
        }
    }
    if vector::length((@node).value.var_decl.right) > 0 {
        let node_assign = allocate(parser::Node)
        @node_assign = {
            kind = parser::NodeKind::ASSIGN,
            loc = (@node).loc,
            scope = (@node).scope
        } !parser::Node

        node_assign.value.assign = {
            left = left,
            right = right
        } !parser::NodeAssign
        return node_assign
    }
    return null
}

def walk_top_VarDecl(node: *parser::Node, body: *vector::Vector, state: *State) {
    let kw = node.value.var_decl.kw
    if kw != parser::VarDecl::CONST {
        let node_assign = walk_top_VarDecl(node, state, false)
        if node_assign {
            vector::push(body, node_assign)
        }
    }
}

def insert_module_main(module: *toolchain::Module, name: *parser::Node, scpe: *scope::Scope, body: *vector::Vector, state: *State) {
    if not module { return }

    // Build dependency graph
    vector::push(state.module.dependants, module)

    let args = vector::make()
    let arg = parser::make_identifier(["args"])
    (@arg).scope = scpe
    (@arg).tpe = typechecking::array(builtins::string_)
    (@arg).svalue = scope::get((@arg).scope, arg)
    vector::push(args, arg)

    let name_size = vector::length(name.value.identifier.path)
    let array = allocate(string, name_size + 1)
    for var j in 0..name_size {
        array[j] = @(vector::get(name.value.identifier.path, j) !*string)
    }
    array[array.size - 1] = "main"
    let ident = parser::make_identifier(array)
    (@ident).scope = scpe

    let main_value = scope::get(module.scope, parser::make_identifier(["main"]))
    if not main_value { return }

    let call = allocate(parser::Node)
    @call = {
        kind = parser::NodeKind::FUNC_CALL,
    	scope = scpe,
        function = (@main_value).tpe
    } !parser::Node
    
    call.value.func_call = {
        left = ident,
        args = args,
        kwargs = vector::make()
    } !parser::NodeFuncCall

    let fun = map::get(module.result.functions, main_value.tpe.type_name) !*Function
    map::put(state.module.result.functions, main_value.tpe.type_name, fun)

    vector::push(body, call)
}

def walk_top_Import(node: *parser::Node, body: *vector::Vector, state: *State) {
    let imports = (@node).value.body
    for var i in 0..vector::length(imports) {
        let imprt = vector::get(imports, i) !*parser::Node
        let name = (@imprt).value.import_module.name

        let module = toolchain::compile_module(name)
        insert_module_main(module, name, node.scope, body, state)
    }
}

def push_tpe_tpe(tpe: *Type, global: Value, module: *toolchain::Module, state: *State) {
    let index = allocate(Value, 2)
    index[0] = make_int_value(0)
    index[1] = make_int_value(4)

    let gep_ret = make_local_value(pointer(pointer(builtins::Type_)), null, state)
    let gep = make_insn(InsnKind::GETELEMENTPTR)
    gep.value.gep = {
        ret = gep_ret,
        tpe = builtins::Type_,
        value = global,
        index = index
    } !InsnGetElementPtr
    push_insn(gep, state)

    var value: Value
    if tpe.tpe {
        value = @create_type(tpe.tpe, module)
    } else {
        value = { kind = ValueKind::NULL, tpe = pointer(builtins::Type_) } !Value
    }

    let store = make_insn(InsnKind::STORE)
    store.value.store = {
        loc = gep_ret,
        value = value
    } !InsnStore
    push_insn(store, state)
}

def push_struct_members(tpe: *Type, global: Value, module: *toolchain::Module, state: *State) {
    if tpe.fields.size == 0 { return }

    // TODO cache these
    let field_type = scope::get_type(toolchain::runtime.scope, make_identifier(["Field"]))

    let fields_sarray = make_static_array(field_type, tpe.fields.size)
    let fields = make_global_value(fields_sarray, "fields", null, state)
    for var i in 0..tpe.fields.size {
        let field = tpe.fields[i]

        let name_values = allocate(Value, 2)
        name_values[0] = { kind = ValueKind::INT, tpe = builtins::int64_, i = field.name.size } !Value
        name_values[1] = { kind = ValueKind::UNDEF, tpe = pointer(builtins::int8_) } !Value

        let field_values = allocate(Value, 3)
        let type_member = vector::get(tpe.field_types, field.index) !*TypeMember
        field_values[0] = { kind = ValueKind::STRUCT, tpe = builtins::string_, values = name_values } !Value
        field_values[1] = { kind = ValueKind::INT, tpe = builtins::uint64_, i = type_member.offset !int64 } !Value
        field_values[2] = { kind = ValueKind::UNDEF, tpe = pointer(builtins::Type_) } !Value

        let value = { kind = ValueKind::STRUCT, tpe = field_type, values = field_values } !Value
        let name = charp(field.name, state)

        let index1 = allocate(int, 2)
        index1[0] = 0
        index1[1] = 1
        let insert_name_ret = make_local_value(field_type, null, state)
        let insert_name = make_insn(InsnKind::INSERTVALUE)
        insert_name.value.insert_value = {
            ret = insert_name_ret,
            value = value,
            element = name,
            index = index1
        } !InsnInsertValue
        push_insn(insert_name, state)

        let tpe = @create_type(field.tpe, module)

        let index2 = allocate(int, 1)
        index2[0] = 2
        let insert_type_ret = make_local_value(field_type, null, state)
        let insert_type = make_insn(InsnKind::INSERTVALUE)
        insert_type.value.insert_value = {
            ret = insert_type_ret,
            value = insert_name_ret,
            element = tpe,
            index = index2
        } !InsnInsertValue
        push_insn(insert_type, state)

        let index3 = allocate(Value, 2)
        index3[0] = make_int_value(0)
        index3[1] = make_int_value(i)
        let gep_ret = make_local_value(pointer(field_type), null, state)
        let gep = make_insn(InsnKind::GETELEMENTPTR)
        gep.value.gep = {
            ret = gep_ret,
            tpe = fields_sarray,
            value = fields,
            index = index3
        } !InsnGetElementPtr
        push_insn(gep, state)

        let store = make_insn(InsnKind::STORE)
        store.value.store = {
            loc = gep_ret,
            value = insert_type_ret
        }
        push_insn(store, state)
    }

    let index1 = allocate(Value, 2)
    index1[0] = make_int_value(0)
    index1[1] = make_int_value(0)
    let gep1_ret = make_local_value(pointer(field_type), null, state)
    let gep1 = make_insn(InsnKind::GETELEMENTPTR)
    gep1.value.gep = {
        ret = gep1_ret,
        tpe = fields_sarray,
        value = fields,
        index = index1
    } !InsnGetElementPtr
    push_insn(gep1, state)

    let index2 = allocate(Value, 3)
    index2[0] = make_int_value(0)
    index2[1] = make_int_value(7)
    index2[2] = make_int_value(1)
    let gep2_ret = make_local_value(pointer(pointer(field_type)), null, state)
    let gep2 = make_insn(InsnKind::GETELEMENTPTR)
    gep2.value.gep = {
        ret = gep2_ret,
        tpe = builtins::Type_,
        value = global,
        index = index2
    } !InsnGetElementPtr
    push_insn(gep2, state)

    let store = make_insn(InsnKind::STORE)
    store.value.store = {
        loc = gep2_ret,
        value = gep1_ret
    }
    push_insn(store, state)
}

def push_enum_values(tpe: *Type, global: Value, module: *toolchain::Module, state: *State) {
    let enum_type = scope::get_type(toolchain::runtime.scope, make_identifier(["EnumValue"]))

    let values_sarray = make_static_array(enum_type, map::size(tpe.scope.fields))
    let values = make_global_value(values_sarray, "values", null, state)
    
    let keys = map::keys(tpe.scope.fields)
    for var i in 0..keys.size {
        let key = keys[i]
        let svalue = map::get(tpe.scope.fields, key) !*scope::Value
        
        let name_values = allocate(Value, 2)
        name_values[0] = { kind = ValueKind::INT, tpe = builtins::int64_, i = key.size } !Value
        name_values[1] = { kind = ValueKind::UNDEF, tpe = pointer(builtins::int8_) } !Value

        let eval_values = allocate(Value, 2)
        eval_values[0] = { kind = ValueKind::STRUCT, tpe = builtins::string_, values = name_values } !Value
        eval_values[1] = { kind = ValueKind::INT, tpe = builtins::int64_, i = svalue.value.i !int64 } !Value

        let value = { kind = ValueKind::STRUCT, tpe = enum_type, values = eval_values } !Value
        let name = charp(key, state)

        let index1 = allocate(int, 2)
        index1[0] = 0
        index1[1] = 1
        let insert_name_ret = make_local_value(enum_type, null, state)
        let insert_name = make_insn(InsnKind::INSERTVALUE)
        insert_name.value.insert_value = {
            ret = insert_name_ret,
            value = value,
            element = name,
            index = index1
        } !InsnInsertValue
        push_insn(insert_name, state)
        
        let index3 = allocate(Value, 2)
        index3[0] = make_int_value(0)
        index3[1] = make_int_value(i)
        let gep_ret = make_local_value(pointer(enum_type), null, state)
        let gep = make_insn(InsnKind::GETELEMENTPTR)
        gep.value.gep = {
            ret = gep_ret,
            tpe = values_sarray,
            value = values,
            index = index3
        } !InsnGetElementPtr
        push_insn(gep, state)

        let store = make_insn(InsnKind::STORE)
        store.value.store = {
            loc = gep_ret,
            value = insert_name_ret
        }
        push_insn(store, state)
    }

    let index1 = allocate(Value, 2)
    index1[0] = make_int_value(0)
    index1[1] = make_int_value(0)
    let gep1_ret = make_local_value(pointer(enum_type), null, state)
    let gep1 = make_insn(InsnKind::GETELEMENTPTR)
    gep1.value.gep = {
        ret = gep1_ret,
        tpe = values_sarray,
        value = values,
        index = index1
    } !InsnGetElementPtr
    push_insn(gep1, state)

    let index2 = allocate(Value, 3)
    index2[0] = make_int_value(0)
    index2[1] = make_int_value(10)
    index2[2] = make_int_value(1)
    let gep2_ret = make_local_value(pointer(pointer(enum_type)), null, state)
    let gep2 = make_insn(InsnKind::GETELEMENTPTR)
    gep2.value.gep = {
        ret = gep2_ret,
        tpe = builtins::Type_,
        value = global,
        index = index2
    } !InsnGetElementPtr
    push_insn(gep2, state)

    let store = make_insn(InsnKind::STORE)
    store.value.store = {
        loc = gep2_ret,
        value = gep1_ret
    }
    push_insn(store, state)
}

def push_type_member(exported: bool, f_name: string, pars: *vector::Vector, rets: *vector::Vector, module: *toolchain::Module, state: *State) -> Value {
    
    let name_values = allocate(Value, 2)
    name_values[0] = { kind = ValueKind::INT, tpe = builtins::int64_, i = f_name.size } !Value
    name_values[1] = { kind = ValueKind::UNDEF, tpe = pointer(builtins::int8_) } !Value

    let module_values = allocate(Value, 2)
    module_values[0] = { kind = ValueKind::INT, tpe = builtins::int64_, i = module.module.size } !Value
    module_values[1] = { kind = ValueKind::UNDEF, tpe = pointer(builtins::int8_) } !Value

    let parameter_t_values = allocate(Value, 2)
    parameter_t_values[0] = { kind = ValueKind::INT, tpe = builtins::int64_, i = vector::length(pars) }
    parameter_t_values[1] = { kind = ValueKind::UNDEF, tpe = pointer(pointer(builtins::Type_)) }

    let return_t_values = allocate(Value, 2)
    return_t_values[0] = { kind = ValueKind::INT, tpe = builtins::int64_, i = vector::length(rets) }
    return_t_values[1] = { kind = ValueKind::UNDEF, tpe = pointer(pointer(builtins::Type_)) }

    let member_values = allocate(Value, 5)
    member_values[0] = { kind = ValueKind::STRUCT, tpe = builtins::string_, values = name_values } !Value
    member_values[1] = { kind = ValueKind::BOOL, tpe = builtins::bool_, i = exported !int64 } !Value
    member_values[2] = { kind = ValueKind::STRUCT, tpe = builtins::string_, values = module_values } !Value
    member_values[3] = { kind = ValueKind::STRUCT, tpe = array(pointer(builtins::Type_)), values = parameter_t_values } !Value
    member_values[4] = { kind = ValueKind::STRUCT, tpe = array(pointer(builtins::Type_)), values = return_t_values } !Value

    var member = { kind = ValueKind::STRUCT, tpe = builtins::Function_, values = member_values } !Value

    let name_v = charp(f_name, state)
    let module_v = charp(module.module, state)

    var parameter_t_ret = NO_VALUE
    if vector::length(pars) > 0 {
        let parameter_t_s_array = make_static_array(pointer(builtins::Type_), vector::length(pars))
        let parameter_t = make_global_value(parameter_t_s_array, "parameter_t", null, state)
        parameter_t_ret = state.gep(pointer(pointer(builtins::Type_)), parameter_t_s_array, parameter_t, [0, 0])

        for var i in 0..vector::length(pars) {
            let np = vector::get(pars, i) !*typechecking::NamedParameter
            let gep_ret = state.gep(pointer(pointer(builtins::Type_)), parameter_t_s_array, parameter_t, [0, i])
            var tpe = np.tpe
            if np.varargs {
                if tpe {
                    tpe = array(tpe.tpe)
                } else {
                    tpe = array(null)
                }
            }
            state.store(gep_ret, @create_type(tpe, module))
        }
    }
    
    var return_t_ret = NO_VALUE
    if vector::length(rets) > 0 {
        let return_t_s_array = make_static_array(pointer(builtins::Type_), vector::length(rets))
        let return_t = make_global_value(return_t_s_array, "return_t", null, state)
        return_t_ret = state.gep(pointer(pointer(builtins::Type_)), return_t_s_array, return_t, [0, 0])

        for var i in 0..vector::length(rets) {
            let tpe = vector::get(rets, i) !*typechecking::Type
            let gep_ret = state.gep(pointer(pointer(builtins::Type_)), return_t_s_array, return_t, [0, i])
            state.store(gep_ret, @create_type(tpe, module))
        }
    }
    
    member = state.insert_value(builtins::Function_, member, name_v, [0, 1])
    member = state.insert_value(builtins::Function_, member, module_v, [2, 1])
    if vector::length(pars) > 0 { 
        member = state.insert_value(builtins::Function_, member, parameter_t_ret, [3, 1])
    }
    if vector::length(rets) > 0 {
        member = state.insert_value(builtins::Function_, member, return_t_ret, [4, 1])
    }

    return member
}

def push_type_members(tpe: *Type, global: Value, module: *toolchain::Module, state: *State) {
    let member_functions = typechecking::get_member_functions(tpe)
    if vector::length(member_functions) == 0 { return }

    let members_sarray = make_static_array(builtins::Function_, vector::length(member_functions))
    let members = make_global_value(members_sarray, "type_members", null, state)

    for var i in 0..vector::length(member_functions) {
        let member_function = vector::get(member_functions, i) !*TypeEntryMember
        let function = member_function.function

        let member = push_type_member(
            member_function.exported, 
            function.type_name, 
            function.parameter_t, function.return_t, 
            module, state)

        let gep_ret = state.gep(pointer(builtins::Function_), members_sarray, members, [0, i])
        state.store(gep_ret, member)
    }

    let gep_ret = state.gep(pointer(builtins::Function_), members_sarray, members, [0, 0])
    let gep2_ret = state.gep(pointer(pointer(builtins::Function_)), builtins::Type_, global, [0, 13, 1])
    state.store(gep2_ret, gep_ret)
}

def push_structural_members(tpe: *Type, global: Value, module: *toolchain::Module, state: *State) {
    
    let structure = tpe.structure
    if vector::length(structure.members) == 0 { return }

    let members_sarray = make_static_array(builtins::Function_, vector::length(structure.members))
    let members = make_global_value(members_sarray, "structural_members", null, state)

    for var i in 0..vector::length(structure.members) {
        let smember = vector::get(structure.members, i) !*typechecking::StructuralTypeMember

        // TODO exported same as type?
        let member = push_type_member(false, smember.name, smember.parameter_t, smember.return_t, module, state)
        let gep_ret = state.gep(pointer(builtins::Function_), members_sarray, members, [0, i])
        state.store(gep_ret, member)
    }

    let gep_ret = state.gep(pointer(builtins::Function_), members_sarray, members, [0, 0])
    let gep2_ret = state.gep(pointer(pointer(builtins::Function_)), builtins::Type_, global, [0, 12, 1])
    state.store(gep2_ret, gep_ret)
}

def do_create_type(tpe: *Type, svalue: *scope::Value, module: *toolchain::Module) -> *Value {
    let state = *toolchain::types_state
    
    // We need an independent block that we can run for constant evaluation
    let old_block = toolchain::types_state.current_block
    let new_block = make_block()
    new_block.counter = old_block.counter
    state.current_block = new_block
    
    let global = { kind = ValueKind::GLOBAL, tpe = pointer(builtins::Type_), name = svalue.assembly_name } !Value

    let field_type = scope::get_type(toolchain::runtime.scope, make_identifier(["Field"]))
    let enum_type = scope::get_type(toolchain::runtime.scope, make_identifier(["EnumValue"]))

    let value = zero_allocate(Value)

    let global2 = allocate(Global)
    @global2 = {
        private = false,
        name = svalue.assembly_name,
        tpe = svalue.tpe,
        value = value,
        line = -1
    }
    map::put(toolchain::types.result.globals, global2.name, global2)
    map::put(toolchain::types.imported, global2.name, map::sentinel)

    let name_str = debug::type_to_str(tpe, true)

    let name_values = allocate(Value, 2)
    name_values[0] = { kind = ValueKind::INT, tpe = builtins::int64_, i = name_str.size } !Value
    name_values[1] = { kind = ValueKind::UNDEF, tpe = pointer(builtins::int8_) } !Value

    let module_values = allocate(Value, 2)
    module_values[0] = { kind = ValueKind::INT, tpe = builtins::int64_, i = module.module.size } !Value
    module_values[1] = { kind = ValueKind::UNDEF, tpe = pointer(builtins::int8_) } !Value

    let type_names = allocate(Value, 2)
    type_names[0] = { kind = ValueKind::INT, tpe = builtins::int64_, i = vector::length(typechecking::get_member_functions(tpe)) } !Value
    type_names[1] = { kind = ValueKind::UNDEF, tpe = pointer(builtins::Function_) } !Value

    value.values = zero_allocate(Value, 14)
    value.values[1] = { kind = ValueKind::STRUCT, tpe = builtins::string_, values = name_values } !Value
    value.values[2] = { kind = ValueKind::INT, tpe = builtins::bool_, i = tpe.unsig !int64 } !Value
    value.values[3] = { kind = ValueKind::UNDEF, tpe = builtins::size_t_ } !Value
    value.values[4] = { kind = ValueKind::UNDEF, tpe = pointer(builtins::Type_) } !Value
    value.values[5] = { kind = ValueKind::INT, tpe = builtins::size_t_, i = tpe.size } !Value
    value.values[6] = { kind = ValueKind::INT, tpe = builtins::size_t_, i = tpe.align } !Value
    value.values[7] = { kind = ValueKind::UNDEF, tpe = array(field_type) } !Value
    value.values[8] = { kind = ValueKind::UNDEF, tpe = array(pointer(builtins::Type_)) } !Value
    value.values[9] = { kind = ValueKind::UNDEF, tpe = array(pointer(builtins::Type_)) } !Value
    value.values[10] = { kind = ValueKind::UNDEF, tpe = array(enum_type) } !Value
    value.values[11] = { kind = ValueKind::STRUCT, tpe = builtins::string_, values = module_values } !Value
    value.values[12] = { kind = ValueKind::UNDEF, tpe = array(builtins::Function_) } !Value
    value.values[13] = { kind = ValueKind::STRUCT, tpe = array(builtins::Function_), values = type_names } !Value

    let index = allocate(Value, 3)
    index[0] = make_int_value(0)
    index[1] = make_int_value(1)
    index[2] = make_int_value(1)

    let gep_ret = make_local_value(pointer(pointer(builtins::char_)), null, state)
    let gep = make_insn(InsnKind::GETELEMENTPTR)
    gep.value.gep = {
        ret = gep_ret,
        tpe = builtins::Type_,
        value = global,
        index = index
    } !InsnGetElementPtr
    push_insn(gep, state)

    let name = charp(name_str, state)
    let store = make_insn(InsnKind::STORE)
    store.value.store = {
        loc = gep_ret,
        value = name
    } !InsnStore
    push_insn(store, state)
    
    let index2 = allocate(Value, 3)
    index2[0] = make_int_value(0)
    index2[1] = make_int_value(11)
    index2[2] = make_int_value(1)

    let gep2_ret = make_local_value(pointer(pointer(builtins::char_)), null, state)
    let gep2 = make_insn(InsnKind::GETELEMENTPTR)
    gep2.value.gep = {
        ret = gep2_ret,
        tpe = builtins::Type_,
        value = global,
        index = index2
    } !InsnGetElementPtr
    push_insn(gep2, state)

    let module_name = charp(module.module, state)
    let store2 = make_insn(InsnKind::STORE)
    store2.value.store = {
        loc = gep2_ret,
        value = module_name
    } !InsnStore
    push_insn(store2, state)

    switch tpe.kind !int {
        case TypeKind::STRUCT, TypeKind::UNION:
            value.values[0] = { kind = ValueKind::INT, tpe = builtins::int_, i = 3 if tpe.kind == TypeKind::STRUCT else 4 } !Value
            let field_values = allocate(Value, 2)
            field_values[0] = { kind = ValueKind::INT, tpe = builtins::int64_, i = tpe.fields.size } !Value
            field_values[1] = { kind = ValueKind::UNDEF, tpe = pointer(field_type) } !Value
            value.values[7] = { kind = ValueKind::STRUCT, tpe = array(field_type), values = field_values } !Value
            push_struct_members(tpe, global, module, state)
        case TypeKind::BOOL:
            value.values[0] = { kind = ValueKind::INT, tpe = builtins::int_, i = 0 } !Value
        case TypeKind::WORD:
            value.values[0] = { kind = ValueKind::INT, tpe = builtins::int_, i = 1 } !Value
        case TypeKind::CHAR:
            value.values[0] = { kind = ValueKind::INT, tpe = builtins::int_, i = 11 } !Value
        case TypeKind::FLOAT:
            value.values[0] = { kind = ValueKind::INT, tpe = builtins::int_, i = 2 } !Value
        case TypeKind::ARRAY:
            create_type(tpe.tpe, module)
            value.values[0] = { kind = ValueKind::INT, tpe = builtins::int_, i = 5 } !Value
            push_tpe_tpe(tpe, global, module, state)
        case TypeKind::STATIC_ARRAY:
            create_type(tpe.tpe, module)
            value.values[0] = { kind = ValueKind::INT, tpe = builtins::int_, i = 6 } !Value
            value.values[3] = { kind = ValueKind::INT, tpe = builtins::size_t_, i = tpe.length} !Value
            push_tpe_tpe(tpe, global, module, state)
        case TypeKind::POINTER:
            create_type(tpe.tpe, module)
            value.values[0] = { kind = ValueKind::INT, tpe = builtins::int_, i = 7 } !Value
            push_tpe_tpe(tpe, global, module, state)
        case TypeKind::REFERENCE:
            create_type(tpe.tpe, module)
            value.values[0] = { kind = ValueKind::INT, tpe = builtins::int_, i = 8 } !Value
            push_tpe_tpe(tpe, global, module, state)
        case TypeKind::FUNCTION:
            //TODO Functions
            for var i in 0..vector::length(tpe.parameter_t) {
                let np = vector::get(tpe.parameter_t, i) !*NamedParameter
                create_type(np.tpe, module)
            }
            for var i in 0..vector::length(tpe.return_t) {
                create_type(vector::get(tpe.return_t, i) !*Type, module)
            }
            value.values[0] = { kind = ValueKind::INT, tpe = builtins::int_, i = 9 } !Value
        case TypeKind::ENUM:
            create_type(tpe.tpe, module)
            value.values[0] = { kind = ValueKind::INT, tpe = builtins::int_, i = 10 } !Value
            let enum_values = allocate(Value, 2)
            enum_values[0] = { kind = ValueKind::INT, tpe = builtins::int64_, i = map::size(tpe.scope.fields) } !Value
            enum_values[1] = { kind = ValueKind::UNDEF, tpe = pointer(enum_type) } !Value
            value.values[10] = { kind = ValueKind::STRUCT, tpe = array(enum_type), values = enum_values } !Value
            push_tpe_tpe(tpe, global, module, state)
            push_enum_values(tpe, global, module, state)
        case TypeKind::STUB:
            value.values[0] = { kind = ValueKind::INT, tpe = builtins::int_, i = 13 } !Value
        case TypeKind::STRUCTURAL:
            value.values[0] = { kind = ValueKind::INT, tpe = builtins::int_, i = 12 } !Value
            let stype_names = allocate(Value, 2)
            stype_names[0] = { kind = ValueKind::INT, tpe = builtins::int64_, i = vector::length(tpe.structure.members) } !Value
            stype_names[1] = { kind = ValueKind::UNDEF, tpe = pointer(builtins::Function_) } !Value
            value.values[12] = { kind = ValueKind::STRUCT, tpe = array(builtins::Function_), values = stype_names } !Value
            push_structural_members(tpe, global, module, state)
        case:
            error(tpe.kind, "\n")
            assert(false)
    }

    value.kind = ValueKind::STRUCT
    value.tpe = builtins::Type_

    let old_cstate_block = consteval::compiler_state.current_block
    let old_cstate_function = consteval::compiler_state.current_function

    let function = allocate(Function)
    @function = {
        name = "main",
        unmangled = "main",
        forward_declare = true,
        allocas = vector::make(),
        block = new_block
    } !Function
    consteval::compiler_state.current_function = function
    consteval::compiler_state.current_block = new_block
    
    // Copy constants into the right module
    // TODO This always copies the whole thing
    let keys = map::keys(toolchain::types.result.globals)
    for var i in 0..keys.size {
        let key = keys[i]
        let global = map::get(toolchain::types.result.globals, key)
        map::put(consteval::const_module.result.globals, key, global)
    }

    let old_module = consteval::compiler_state.module
    consteval::compiler_state.module = consteval::const_module
    eval::eval(*consteval::compiler_state)
    consteval::compiler_state.module = old_module

    old_block.counter = new_block.counter
    for var i in 0..vector::length(new_block.insn) {
        vector::push(old_block.insn, vector::get(new_block.insn, i))
    }
    state.current_block = old_block

    consteval::compiler_state.current_block = old_cstate_block
    consteval::compiler_state.current_function = old_cstate_function

    push_type_members(tpe, global, module, state)

    return value
}

// Vector of ToResolve
let types_to_resolve = vector::make()
type ToResolve = struct {
    module: *toolchain::Module
    tpe: *typechecking::Type
}

// This is needed because some of the types might be stubs when they are first referenced
// Resolve these later
export def resolve_types {
    for var i in 0..vector::length(types_to_resolve) {
        let to_resolve = vector::get(types_to_resolve, i) !*ToResolve
        let tpe = to_resolve.tpe
        if tpe.kind == typechecking::TypeKind::STUB { continue }

        let ident = make_identifier([debug::type_to_str(tpe, true)])
        ident.loc.module = "type"
        
        let svalue = scope::get(toolchain::types.scope, ident)
        svalue.value = do_create_type(tpe, svalue, to_resolve.module)
    }
}

export def create_type(tpe: *Type, module: *toolchain::Module) -> *Value {
    if not tpe { return null }
    if tpe.kind == typechecking::TypeKind::STUB {
        let to_resolve = allocate(ToResolve)
        @to_resolve = { module, tpe } !ToResolve
        vector::push(types_to_resolve, to_resolve)
    }

    let ident = make_identifier([debug::type_to_str(tpe, true)])
    ident.loc.module = "type"

    var svalue = scope::get(toolchain::types.scope, ident, false, false)
    if not svalue {
        svalue = scope::create_variable(
            toolchain::types.scope, ident, parser::ShareMarker::NONE, 
            parser::VarDecl::CONST, builtins::Type_, 
            false, false, null, scope::Phase::DEFINED, null, null)

        svalue = scope::create_variable(
            toolchain::types.scope, 
            ident, parser::ShareMarker::NONE, parser::VarDecl::CONST, 
            builtins::Type_, do_create_type(tpe, svalue, module))
    }
    if not map::contains(module.result.globals, svalue.assembly_name) {
        let global = allocate(Global)
        @global = {
            external = true,
            name = svalue.assembly_name,
            tpe = svalue.tpe,
            line = -1
        }
        map::put(module.result.globals, global.name, global)
        map::put(module.imported, global.name, map::sentinel)
    }

    let value = allocate(Value)
    @value = {
        kind = ValueKind::GLOBAL,
        tpe = typechecking::pointer(builtins::Type_), 
        name = svalue.assembly_name
    } !Value

    value.value_tpe = tpe

    return value
}

def change_value_to_type(tpe: *Type, state: *State) -> *scope::Value {
    let type_tpe = copy(builtins::Type_)
    type_tpe.tpe = tpe 
    import_structures(builtins::Type_, state.module)
    
    let value = zero_allocate(scope::Value)
    value.tpe = typechecking::pointer(type_tpe)
    value.value = create_type(tpe, state.module)

    return value
}


export def make_result -> *Result {
    let result = allocate(Result)
    @result = {
        functions = map::make(),
        structures = map::make(),
        globals = map::make(),
        metadata = map::make()
    } !Result
}

export def make_state(module: *toolchain::Module) -> State {
    let state = {
        module = module,
        loops = vector::make(),
        ditypes = map::make(),
        discope = vector::make(),
        current_block = make_block(),
        globals = map::make()
    } !State

    return state
}

export def predeclare_functions(module: *toolchain::Module) {
    let sc = module.scope
    if sc.imports {
        for var i in 0..vector::length(sc.imports) {
            let imported_module = vector::get(sc.imports, i) !*toolchain::Module
            let m_scope = imported_module.scope
            let keys = map::keys((@m_scope).fields)
            for var i in 0..keys.size {
                var value = map::get((@m_scope).fields, keys[i]) !*scope::Value
                while value {
                    if (@value).share !int & parser::ShareMarker::EXPORT !int {
                        if typechecking::is_function((@value).tpe) {
                            let fun = predeclare_function(value.tpe, imported_module)
                            map::put(module.result.functions, value.tpe.type_name, fun)
                        } else if not typechecking::is_type((@value).tpe) {
                            let name = (@value).assembly_name
                            let global = allocate(Global)
                            (@global) = {
                                name = name,
                                tpe = (@value).tpe,
                                external = true,
                                line = -1
                            } !Global
                            map::put(module.result.globals, name, global)
                        }
                    }
                    value = (@value).next
                }
            }
        }
    }
}

def generate_vtable_function(function: *Function, tpe: *typechecking::Type, state: *State) {
    let first_param = (vector::get(tpe.parameter_t, 0) !*typechecking::NamedParameter).tpe
    let intf = typechecking::get_interface(first_param)

    function.block = make_block()
    function.forward_declare = false
    state.current_block = function.block

    var ret_tpe: *typechecking::Type = null
    if vector::length(tpe.return_t) > 1 {
        ret_tpe = make_return_type(tpe)
    } else {
        ret_tpe = vector::peek(tpe.return_t) !*typechecking::Type
    }

    let equals = scope::get(toolchain::runtime.scope, parser::make_identifier(["equals"]))
    predeclare_function(equals.tpe, state.module)
    map::put(state.module.imported, equals.tpe.type_name, map::sentinel)

    // Extract type
    let ref_tpe = state.extract_value(
        typechecking::pointer(builtins::Type_), 
        { kind = ValueKind::LOCAL, tpe = first_param, name = "__ref.value"} !Value,
        [2]
    )
    let ref_tpe_deref = state.load(builtins::Type_, ref_tpe)
    let tpe_value = state.extract_value(
        typechecking::pointer(builtins::Type_),
        ref_tpe_deref,
        [4]
    )

    let keys = map::keys(typechecking::types_map)
    for var i in 0..keys.size {
        let type_entry = map::get(typechecking::types_map, keys[i]) !*typechecking::TypeEntry
        if is_ref(type_entry.tpe) and typechecking::implements(type_entry.tpe, intf, state.module) {
            import_structure(type_entry.tpe.tpe, state.module)
            map::put(state.module.imported, type_entry.tpe.tpe.type_name, map::sentinel)

            let parameter_t = vector::copy(tpe.parameter_t)
            let np = allocate(typechecking::NamedParameter)
            @np = { name = "", tpe = type_entry.tpe }
            vector::set(parameter_t, 0, np)
            
            var score = util::MAX_INT32 !int
            var function: *typechecking::Type = null
            for var i in 0..vector::length(type_entry.functions) {
                let member = vector::get(type_entry.functions, i) !*typechecking::TypeEntryMember
                let s = typechecking::overload_score(member.function, parameter_t, state.module, true)
                if s < score { 
                    function = member.function
                    score = s
                }
            }

            predeclare_function(function, state.module)
            map::put(state.module.imported, function.type_name, map::sentinel)

            let cond = state.call(equals.tpe.type_name, builtins::bool_, [
                tpe_value,
                do_create_type(type_entry.tpe.tpe, state.module)
            ])

            let br = make_insn(InsnKind::BR)
            br.value.br = { cond = cond } !InsnBr
            push_insn(br, state)
            
            let if_true = make_label(state)
            br.value.br.if_true = if_true
            push_label(if_true, state)

            let reference = convert_ref_to_ref(type_entry.tpe, { kind = ValueKind::LOCAL, tpe = first_param, name = "__ref.value"} !Value, null, state)

            let args = allocate(Value, vector::length(tpe.parameter_t))
            args[0] = reference
            for var i in 1..vector::length(tpe.parameter_t) {
                let np = vector::get(tpe.parameter_t, i) !*typechecking::NamedParameter
                let buf = *buffer::make_buffer()
                buf.append_str(np.name)
                buf.append_str(".value")
                args[i] = { kind = ValueKind::LOCAL, tpe = np.tpe, name = buf.to_string() } !Value
            }
            let r = state.call(function.type_name, ret_tpe, args)
            state.ret(r)

            let if_false = make_label(state)
            br.value.br.if_false = if_false
            push_label(if_false, state)
        }
    }

    map::put(state.module.imported, "abort", map::sentinel)
    state.call("abort", null, [] ![Value])

    map::put(state.module.imported, function.name, map::sentinel)
    push_insn(make_insn(InsnKind::UNREACHABLE), state)
    
}

export var time_spent: int64 = 0

export def compile(module: *toolchain::Module) {
    let state = make_state(module)
    compile(*state, module.module == "main")
}

export def compile(state: *State, is_main: bool, no_cleanup: bool = false) {
    let start = util::millis()
    debug::trace("Compiling ", state.module.module)

    let node = state.module.node
    assert((@node).kind == parser::NodeKind::PROGRAM)

    import_structures(builtins::Type_, state.module)

    let body = vector::make()

    if not toolchain::is_preload(state.module) {
        // compile standard library
        let cstd_ident = parser::make_identifier(["cstd"])
        let std_indent = parser::make_identifier(["std"])
        let cstd = toolchain::compile_module(cstd_ident)
        let std = toolchain::compile_module(std_indent)
        insert_module_main(cstd, cstd_ident, node.scope, body, state)
        insert_module_main(std, std_indent, node.scope, body, state)
    }

    if is_main {
        // Import types
        let type_indent = parser::make_identifier(["type"])
        insert_module_main(toolchain::types, type_indent, node.scope, body, state)

        // Import runtime
        let runtime_ident = parser::make_identifier(["runtime"])
        insert_module_main(toolchain::runtime, runtime_ident, node.scope, body, state)

        // Import preload
        let preload_ident = parser::make_identifier(["preload"])
        let preload = toolchain::compile_module(preload_ident)
        insert_module_main(preload, preload_ident, node.scope, body, state)
    }

    var globals: *Value = null
    // Create compilation unit and file
    if toolchain::debug_sym {
        var dirname = util::dirname(state.module.filename)
        if length(dirname) == 0 { dirname = "." }
        let abspath = allocate(char, PATH_MAX)
        absolute_path(dirname, *abspath)
        abspath.size = strlen(abspath) + 1
        let file = util::basename(state.module.filename)

        let dvalues1 = allocate(DebugParam, 2)
        dvalues1[0] = {
            name = "filename", value = { kind = DebugValueKind::STRING, s = file } !DebugValue
        } !DebugParam
        dvalues1[1] = {
            name = "directory", value = { kind = DebugValueKind::STRING, s = abspath } !DebugValue
        } !DebugParam

        let difile = allocate(Value)
        @difile = {
            kind = ValueKind::DEBUG_INFO,
            metadata = true,
            name = "DIFile",
            debug_values = dvalues1
        } !Value
        state.difile = push_meta(difile, state)
        vector::push(state.discope, state.difile)

        globals = allocate(Value)
        let dvalues2 = allocate(DebugParam, 6)
        dvalues2[0] = {
            name = "language", value = { kind = DebugValueKind::CONST, name = "DW_LANG_C99" } !DebugValue
        } !DebugParam
        dvalues2[1] = {
            name = "file", value = meta_to_debug_value(state.difile)
        } !DebugParam
        dvalues2[2] = {
            name = "producer", value = { kind = DebugValueKind::STRING, s = toolchain::version } !DebugValue
        } !DebugParam
        dvalues2[3] = {
            name = "isOptimized", value = { kind = DebugValueKind::BOOL, i = 0 } !DebugValue
        } !DebugParam
        dvalues2[4] = {
            name = "emissionKind", value = { kind = DebugValueKind::CONST, name = "FullDebug" } !DebugValue
        } !DebugParam
        dvalues2[5] = {
            name = "globals", value = meta_to_debug_value(push_meta(globals, state))
        } !DebugParam

        let diunit = allocate(Value)
        @diunit = {
            kind = ValueKind::DEBUG_INFO,
            metadata = true,
            distinct = true,
            name = "DICompileUnit",
            debug_values = dvalues2
        } !Value
        state.diunit = push_meta(diunit, state)

        let values = allocate(Value, 1)
        values[0] = @state.diunit
        let dbgcu = allocate(Value)
        @dbgcu = {
            kind = ValueKind::STRUCT,
            metadata = true,
            values = values
        } !Value
        map::put(state.module.result.metadata, "llvm.dbg.cu", dbgcu)

        let values2 = allocate(Value, 3)
        values2[0] = { ValueKind::INT, i = 7, tpe = builtins::int_ } !Value
        values2[1] = { ValueKind::STRING, metadata = true, s = "Dwarf Version" } !Value
        values2[2] = { ValueKind::INT, i = 4, tpe = builtins::int_ } !Value
        let dwarfv = allocate(Value)
        @dwarfv = {
            kind = ValueKind::STRUCT,
            metadata = true,
            values = values2
        } !Value
        let dwarfvp = push_meta(dwarfv, state)

        let values3 = allocate(Value, 3)
        values3[0] = { ValueKind::INT, i = 2, tpe = builtins::int_ } !Value
        values3[1] = { ValueKind::STRING, metadata = true, s = "Debug Info Version" } !Value
        values3[2] = { ValueKind::INT, i = 3, tpe = builtins::int_ } !Value
        let div = allocate(Value)
        @div = {
            kind = ValueKind::STRUCT,
            metadata = true,
            values = values3
        } !Value
        let divp = push_meta(div, state)

        let values4 = allocate(Value, 3)
        values4[0] = { ValueKind::INT, i = 1, tpe = builtins::int_ } !Value
        values4[1] = { ValueKind::STRING, metadata = true, s = "wchar_size" } !Value
        values4[2] = { ValueKind::INT, i = 4, tpe = builtins::int_ } !Value
        let wchars = allocate(Value)
        @wchars = {
            kind = ValueKind::STRUCT,
            metadata = true,
            values = values4
        } !Value
        let wcharsp = push_meta(wchars, state)
        
        let values5 = allocate(Value, 3)
        values5[0] = @dwarfvp
        values5[1] = @divp
        values5[2] = @wcharsp
        let flags = allocate(Value)
        @flags = {
            kind = ValueKind::STRUCT,
            metadata = true,
            values = values5
        } !Value
        map::put(state.module.result.metadata, "llvm.module.flags", flags)

        let values6 = allocate(Value, 1)
        values6[0] = { ValueKind::STRING, metadata = true, s = toolchain::version } !Value
        let identv = allocate(Value)
        @identv = {
            kind = ValueKind::STRUCT,
            metadata = true,
            values = values6
        } !Value
        let identp = push_meta(identv, state)

        let values7 = allocate(Value, 1)
        values7[0] = @identp
        let ident = allocate(Value)
        @ident = {
            kind = ValueKind::STRUCT,
            metadata = true,
            values = values7
        } !Value
        map::put(state.module.result.metadata, "llvm.ident", ident)
    }
    
    // Forward declare functions from other files
    // TODO This doesn't work for functions that return multiple parameters
    predeclare_functions(state.module)

    let ident = parser::make_identifier(["main"])
    (@ident).loc.module = state.module.module
    (@ident).loc.filename = state.module.filename
    (@ident).loc.line = 0
    (@ident).loc.column = 0

    let string_array_tpe = typechecking::array(builtins::string_)

    let named = allocate(typechecking::NamedParameter)
    @named = {
        name = "args",
        tpe = string_array_tpe
    } !typechecking::NamedParameter
    let args = vector::make()
    vector::push(args, named)

    let main_tpe = typechecking::make_function_type_n(ident, args, vector::make(), false, false)
    scope::create_function(node.scope, ident, parser::ShareMarker::EXPORT, main_tpe)
    
    for var i in 0..vector::length(state.module.dyn_dispatch) {
        let tpe = vector::get(state.module.dyn_dispatch, i) !*typechecking::Type
        let function = predeclare_function(tpe, state.module)
        generate_vtable_function(function, tpe, state)
    }

    predeclare_function(main_tpe, state.module)

    for var i in 0..vector::length(node.value.body) {
        let n = vector::get(node.value.body, i) !*parser::Node
        if n.kind == parser::NodeKind::DEF and not typechecking::is_polymorph(n.tpe) {
            predeclare_function(n.tpe, state.module)
        }
    }

    state.current_block = state.module.code
    for var i in 0..vector::length((@node).value.body) {
        let n = vector::get((@node).value.body, i) !*parser::Node
        switch (@n).kind !int {
            case parser::NodeKind::DEF:
                if n.value.def_.body and not typechecking::is_polymorph(n.tpe) {
                    create_function(n, n.tpe, n.value.def_.body, n.inner_scope, null, state)
                }
            case parser::NodeKind::TYPE_DECL:
                walk_TypeDecl(n, state)
            case parser::NodeKind::VAR_DECL:
                walk_top_VarDecl(n, body, state)
            case parser::NodeKind::IMPORT:
                walk_top_Import(n, body, state)
            case:
                vector::push(body, n)
        }
    }

    create_function(ident, main_tpe, body, node.scope, state.module.code, state, no_cleanup)

    if toolchain::debug_sym {
        let keys = map::keys(state.module.result.globals)
        let values = allocate(Value, keys.size)
        for var i in 0..keys.size {
            let global = map::get(state.module.result.globals, keys[i]) !*Global

            let debug_values = allocate(DebugParam, 6)
            debug_values[0] = {
                name = "name", value = { kind = DebugValueKind::STRING, s = (@global).name } !DebugValue
            } !DebugParam
            debug_values[1] = {
                name = "scope", value = meta_to_debug_value(state.diunit)
            } !DebugParam
            debug_values[2] = {
                name = "file", value = meta_to_debug_value(state.difile)
            } !DebugParam
            debug_values[3] = {
                name = "line", value = { kind = DebugValueKind::INT, i = (@global).line + 1 } !DebugValue
            } !DebugParam
            debug_values[4] = {
                name = "type", value = meta_to_debug_value(di_type((@global).tpe, state))
            } !DebugParam
            debug_values[5] = {
                name = "isDefinition", value = { kind = DebugValueKind::BOOL, i = (not (@global).external) !int } !DebugValue
            } !DebugParam

            let diglobal = allocate(Value)
            @diglobal = {
                kind = ValueKind::DEBUG_INFO,
                name = "DIGlobalVariable",
                debug_values = debug_values,
                distinct = true
            } !Value
            let diglobalp = push_meta(diglobal, state)

            let debug_values2 = allocate(DebugParam, 2)
            debug_values2[0] = {
                name = "var", value = meta_to_debug_value(diglobalp)
            } !DebugParam
            debug_values2[1] = {
                name = "expr", value = { kind = DebugValueKind::DIEXP } !DebugValue
            } !DebugParam

            let diglobal_expr = allocate(Value)
            @diglobal_expr = {
                kind = ValueKind::DEBUG_INFO,
                name = "DIGlobalVariableExpression",
                debug_values = debug_values2
            } !Value
            let diglobal_exprp = push_meta(diglobal_expr, state)

            values[i] = @diglobal_exprp
            (@global).debug = diglobal_exprp
        }
        @globals = {
            kind = ValueKind::STRUCT,
            metadata = true,
            values = values
        } !Value
    }

    let end = util::millis()
    time_spent += end - start
}
