// This is the entry point for a language server as defined by the LSP
import vector
import map
import json
import toolchain
import parser

import document
import cache

const VERSION = "0.0.1"

const ParseError = -32700
const InvalidRequest = -32600
const MethodNotFound = -32601
const InvalidParams = -32602
const InternalError = -32603

const ServerNotInitialized = -32002
const UnknownErrorCode = -32001

type MessageType = enum {
    Error = 1
    Warning = 2
    Info = 3
    Log = 4
}

export type DocumentUri = &string

export def uri_to_path(uri: DocumentUri) -> &string {
    if uri.starts_with("file://") {
        return uri.substring(7)
    }
    abort("Unsupported protocol in uri: " + uri)
}

export def path_to_uri(path: &string) -> DocumentUri {
    return "file://" + path
}

export type TextDocumentIdentifier = struct {
    uri: DocumentUri
}

export type Range = struct {
	start: Position
	end: Position
}

export type Location = struct {
	uri: DocumentUri
	range: Range
}

export type Position = struct {
    line: int
    character: int
}

type WorkspaceFolder = struct {
    uri: DocumentUri
    name: &string
}

type TextDocumentItem = struct {
    uri: DocumentUri
    languageId: &string
    version: int
    text: &string
}

type DidOpenTextDocumentParams = struct {
    textDocument: TextDocumentItem
}

def did_open(id: int, params: DidOpenTextDocumentParams) {
    if params.textDocument.languageId != "princess" { return }
    document::open_document(params.textDocument.uri, params.textDocument.text)
}

type VersionedTextDocumentIdentifier = struct {
    uri: DocumentUri
    version: int
}

export type TextDocumentContentChangeEvent = struct {
    range: &Json
    text: &string
}

type DidChangeTextDocumentParams = struct {
    textDocument: VersionedTextDocumentIdentifier
    contentChanges: &[TextDocumentContentChangeEvent]
}

def did_change(id: int, params: DidChangeTextDocumentParams) {
    document::change_document(params.textDocument.uri, params.contentChanges)
}

export type DidSaveTextDocumentParams = struct {
    textDocument: TextDocumentIdentifier
    text: &string
}

def did_save(id: int, params: DidSaveTextDocumentParams) {
    document::save_document(params.textDocument.uri, params.text)
}

type DefinitionParams = struct {
    textDocument: TextDocumentIdentifier
    position: Position
}

def go_to_definition(id: int, params: DefinitionParams) {
    let module = toolchain::find_module_by_path(uri_to_path(params.textDocument.uri))
    if not module { send_reply(id, null); return }
    let node = parser::find(module.node, params.position.line, params.position.character)
    if not node { send_reply(id, null); return }
    if node.kind != parser::NodeKind::IDENTIFIER { send_reply(id, null); return }
    let svalue = node.svalue
    if not svalue { send_reply(id, null); return }
    let sloc = svalue.loc
    if parser::is_invalid(sloc) { send_reply(id, null); return }
    //error("Go to: ", svalue !*, " ", sloc.line, " ", sloc.column, "\n")


    let loc = {
        uri = path_to_uri(sloc.filename),
        range = {
            start = { sloc.line, sloc.column } !Position,
            end = { sloc.end_line, sloc.end_column } !Position
        } !Range
    } !Location
    send_reply(id, json::serialize(*loc))
}

export type DiagnosticSeverity = enum {
    Error = 1
    Warning = 2
    Information = 3
    Hint = 4
}

export type Diagnostic = struct {
    range: Range
    severity: int
    message: &string
}

export type PublishDiagnosticsParams = struct {
    uri: DocumentUri
    diagnostics: &[Diagnostic]
}

export def publish_diagnostics(params: PublishDiagnosticsParams) {
    send_notification("textDocument/publishDiagnostics", json::serialize(*params))
}

type FileChangeType = enum {
    Created = 1
    Changed = 2
    Deleted = 3
}

type FileEvent = struct {
    uri: DocumentUri
    _type: uint
}

type DidChangeWatchedFilesParams = struct {
    changes: &[FileEvent]
}

def did_change_watched_files(id: int, params: DidChangeWatchedFilesParams) {
    for var event in @params.changes {
        switch event._type {
        case FileChangeType::Created:
            document::on_created(event.uri)
        case FileChangeType::Changed:
            document::on_changed(event.uri)
        case FileChangeType::Deleted:
            document::on_deleted(event.uri)
        }
    }
}

type InitializeParams = struct {
    processId: int
    clientInfo: struct {
        name: &string
        version: &string
    }
    locale: &string
    rootPath: &string
    rootUri: DocumentUri
    initializationOptions: &Json
    capabilities: &Json
    trace: &string
    workspaceFolders: &[WorkspaceFolder]
}

def initialize(id: int, params: InitializeParams) {
    let result = json::make_object()

    let capabilities = json::make_object()
    capabilities["positionEncoding"] = "utf-8"

    let sync_options = json::make_object()
    sync_options["change"] = 2 // Incremental
    sync_options["openClose"] = true

    let save_options = json::make_object()
    save_options["includeText"] = true
    sync_options["save"] = save_options

    capabilities["textDocumentSync"] = sync_options
    capabilities["definitionProvider"] = true

    let serverInfo = json::make_object()
    serverInfo["name"] = "Princess Language Server"
    serverInfo["version"] = VERSION

    result["capabilities"] = capabilities
    result["serverInfo"] = serverInfo
    
    send_reply(id, result)
}

def initialized {
    let watcherPr = json::make_object()
    watcherPr["globPattern"] = "**/*.pr"
    let watchers = json::make_array()
    watchers.push(watcherPr)

    let registerOptions = json::make_object()
    registerOptions["watchers"] = watchers

    let registration = json::make_object()
    registration["id"] = "didChangeWatchedFiles"
    registration["method"] = "workspace/didChangeWatchedFiles"
    registration["registerOptions"] = registerOptions

    let registrations = json::make_array()
    registrations.push(registration)

    let obj = json::make_object()
    obj["registrations"] = registrations

    def on_register(reply: &Json) {}
    send_request("client/registerCapability", obj, reply = on_register)
}

type Header = &Vector(&string)

def get(header: Header, key: &string) -> &string {
    for var i in 0..header.length {
        let entry = header[i]
        if entry.starts_with(key + ": ") {
            return entry.substring(entry.index_of(": ") + 2)
        }
    }
    return null
}

def read_header -> Header {
    let header = vector::make(type &string)
    loop {
        var s: &string = ""
        loop {
            var c: char
            if read(std::stdin(), *c) < 1 { return header }
            if c == '\r' {
                if read(std::stdin(), *c) < 1 { return header }
                if c == '\n' {
                    break
                }
            } else {
                s += c
            }
        }
        if s.length == 0 {
            break
        }
        header.push(s)
    }
    return header
}

def send_message(payload: &Json) {
    let message = to_string(payload)
    print("Content-Length: ", message.length, "\r\n")
    print("Content-Type: application/vscode-jsonrpc; charset=utf-8\r\n")
    print("\r\n")
    print(message)
    fflush(std::stdout())
}

def log_message(str: &string, tpe: int = MessageType::Log) {
    let obj = json::make_object()
    obj["type"] = tpe
    obj["message"] = str
    send_request("window/logMessage", obj)
}

var request_id: size_t = 0
def send_request(method: &string, params: &Json, reply: (&Json) -> ()) {
    on_reply(request_id, reply)
    send_request(method, params)
}

def send_request(method: &string, params: &Json) {
    let obj = json::make_object()
    obj["jsonrpc"] = "2.0"
    obj["id"] = request_id !int
    obj["method"] = method
    obj["params"] = params
    send_message(obj)
    request_id += 1
}

def send_notification(method: &string, params: &Json) {
    let obj = json::make_object()
    obj["jsonrpc"] = "2.0"
    obj["method"] = method
    obj["params"] = params
    send_message(obj)
}

def send_error(id: int, error_code: int, message: &string, data: &Json = null) {
    error(message, "\n")

    let obj = json::make_object()
    obj["jsonrpc"] = "2.0"
    obj["id"] = id

    let error = json::make_object()
    error["code"] = error_code
    error["message"] = message
    if data {
        error["data"] = data
    }
 
    obj["error"] = error

    send_message(obj)
}

def send_reply(id: int, data: &Json) {
    let obj = json::make_object()
    obj["jsonrpc"] = "2.0"
    obj["id"] = id
    obj["result"] = data
    send_message(obj)
}

def read_message -> &Json {
    let header = read_header()
    if not header {
        send_error(0, ParseError, "Invalid header")
        return null
    }
    let content_length = parse_int(header.get("Content-Length"))
    if content_length == 0 {
        send_error(0, ParseError, "Invalid Content-Length")
        return null
    }
    let encoding = header.get("Content-Type")
    if encoding {
        if encoding != "application/vscode-jsonrpc; charset=utf-8" and
            encoding != "application/vscode-jsonrpc; charset=utf8" {
            
            send_error(0, ParseError, "Incalid Content-Type")
            return null
        }
    }

    let message_str = zero_allocate(char, content_length + 1)
    read(std::stdin(), message_str, content_length)
    let message = json::parse(message_str)
    if message.status == json::Status::JSON_ERROR {
        send_error(0, ParseError, "Can't parse content as json")
        return null
    }
    return message
}

var is_initialized = false
var is_shutdown = false
var reply_handlers = map::make(size_t, type (&Json) -> ())

def on_reply(id: size_t, handler: (&Json) -> ()) {
    reply_handlers[id] = handler
}

export def main -> int {
    cache::setup_error_handler()

    // Preparing toolchain
    toolchain::prepare_preload()
    toolchain::reset_types()

    loop {
        let message = read_message()
        if message {
            let id = message["id"].as_int() if message.has_item("id") else 0
            var method = message["method"].as_string() if message.has_item("method") else null
            let params = message["params"]

            if not method {
                if message.has_item("error") {
                    let error_msg = message["error"]["message"].as_string()
                    error("Error: ", error_msg, "\n")
                } else {
                    let request_id = id !size_t
                    // This is a response
                    if not reply_handlers.contains(request_id) {
                        send_error(id, InvalidRequest, "Not a valid request id")
                        continue
                    }
                    let handler = reply_handlers[request_id]
                    handler(message["result"])
                    reply_handlers.remove(request_id)
                    continue
                }
            }
        
            if method == "exit" {
                if is_shutdown {
                    return 0
                } else {
                    return 1
                }
            }

            if is_shutdown {
                send_error(id, InvalidRequest, "Server is shut down")
                continue
            }

            if method == "shutdown" {
                is_shutdown = true
                send_reply(id, null)
                continue
            }

            if not is_initialized {
                if method == "initialize" {
                    is_initialized = true
                    let p = json::deserialize(params, InitializeParams)
                    if not p.exists { send_error(id, ParseError, "Couldn't parse parameters") }
                    else { initialize(id, p.get()) }
                } else {
                    send_error(id, ServerNotInitialized, "Server not initialized!")
                }
                continue
            }

            if method {
                if method == "initialized" {
                    initialized()
                } else if method == "textDocument/definition" {
                    let p = json::deserialize(params, DefinitionParams)
                    if not p.exists { send_error(id, ParseError, "Couldn't parse parameters") }
                    else { go_to_definition(id, p.get()) }
                } else if method == "textDocument/didOpen" {
                    let p = json::deserialize(params, DidOpenTextDocumentParams)
                    if not p.exists { send_error(id, ParseError, "Couldn't parse parameters") }
                    else { did_open(id, p.get()) }
                } else if method == "textDocument/didChange" {
                    let p = json::deserialize(params, DidChangeTextDocumentParams)
                    if not p.exists { send_error(id, ParseError, "Couldn't parse parameters") }
                    else { did_change(id, p.get()) }
                } else if method == "textDocument/didSave" {
                    let p = json::deserialize(params, DidSaveTextDocumentParams)
                    if not p.exists { send_error(id, ParseError, "Couldn't parse parameters") }
                    else { did_save(id, p.get()) }
                } else if method == "workspace/didChangeWatchedFiles" {
                    let p = json::deserialize(params, DidChangeWatchedFilesParams)
                    if not p.exists { send_error(id, ParseError, "Couldn't parse parameters") }
                    else { did_change_watched_files(id, p.get()) }
                } else {
                    send_error(id, MethodNotFound, "Method " + method + " not found")
                }
            } else {
                send_error(id, MethodNotFound, "No method specified")
            }
        }
    }
    return 1
}