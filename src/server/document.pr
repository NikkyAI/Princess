import vector
import map
import set
import toolchain
import json

import server
import cache

export def setup_file_loader {
    toolchain::file_loader = *load_file
}

export def load_file(filename: &string) -> &string {
    let module = toolchain::find_module_by_path(filename)
    if module {
        return module.text
    }
    let text = toolchain::load_file(filename)
    return text
}

export def open_document(uri: server::DocumentUri, text: &string) {
    let path = uri_to_path(uri)
    cache::recompile(path)
}

export def save_document(uri: server::DocumentUri, text: &string) {
    open_document(uri, text)
}

// TODO This is very inefficient, change the lexer to accept split lines as well instead
export def find_offset(text: &string, pos: server::U16Position) -> size_t {
    var u8_offset = 0
    var line = 0
    var u16_column = 0
    while u8_offset < text.length() {
        if line == pos.line and u16_column == pos.character {
            return u8_offset
        }
        let c = text[u8_offset]
        if c == '\r' {
            if u8_offset + 1 < text.length() {
                if text[u8_offset + 1] == '\n' {
                    u8_offset += 1
                }
            }
            u16_column = 0
            line += 1
            u8_offset += 1
        } else if c == '\n' {
            u16_column = 0
            line += 1
            u8_offset += 1
        } else {
            if c & 0xF0 == 0xC0 or c & 0xF0 == 0xD0 {
                u8_offset += 2
                u16_column += 1
            } else if c & 0xF0 == 0xE0 {
                u8_offset += 3
                u16_column += 2
            } else if c & 0xF0 == 0xF0 {
                u8_offset += 4
                u16_column += 2
            } else {
                u8_offset += 1
                u16_column += 1
            }
        }        
    }
    return u8_offset
}

export def u16_pos_to_u8(filename: &string, pos: server::U16Position) -> server::U8Position {
    let line = toolchain::find_module_by_path(filename).lines[pos.line]
    var u8_column = 0
    var u16_column = 0
    while u8_column < line.length {
        let c = line[u8_column]
        if c & 0xF0 == 0xC0 or c & 0xF0 == 0xD0 {
            u8_column += 2
            u16_column += 1
        } else if c & 0xF0 == 0xE0 {
            u8_column += 3
            u16_column += 2
        } else if c & 0xF0 == 0xF0 {
            u8_column += 4
            u16_column += 2
        } else {
            u8_column += 1
            u16_column += 1
        }
        if u16_column == pos.character { break }
    }
    return { pos.line, u8_column } !server::U8Position 
}

export def u8_pos_to_u16(filename: &string, pos: server::U8Position) -> server::U16Position {
    let line = toolchain::find_module_by_path(filename).lines[pos.line]
    var u8_column = 0
    var u16_column = 0
    while u8_column < line.length {
        let c = line[u8_column]
        if c & 0xF0 == 0xC0 or c & 0xF0 == 0xD0 {
            u8_column += 2
            u16_column += 1
        } else if c & 0xF0 == 0xE0 {
            u8_column += 3
            u16_column += 2
        } else if c & 0xF0 == 0xF0 {
            u8_column += 4
            u16_column += 2
        } else {
            u8_column += 1
            u16_column += 1
        }
        if u8_column == pos.character { break }
    }
    return { pos.line, u16_column } !server::U16Position 
}

export def change_document(uri: server::DocumentUri, changes: &[server::TextDocumentContentChangeEvent]) {
    let path = uri_to_path(uri)
    let module = toolchain::find_module_by_path(path)
    let text = module.text

    for var change in @changes {
        if change.range {
            // TODO this is ugly, allow optionals instead
            let range = json::deserialize(change.range, server::Range).get()
            let start_offset = find_offset(module.text, range.start)
            let end_offset = find_offset(module.text, range.end)

            if start_offset != end_offset {
                module.text.remove(
                    min(text.length() - 1, start_offset) !size_t, 
                    end_offset - 1
                )
            }
            if start_offset < text.length() {
                module.text.insert(start_offset, change.text)
            } else {
                module.text += change.text
            }

            cache::offset_errors(
                path, 
                u16_pos_to_u8(path, range.start),
                u16_pos_to_u8(path, range.end), 
                change.text
            )
        } else {
            module.text = change.text
        }
    }

    cache::recompile(path)
}

export def close_document(uri: server::DocumentUri) {
    // TODO
}

// File system events
export def on_created(uri: server::DocumentUri) {
    let path = uri_to_path(uri)
    if cache::check_imports(path) {
        cache::recompile(path)
    }
}

export def on_changed(uri: server::DocumentUri) {
    let path = uri_to_path(uri)
    if toolchain::find_module_by_path(path) {
        cache::recompile(path)
    }
}

export def on_deleted(uri: server::DocumentUri) {
    let path = uri_to_path(uri)
    cache::check_imports(path)
    toolchain::modules.remove(path)
}