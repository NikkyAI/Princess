// This scans a file and predeclares every type, function and variable
// It also evaluates constant expressions and static ifs

import vector
import map
import builtins
import toolchain
import scope
import parser
import typechecking
import compiler
import util
import debug
import errors

export let const_module = allocate(toolchain::Module)
@const_module = {
    module = "const",
    filename = "",
    scope = scope::enter_function_scope(builtins::builtins),
    result = compiler::make_result(),
    dependants = vector::make(),
    code = compiler::make_block(),
    imported = map::make()
} !toolchain::Module

// This is for compiling expressions
export let compiler_state = compiler::make_state(const_module)

import eval

export def make_value(value: compiler::Value) -> *scope::Value {
    let svalue = zero_allocate(scope::Value)
    let valuep = allocate(compiler::Value)
    @valuep = value
    svalue.value = valuep
    svalue.tpe = value.tpe
    return svalue
}

// If we store the state we need to create a permanent copy
def copy_state(state: *typechecking::State) -> *typechecking::State {
    let new_state = allocate(typechecking::State)
    @new_state = @state
    new_state.function_stack = vector::copy(state.function_stack)
    return new_state
}

def set_current_function {
    let block = compiler::make_block()
    let function = allocate(compiler::Function)
    @function = {
        name = "main",
        unmangled = "main",
        forward_declare = true,
        allocas = vector::make(),
        block = block
    } !compiler::Function
    compiler_state.current_function = function
    compiler_state.current_block = block
}

export def expr(node: *parser::Node, state: *typechecking::State) -> compiler::Value {
    if not node { return compiler::NO_VALUE }
    set_current_function()
    typechecking::walk(node.parent, node, state)
    var result = compiler::walk_expression(node, *compiler_state)
    let estate = eval::eval(*compiler_state)
    result = eval::get_value(result, *estate)
    return result
}

export def boolean_expr(node: *parser::Node, state: *typechecking::State) -> compiler::Value {
    if not node { return compiler::NO_VALUE }
    set_current_function()
    typechecking::walk(node.parent, node, state)
    var result = compiler::walk_expression(node, *compiler_state)
    result = compiler::convert_to(node, result, builtins::bool_, *compiler_state)
    let estate = eval::eval(*compiler_state)
    result = eval::get_value(result, *estate)
    return result
}

def walk_IfExpr(node: *parser::Node, state: *typechecking::State) {
    walk(node, node.value.if_expr.if_true, state)
    walk(node, node.value.if_expr.cond, state)
    walk(node, node.value.if_expr.if_false, state)
}

def walk_StaticIf(node: *parser::Node, state: *typechecking::State) {
    let is_static = state.is_static
    state.is_static = true
    walk(node, node.value.if_.cond, state)
    state.is_static = is_static
    var result = boolean_expr(node.value.if_.cond, state)

    var body: *vector::Vector = null
    if result.i {
        body = node.value.if_.body
    } else {
        for var i in 0..vector::length(node.value.if_.else_if) {
            let else_if = vector::get(node.value.if_.else_if, i) !*parser::Node
            let is_static = state.is_static
            state.is_static = true
            walk(else_if, else_if.value.else_if.cond, state)
            state.is_static = is_static
            result = boolean_expr(else_if.value.else_if.cond, state)
            if result.i { 
                body = else_if.value.else_if.body
                break
            }
        }
        let else_ = node.value.if_.else_
        if not result.i and else_ {
            body = else_.value.body
        }
    }
    
    let index = vector::index_of(node.parent.body, node)
    vector::remove(node.parent.body, index)
    if body {
        vector::insert(node.parent.body, index, body)
        for var i in 0..vector::length(body) {
            walk(node.parent, vector::get(body, i) !*parser::Node, state)
        }
    }
}

def walk_Import(node: *parser::Node, state: *typechecking::State) {
    let imports = (@node).value.body
    for var i in 0..vector::length(imports) {
        let imprt = vector::get(imports, i) !*parser::Node
        var name = (@imprt).value.import_module.name
        var alias = (@imprt).value.import_module.alias
        if not alias {
            alias = name
        }
        let module = toolchain::consteval_module(name)
        if not module {
            errors::errorn(name, "Module `", parser::identifier_to_str(name), "` could not be found")
            return
        }
        scope::insert_module(state.scope, alias, module)
    }
    compiler::predeclare_functions(state.module)
}

export def walk_Def_with_type_argument(node: *parser::Node, parameter_t: *vector::Vector, state: *typechecking::State) {
    node = parser::deep_copy_node(node)
    let share = node.value.def_.share
    let tpe = node.tpe

    tpe.is_polymorph = false
    var body = node.value.def_.body

    let function = allocate(typechecking::Function)
    @function = {
        tpe = tpe,
        locals = map::make(),
        has_defer = false
    }
    typechecking::push_function(state, function)

    state.scope = scope::enter_function_scope(state.scope)
    node.inner_scope = state.scope

    for var i in 0..vector::length(parameter_t) {
        let np = vector::get(parameter_t, i) !*typechecking::NamedParameter
        var left: *typechecking::NamedParameter = null
        if length(np.name) > 0 {
            for var j in 0..vector::length(tpe.parameter_t) {
                let l = vector::get(tpe.parameter_t, j) !*typechecking::NamedParameter
                if l.name == np.name {
                    left = l
                }
            }
        } else {
            left = vector::get(tpe.parameter_t, i) !*typechecking::NamedParameter
        }
        assert(left != null)

        if typechecking::equals(left.tpe, builtins::type_) {
            left.value = allocate(compiler::Value)
            @left.value = { kind = compiler::ValueKind::TYPE, tpe = builtins::type_, value_tpe = np.tpe.tpe.tpe } !compiler::Value
        }
    }

    let types_map = map::make()
    typechecking::replace_type_defs(tpe, parameter_t, true, types_map)

    let keys = map::keys(types_map)
    for var i in 0..keys.size {
        let key = keys[i]
        let tpe2 = map::get(types_map, key) !*typechecking::Type
        scope::create_type(state.scope, parser::make_identifier([key]), parser::ShareMarker::NONE, tpe2)
    }

    if vector::length(tpe.parameter_t) > 0 {
        let first_param = vector::get(tpe.parameter_t, 0) !*NamedParameter
        typechecking::create_type_entry(first_param.tpe, (share !int & parser::ShareMarker::EXPORT !int) != 0, tpe, state.module)
    }

    body = vector::copy(body)
    for var i in 0..vector::length(body) {
        walk(node, vector::get(body, i) !*parser::Node, state)
    }
    state.scope = scope::exit_scope(state.scope)

    node.value.def_.locals = function.locals
    node.value.def_.has_defer = function.has_defer
    typechecking::pop_function(state)

    typechecking::walk_Def(node, state, false)

    vector::push(state.module.node.body, node)
}

def walk_Def(node: *parser::Node, state: *typechecking::State) {
    let share = node.value.def_.share
    let name = node.value.def_.name
    let params = node.value.def_.params
    let returns = node.value.def_.returns
    let extern = node.value.def_.extern
    let dllimport = node.value.def_.dllimport
    var body = node.value.def_.body
    let imported = (share !int & parser::ShareMarker::IMPORT !int) !bool

    if share !int & parser::ShareMarker::IMPORT !int {
        node.value.def_.is_used = true
    }

    let parameter_t = vector::make()
    let return_t = vector::make()
    for var i in 0..vector::length(params) {
        let param = vector::get(params, i) !*parser::Node
        assert(param.kind == parser::NodeKind::PARAMETER)

        var tpe: *typechecking::Type = null
        if param.value.param.kw == parser::VarDecl::TYPE {
            tpe = typechecking::copy(builtins::type_)
            tpe.type_name = tpe.name = scope::last_path_element(param.value.param.name)
        } else {
            tpe = typechecking::type_lookup(param.value.param.tpe, state, true)
        }

        var value: *compiler::Value = null
        if param.value.param.value {
            set_current_function()
            typechecking::walk(node, param.value.param.value, state)
            var result = compiler::walk_expression(param.value.param.value, *compiler_state)
            let gvalue = compiler::make_global_value(result.tpe, "default_param", null, *compiler_state)
            let estate = eval::eval(*compiler_state)
            result = eval::get_value(result, *estate)

            if result.kind != compiler::ValueKind::NULL {
                eval::set_value(gvalue, result, *estate)

                let global = eval::serialize_value(gvalue.name, state.module, *compiler_state)
                value = allocate(compiler::Value)
                if global.value {
                    @value = @global.value

                    if not typechecking::is_assignable(tpe, value.tpe) {
                        errors::errorn(param.value.param.value, debug::type_to_str(value.tpe), " is not assignable to ", debug::type_to_str(tpe))
                    }
                } else {
                    global.private = false
                    @value = { kind = compiler::ValueKind::GLOBAL, tpe = typechecking::pointer(global.tpe), name = global.name } !compiler::Value

                    if not typechecking::is_assignable(tpe, global.tpe) {
                        errors::errorn(param.value.param.value, debug::type_to_str(global.tpe), " is not assignable to ", debug::type_to_str(tpe))
                    }
                }
            } else {
                if not typechecking::is_pointer(tpe) {
                    // TODO Null references?
                    errors::errorn(param.value.param.value, "Can only assign null to a pointer")
                }
                value = allocate(compiler::Value)
                @value = { kind = compiler::ValueKind::NULL, tpe = tpe }
            }
        }

        let name = param.value.param.name
        let named = allocate(typechecking::NamedParameter)

        @named = {
            name = last_ident_to_str(name),
            tpe = tpe,
            varargs = (@param).value.param.varargs,
            node = name,
            value = value
        } !typechecking::NamedParameter
            
        vector::push(parameter_t, named)
    }
    for var i in 0..vector::length(returns) {
        let n = vector::get(returns, i) !*parser::Node
        let tpe = typechecking::type_lookup(n, state, true)
        vector::push(return_t, tpe)
    }

    let tpe = typechecking::make_function_type_n(name, parameter_t, return_t, extern, imported, dllimport)
    
    tpe.is_polymorph = typechecking::is_polymorph(tpe)
    if body {
        scope::create_function(state.scope, name, share, tpe, scope::Phase::DEFINED, node, copy_state(state))
    } else {
        scope::create_function(state.scope, name, share, tpe, scope::Phase::DECLARED, null, null)
    }

    if not tpe.is_polymorph and vector::length(tpe.parameter_t) > 0 {
        let first_param = vector::get(tpe.parameter_t, 0) !*NamedParameter
        typechecking::create_type_entry(first_param.tpe, (share !int & parser::ShareMarker::EXPORT !int) != 0, tpe, state.module)
    }

    if body and not tpe.is_polymorph {
        let function = allocate(typechecking::Function)
        @function = {
            tpe = tpe,
            locals = map::make(),
            has_defer = false
        }
        typechecking::push_function(state, function)

        state.scope = scope::enter_function_scope(state.scope)
        node.inner_scope = state.scope
        body = vector::copy(body)
        for var i in 0..vector::length(body) {
            walk(node, vector::get(body, i) !*parser::Node, state)
        }
        state.scope = scope::exit_scope(state.scope)

        node.value.def_.locals = function.locals
        node.value.def_.has_defer = function.has_defer
        typechecking::pop_function(state)
    }

    node.tpe = tpe
}

def walk_TypeDecl(node: *parser::Node, state: *typechecking::State) {
    let share = node.value.type_decl.share
    let left = node.value.type_decl.left
    let right = node.value.type_decl.right

    for var i in 0..vector::length(left) {
        let name = vector::get(left, i) !*parser::Node

        var value: *parser::Node = null
        if i < vector::length(right) {
            value = vector::get(right, i) !*parser::Node
        }
        var tpe = typechecking::make_type(typechecking::TypeKind::STUB, name)

        if vector::length(name.value.body) > 1 {
            if value {
                errors::errorn(name, "Can't create type in sub scope")
                continue
            }
            let scpe = toolchain::get_forward_declared_scope(name)
            let last = vector::peek((@name).value.body) !*string
            let n = parser::copy_node(name)
            (@n).value.body = vector::make()
            vector::push((@n).value.body, last)
            tpe = scope::create_type(scpe, n, share, tpe)
        }

        if value {
            if value.kind == parser::NodeKind::ENUM_T {
                tpe = typechecking::copy(typechecking::type_lookup(value, state))
                tpe.name = parser::identifier_to_str(name)
                tpe.type_name = typechecking::append_module(tpe.name, value.loc.module)

                var constant: int64 = 0
                // Create all the constants
                state.scope = scope::enter_scope(state.scope)
                for var i in 0..vector::length(value.value.t_enum.body) {
                    let iddecl = vector::get(value.value.t_enum.body, i) !*parser::Node
                    if iddecl.value.id_decl_enum.value {
                        constant = expr(iddecl.value.id_decl_enum.value, state).i
                    }

                    let c = allocate(compiler::Value)
                    @c = { kind = compiler::ValueKind::INT, tpe = tpe.tpe, i = constant } !compiler::Value
                    scope::create_variable(state.scope, iddecl.value.id_decl_enum.ident, 
                        share, parser::VarDecl::CONST, tpe, c)

                    constant += 1
                }

                (@tpe).scope = state.scope
                state.scope = scope::exit_scope(state.scope)

                // Create to_string function
                let parameter_t = vector::make()
                let return_t = vector::make()
                let np = allocate(NamedParameter)
                @np = {
                    name = "enum",
                    tpe = tpe
                } !NamedParameter
                vector::push(parameter_t, np)
                vector::push(return_t, builtins::string_)

                let ident = parser::make_identifier(["to_string"])
                let ftpe = typechecking::make_function_type_n(ident, parameter_t, return_t, false, false)
                scope::create_function(state.scope, ident, parser::ShareMarker::EXPORT, ftpe)

                scope::create_type(state.scope, name, share, tpe)
            } else {
                let typedef = parser::copy_node(node)
                typedef.value.type_decl.left = vector::make()
                vector::push(typedef.value.type_decl.left, name)
                typedef.value.type_decl.right = vector::make()
                vector::push(typedef.value.type_decl.right, value)

                tpe = scope::create_type(state.scope, name, share, tpe, scope::Phase::DEFINED, typedef, copy_state(state))
            }
        } else {
            tpe = scope::create_type(state.scope, name, share, tpe, scope::Phase::DECLARED, null, null)
        }

        name.tpe = tpe
    }
}

def walk_top_VarDecl(node: *parser::Node, state: *typechecking::State) {
    let share = node.value.var_decl.share
    let kw = node.value.var_decl.kw
    let left = node.value.var_decl.left
    let right = node.value.var_decl.right
    let extern = node.value.var_decl.extern
    let dllimport = node.value.var_decl.dllimport

    if kw == parser::VarDecl::CONST {
        for var i in 0..vector::length(right) {
            let is_static = state.is_static
            state.is_static = true
            walk(node, vector::get(right, i) !*parser::Node, state)
            state.is_static = is_static
        }

        set_current_function()
        typechecking::walk_VarDecl(node, state, true)
        let assign = compiler::walk_top_VarDecl(node, *compiler_state, true)
        compiler::walk_expression(assign, *compiler_state)
        eval::eval(*compiler_state)

        for var i in 0..vector::length(left) {
            let n = vector::get(left, i) !*parser::Node
            if n.kind != parser::NodeKind::ID_DECL {
                errors::errorn(n, "Can't assign in const statement")
                return
            }
            let ident = n.value.id_decl.value
            let global = eval::serialize_value(ident.svalue.assembly_name, state.module, *compiler_state)
            if global {
                ident.svalue.value = global.value
            }
        }

        return
    }

    for var i in 0..vector::length(left) {
        let n = vector::get(left, i) !*parser::Node
        if n.kind == parser::NodeKind::ID_DECL {
            if scope::last_path_element(n.value.id_decl.value) == "_" {
                errors::errorn(n.value.id_decl.value, "Can't use underscore at top level")
                continue
            }

            scope::create_variable(
                state.scope, n.value.id_decl.value, 
                share, kw, typechecking::make_type_raw(typechecking::TypeKind::STUB), 
                extern, dllimport, null, scope::Phase::DEFINED, node, copy_state(state)
            )
        } else {
            walk(node, n, state)
        }
    }
    for var i in 0..vector::length(right) {
        walk(node, vector::get(right, i) !*parser::Node, state)
    }
}

def walk_VarDecl(node: *parser::Node, state: *typechecking::State) {
    let kw = node.value.var_decl.kw
    let left = node.value.var_decl.left
    let right = node.value.var_decl.right

    if kw == parser::VarDecl::CONST and not state.is_compiling_function {
        for var i in 0..vector::length(right) {
            let is_static = state.is_static
            state.is_static = true
            walk(node, vector::get(right, i) !*parser::Node, state)
            state.is_static = is_static
        }

        set_current_function()
        typechecking::walk_VarDecl(node, state, true)
        compiler::walk_VarDecl(node, *compiler_state, true)
        let estate = eval::eval(*compiler_state)
        let locals = eval::get_stack_frame(*estate).locals

        for var i in 0..vector::length(left) {
            let n = vector::get(left, i) !*parser::Node
            if n.kind != parser::NodeKind::ID_DECL {
                errors::errorn(n, "Can't assign in const statement")
                return
            }
            let name = n.value.id_decl.value
            let value = scope::get(state.scope, name)
            // TODO We need to serialize these ones as well, move them out of the function
            let mem = map::get(locals, value.assembly_name) !*
            let ptr = eval::get(mem, typechecking::pointer(value.tpe))
            let constant = eval::get(ptr.i !*, value.tpe)

            let constantp = allocate(compiler::Value)
            @constantp = constant
            value.value = constantp
        }

        return
    }

    for var i in 0..vector::length(left) {
        let left = vector::get(left, i) !*parser::Node
        if left.kind != parser::NodeKind::ID_DECL {
            walk(node, left, state)
        }
    }
    for var i in 0..vector::length(right) {
        walk(node, vector::get(right, i) !*parser::Node, state)
    }
}

def walk_UnaryOp(node: *parser::Node, state: *typechecking::State) {
    walk(node, node.value.expr, state)
}

def walk_BinaryOp(node: *parser::Node, state: *typechecking::State) {
    walk(node, node.value.bin_op.left, state)
    walk(node, node.value.bin_op.right, state)
}

def walk_Assign(node: *parser::Node, state: *typechecking::State) {
    for var i in 0..vector::length(node.value.assign.left) {
        walk(node, vector::get(node.value.assign.left, i) !*parser::Node, state)
    }
    for var i in 0..vector::length(node.value.assign.right) {
        walk(node, vector::get(node.value.assign.right, i) !*parser::Node, state)
    }
}

def walk_Return(node: *parser::Node, state: *typechecking::State) {
    for var i in 0..vector::length(node.value.body) {
        walk(node, vector::get(node.value.body, i) !*parser::Node, state)
    }
}

def compile_function(node: *parser::Node, state: *typechecking::State) {
    if not node { return }

    let function = compiler::predeclare_function(node.tpe, node.module)
    map::put(state.module.result.functions, function.name, function)
    map::put(compiler_state.module.result.functions, function.name, function)
    
    if not function.is_compiled {
        function.is_compiled = true

        let is_compiling_function = state.is_compiling_function
        let module = state.module
        let cmodule = compiler_state.module
        state.is_compiling_function = true
        state.module = compiler_state.module = node.module

        // This is a big ugly but what can we do
        let debug = toolchain::debug_sym
        toolchain::debug_sym = false

        for var i in 0..vector::length(node.value.def_.body) {
            walk(node, vector::get(node.value.def_.body, i) !*parser::Node, state)
        }
        compiler::create_function(node, node.tpe, node.value.def_.body, node.inner_scope, null, *compiler_state)

        toolchain::debug_sym = debug
        state.is_compiling_function = is_compiling_function
        compiler_state.module = cmodule
        state.module = module
    }
}

def walk_Call(node: *parser::Node, state: *typechecking::State) {
    let left = node.value.func_call.left
    walk(node, left, state)

    if state.is_static {
        typechecking::walk(node.parent, node, state)

        if not left.svalue { return }
        let func = left.svalue.node

        compile_function(func, state)
    }
    
    for var i in 0..vector::length(node.value.func_call.args) {
        walk(node, vector::get(node.value.func_call.args, i) !*parser::Node, state)
    }
    for var i in 0..vector::length(node.value.func_call.kwargs) {
        let named_arg = vector::get(node.value.func_call.kwargs, i) !*parser::Node
        walk(node, named_arg.value.named_arg.value, state)
    }
}

def walk_Ptr(node: *parser::Node, state: *typechecking::State) {
    walk(node, node.value.expr, state)
    if state.is_static {
        let suppress_errors = errors::suppress_errors
        errors::suppress_errors = true
        typechecking::walk(node.parent, node, state)
        errors::suppress_errors = suppress_errors

        if not node.value.expr.svalue { return }
        let func = node.value.expr.svalue.node
        compile_function(func, state)
    }
}

def walk_Switch(node: *parser::Node, state: *typechecking::State) {
    walk(node, node.value.switch_.expr, state)
    for var i in 0..vector::length(node.value.switch_.body) {
        walk(node, vector::get(node.value.switch_.body, i) !*parser::Node, state)
    }
}

def walk_Case(node: *parser::Node, state: *typechecking::State) {
    for var i in 0..vector::length(node.value.case_.expr) {
        walk(node, vector::get(node.value.case_.expr, i) !*parser::Node, state)
    }

    state.scope = scope::enter_scope(state.scope)
    node.inner_scope = state.scope
    let body = vector::copy(node.value.case_.body)
    for var i in 0..vector::length(body) {
        walk(node, vector::get(body, i) !*parser::Node, state)
    }
    state.scope = scope::exit_scope(state.scope)
}

def walk_Defer(node: *parser::Node, state: *typechecking::State) {
    state.scope = scope::enter_scope(state.scope)
    node.inner_scope = state.scope
    let body = vector::copy(node.value.body)
    for var i in 0..vector::length(body) {
        walk(node, vector::get(body, i) !*parser::Node, state)
    }
    state.scope = scope::exit_scope(state.scope)   
}

def walk_If(node: *parser::Node, state: *typechecking::State) {
    walk(node, node.value.if_.cond, state)
    
    state.scope = scope::enter_scope(state.scope)
    node.inner_scope = state.scope
    let body = vector::copy(node.value.if_.body)
    for var i in 0..vector::length(body) {
        walk(node, vector::get(body, i) !*parser::Node, state)
    }
    state.scope = scope::exit_scope(state.scope)

    for var i in 0..vector::length(node.value.if_.else_if) {
        let else_if = vector::get(node.value.if_.else_if, i) !*parser::Node
        walk(node, else_if.value.else_if.cond, state)
        
        state.scope = scope::enter_scope(state.scope)
        else_if.inner_scope = state.scope
        let body = vector::copy(else_if.value.else_if.body)
        for var i in 0..vector::length(body) {
            walk(node, vector::get(body, i) !*parser::Node, state)
        }
        state.scope = scope::exit_scope(state.scope)
    }
    if node.value.if_.else_ {
        let else_ = node.value.if_.else_
        state.scope = scope::enter_scope(state.scope)
        else_.inner_scope = state.scope
        let body = vector::copy(else_.value.body)
        for var i in 0..vector::length(body) {
            walk(node, vector::get(body, i) !*parser::Node, state)
        }
        state.scope = scope::exit_scope(state.scope)
    }
}

def walk_For(node: *parser::Node, state: *typechecking::State) {
    walk(node, node.value.for_loop.expr, state)
    state.scope = scope::enter_scope(state.scope)
    node.inner_scope = state.scope
    let body = vector::copy(node.value.for_loop.body)
    for var i in 0..vector::length(body) {
        walk(node, vector::get(body, i) !*parser::Node, state)
    }
    state.scope = scope::exit_scope(state.scope)
}

def walk_While(node: *parser::Node, state: *typechecking::State) {
    walk(node, node.value.while_loop.expr, state)
    state.scope = scope::enter_scope(state.scope)
    node.inner_scope = state.scope
    let body = vector::copy(node.value.while_loop.body)
    for var i in 0..vector::length(body) {
        walk(node, vector::get(body, i) !*parser::Node, state)
    }
    state.scope = scope::exit_scope(state.scope)
}

def walk_Loop(node: *parser::Node, state: *typechecking::State) {
    state.scope = scope::enter_scope(state.scope)
    node.inner_scope = state.scope
    let body = vector::copy(node.value.body)
    for var i in 0..vector::length(body) {
        walk(node, vector::get(body, i) !*parser::Node, state)
    }
    state.scope = scope::exit_scope(state.scope)
}

def walk_StructLit(node: *parser::Node, state: *typechecking::State) {
    for var i in 0..vector::length(node.value.struct_lit.args) {
        walk(node, vector::get(node.value.struct_lit.args, i) !*parser::Node, state)
    }
    for var i in 0..vector::length(node.value.struct_lit.kwargs) {
        let named_arg = vector::get(node.value.struct_lit.kwargs, i) !*parser::Node
        walk(node, named_arg.value.named_arg.value, state)
    }
}

def walk_Defined(node: *parser::Node, state: *typechecking::State) {
    let expr = node.value.expr

    let boolean_node = {
        kind = parser::NodeKind::BOOLEAN,
        parent = node.parent,
        loc = node.loc
    } !parser::Node

    if expr {
        let ident = scope::get(state.scope, expr)
        boolean_node.value.i = (not not ident) !int64
    }

    @node = boolean_node
}

def walk_Error(node: *parser::Node, state: *typechecking::State) {
    let expr = node.value.expr
    let is_static = state.is_static
    state.is_static = true
    walk(node, expr, state)
    state.is_static = is_static

    set_current_function()
    typechecking::walk(node, expr, state)
    var result = compiler::walk_expression(expr, *compiler_state)
    let estate = eval::eval(*compiler_state)
    result = eval::get_value(result, *estate)
    if not typechecking::equals(result.tpe, builtins::string_) {
        errors::errorn(node, "Error pragma expects string, got ", debug::type_to_str(result.tpe))
    } else {
        var ptr: *char = null
        if result.kind == compiler::ValueKind::ADDRESS {
            let mem = eval::get_address(@result.addr, *estate)
            let val = eval::get(eval::get(mem, typechecking::pointer(result.tpe)).i !*, result.tpe)
            ptr = val.values[1].i !*char
        } else {
            ptr = result.values[1].i !*char
        } 
        errors::errorn(node, make_string(ptr))
    }

    @node = {
        kind = parser::NodeKind::NULL,
        parent = node.parent,
        loc = node.loc
    } !parser::Node
}

def walk_top(parent: *parser::Node, node: *parser::Node, state: *typechecking::State) {
    switch node.kind !int {
        case parser::NodeKind::IMPORT:
            walk_Import(node, state)
        case parser::NodeKind::DEF:
            walk_Def(node, state)
        case parser::NodeKind::TYPE_DECL:
            walk_TypeDecl(node, state)
        case parser::NodeKind::VAR_DECL:
            walk_top_VarDecl(node, state)
        case: do_walk(node, state)
    }
}

def walk(parent: *parser::Node, node: *parser::Node, state: *typechecking::State) {
    if not node { return }

    node.parent = parent
    if not node.module {
        node.module = state.module
    }
    if not node.scope {
        node.scope = state.scope
    }

    if parent.kind == parser::NodeKind::PROGRAM {
        walk_top(parent, node, state)
        return
    }
    do_walk(node, state)
}

def do_walk(node: *parser::Node, state: *typechecking::State) {
    switch node.kind !int {
        case parser::NodeKind::VAR_DECL:
            walk_VarDecl(node, state)
        case parser::NodeKind::ASSIGN:
            walk_Assign(node, state)
        case parser::NodeKind::RETURN:
            walk_Return(node, state)
        case parser::NodeKind::FUNC_CALL:
            walk_Call(node, state)
        case parser::NodeKind::SWITCH:
            walk_Switch(node, state)
        case parser::NodeKind::CASE:
            walk_Case(node, state)
        case parser::NodeKind::IF:
            walk_If(node, state)
        case parser::NodeKind::STATIC_IF:
            walk_StaticIf(node, state)
        case parser::NodeKind::IF_EXPR:
            walk_IfExpr(node, state)
        case parser::NodeKind::FOR:
            walk_For(node, state)
        case parser::NodeKind::WHILE:
            walk_While(node, state)
        case parser::NodeKind::LOOP:
            walk_Loop(node, state)
        case parser::NodeKind::STRUCT_LIT:
            walk_StructLit(node, state)
        case parser::NodeKind::RANGE, parser::NodeKind::RANGE_INC, parser::NodeKind::MEMBER_ACCESS, parser::NodeKind::CAST, parser::NodeKind::ADD..=parser::NodeKind::OR, parser::NodeKind::BAND..=parser::NodeKind::SHR_EQ:
            walk_BinaryOp(node, state)
        case parser::NodeKind::PTR:
            walk_Ptr(node, state)
        case parser::NodeKind::SIZE_OF, parser::NodeKind::ALIGN_OF, parser::NodeKind::DEREF..=parser::NodeKind::NOT:
            walk_UnaryOp(node, state)
        case parser::NodeKind::IDENTIFIER:
            // walk_Identifier(node, state)
        case parser::NodeKind::DEFINED:
            walk_Defined(node, state)
        case parser::NodeKind::ERROR:
            walk_Error(node, state)
        case parser::NodeKind::DEFER:
            walk_Defer(node, state)
    }
}

export def consteval(module: *toolchain::Module) {
    let state = typechecking::make_state(module)
    consteval(*state)
}

export var time_spent: int64 = 0

export def consteval(state: *typechecking::State) {
    let start = util::millis()
    debug::trace("Preprocessing ", state.module.module)

    let node = state.module.node
    assert(node.kind == parser::NodeKind::PROGRAM)

    if not toolchain::is_preload(state.module) {
        // import standard library
        let cstd_ident = parser::make_identifier(["cstd"])
        let cstd = toolchain::consteval_module(cstd_ident)
        scope::insert_module(state.module.scope, cstd_ident, cstd)
        
        let std_ident = parser::make_identifier(["std"])
        let std = toolchain::consteval_module(std_ident)
        scope::insert_module(state.module.scope, std_ident, std)

        let preload_ident = parser::make_identifier(["preload"])
        let preload = toolchain::consteval_module(preload_ident)
        scope::insert_module(state.module.scope, preload_ident, preload)
    }

    compiler::predeclare_functions(state.module)

    let body = vector::copy(node.value.body)
    for var i in 0..vector::length(body) {
        let n = vector::get(body, i) !*parser::Node
        walk(node, n, state)
    }
    let end = util::millis()
    time_spent += end - start
}