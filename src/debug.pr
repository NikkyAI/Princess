import parser
import vector
import util
import typechecking
import json

#if not defined WIN32 {
    import linux
}

def bin_op_to_json(str: &string, node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = str
    res["left"] = node_to_json(node.value.bin_op.left)
    res["right"] = node_to_json(node.value.bin_op.right)
    return res
}

def un_op_to_json(str: &string, node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = str
    res["expr"] = node_to_json(node.value.expr)
    return res
}

def node_vec_to_json(vec: &Vector(&parser::Node)) -> &Json {
    if not vec {
        return json::make_null()
    } else {
        let res = json::make_array()
        for var i in 0..vector::length(vec) {
            res.push(node_to_json(vec[i]))
        }
        return res
    }
}

def func_call_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "FuncCall"
    res["left"] = node_to_json(node.value.func_call.left)
    res["args"] = node_vec_to_json(node.value.func_call.args)
    res["kwargs"] = node_vec_to_json(node.value.func_call.kwargs)
    return res
}

def var_decl_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "VarDecl"
    res["share"] = to_string(node.value.var_decl.share)
    res["kw"] = to_string(node.value.var_decl.kw)
    res["left"] = node_vec_to_json(node.value.var_decl.left)
    res["right"] = node_vec_to_json(node.value.var_decl.right)
    return res
}

def id_decl_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "IdDecl"
    res["value"] = node_to_json(node.value.id_decl.value)
    res["tpe"] = node_to_json(node.value.id_decl.tpe)
    return res
}

def id_decl_struct_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "IdDeclStruct"
    res["ident"] = node_to_json(node.value.id_decl_struct.ident)
    res["tpe"] = node_to_json(node.value.id_decl_struct.tpe)
    return res    
}

def id_decl_enum_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "IdDeclEnum"
    res["ident"] = node_to_json(node.value.id_decl_enum.ident)
    res["value"] = node_to_json(node.value.id_decl_enum.value)
    return res    
}

def enum_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "Enum"
    res["tpe"] = node_to_json(node.value.t_enum.tpe)
    res["body"] = node_vec_to_json(node.value.t_enum.body)
    return res
}

def id_assign_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "IdAssign"
    res["value"] = node_to_json(node.value.expr)
    return res
}

def named_arg_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "NamedArg"
    res["name"] = node_to_json(node.value.named_arg.name)
    res["value"] = node_to_json(node.value.named_arg.value)
    return res
}

def identifier_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    let path = json::make_array()
    for var i in 0..node.value.identifier.path.length {
        path.push(node.value.identifier.path[i])
    }
    res["path"] = path
    res["prefixed"] = node.value.identifier.prefixed
    res["args"] = node_vec_to_json(node.value.identifier.args)
    return res
}

def function_t_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "FunctionT"
    res["args"] = node_vec_to_json(node.value.t_func.args)
    res["ret"] = node_vec_to_json(node.value.t_func.ret)
    return res
}

def ptrarray_to_json(str: &string, node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = str
    res["kw"] = to_string(node.value.t_parr.kw)
    res["tpe"] = node_to_json(node.value.t_parr.tpe)
    return res
}

def array_static_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "ArrayStaticT"
    res["n"] = node_to_json(node.value.t_arrs.n)
    print("kw = ")
    print((@node).value.t_arrs.kw)
    res["tpe"] = node_to_json(node.value.t_arrs.tpe)
    return res
}

def assign_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "Assign"
    res["left"] = node_vec_to_json(node.value.assign.left)
    res["right"] = node_vec_to_json(node.value.assign.right)
    return res
}

def unsigned_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "Unsigned"
    res["expr"] = node_to_json(node.value.expr)
    return res
}

def switch_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "Switch"
    res["expr"] = node_to_json(node.value.switch_.expr)
    res["body"] = node_vec_to_json(node.value.switch_.body)
    return res
}

def case_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "Case"
    res["expr"] = node_vec_to_json(node.value.case_.expr)
    res["body"] = node_vec_to_json(node.value.case_.body)
    return res
}

def if_expr_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "IfExpr"
    res["cond"] = node_to_json(node.value.if_expr.cond)
    res["if_true"] = node_to_json(node.value.if_expr.if_true)
    res["if_false"] = node_to_json(node.value.if_expr.if_false)
    return res
}

def if_to_json(node: &parser::Node, static_if: bool) -> &Json {
    let res = json::make_object()
    if static_if {
        res["kind"] = "StaticIf"
    } else {
        res["kind"] = "If"
    }
    res["cond"] = node_to_json(node.value.if_.cond)
    res["body"] = node_vec_to_json(node.value.if_.body)
    res["else_if"] = node_vec_to_json(node.value.if_.else_if)
    res["else_"] = node_to_json(node.value.if_.else_)
    return res
}

def else_if_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "ElseIf"
    res["cond"] = node_to_json(node.value.if_.cond)
    res["body"] = node_vec_to_json(node.value.if_.body)
    return res
}

def else_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "Else"
    res["body"] = node_vec_to_json(node.value.body)
    return res
}

def type_decl_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "TypeDecl"
    print("share = ")
    print((@node).value.type_decl.share)
    res["left"] = node_vec_to_json(node.value.type_decl.left)
    res["right"] = node_vec_to_json(node.value.type_decl.right)
    return res
}

def loop_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "Loop"
    res["body"] = node_vec_to_json(node.value.body)
    return res
}

def for_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "For"
    res["iddecl"] = node_to_json(node.value.for_loop.iddecl)
    res["expr"] = node_to_json(node.value.for_loop.expr)
    res["body"] = node_vec_to_json(node.value.for_loop.body)
    return res
}

def for_id_decl_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "ForIdDecl"
    res["kw"] = to_string(node.value.for_id_decl.kw)
    res["ident"] = node_to_json(node.value.for_id_decl.ident)
    return res
}

def while_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "While"
    res["expr"] = node_to_json(node.value.while_loop.expr)
    res["body"] = node_vec_to_json(node.value.while_loop.body)
    return res
}

def import_module_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "ImportModule"
    res["name"] = node_to_json(node.value.import_module.name)
    res["alias"] = node_to_json(node.value.import_module.alias)
    return res
}

def def_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "Def"
    res["share"] = to_string(node.value.def_.share)
    res["name"] = node_to_json(node.value.def_.name)
    res["params"] = node_vec_to_json(node.value.def_.params)
    res["returns"] = node_vec_to_json(node.value.def_.returns)
    res["body"] = node_vec_to_json(node.value.def_.body)
    return res 
}

def parameter_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "Parameter"
    res["kw"] = to_string(node.value.param.kw)
    res["name"] = node_to_json(node.value.param.name)
    res["tpe"] = node_to_json(node.value.param.tpe)
    res["value"] = node_to_json(node.value.param.value)
    return res 
}

def struct_lit_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "StructLit"
    res["args"] = node_vec_to_json(node.value.struct_lit.args)
    res["kwargs"] = node_vec_to_json(node.value.struct_lit.kwargs)
    return res
}

def assert_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "Assert"
    res["cond"] = node_to_json(node.value.assert_.cond)
    res["message"] = node_to_json(node.value.assert_.message)
    return res
}

def structural_member_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "StructuralMember"
    res["name"] = node_to_json(node.value.structural_member.name)
    res["params"] = node_vec_to_json(node.value.structural_member.params)
    res["returns"] = node_vec_to_json(node.value.structural_member.returns)
    return res
}

def type_constructor_to_json(node: &parser::Node) -> &Json {
    let res = json::make_object()
    res["kind"] = "TypeConstructor"
    res["name"] = node_to_json(node.value.type_constructor.name)
    res["args"] = node_vec_to_json(node.value.type_constructor.args)
    return res
}

export def node_to_json(node: &parser::Node) -> &Json {
    if not node { return json::make_null() }
    var res: &Json
    switch (@node).kind !int {
        case parser::NodeKind::PROGRAM:
            res = json::make_object()
            res["kind"] = "Program"
            res["body"] = node_vec_to_json(node.value.body)
        case parser::NodeKind::INTEGER:
            res = json::make_object()
            res["kind"] = "Integer"
            res["value"] = node.value.i !double
        case parser::NodeKind::CHAR:
            res = json::make_object()
            res["kind"] = "Char"
            res["value"] = node.value.i !double
        case parser::NodeKind::STRING:
            res = json::make_object()
            res["kind"] = "String"
            res["value"] = node.value.str
        case parser::NodeKind::FLOAT:
            res = json::make_object()
            res["kind"] = "Float"
            res["value"] = node.value.i !double
        case parser::NodeKind::BOOLEAN:
            res = json::make_object()
            res["kind"] = "Boolean"
            res["value"] = node.value.i !bool
        case parser::NodeKind::IDENTIFIER:
            res = identifier_to_json(node)
        case parser::NodeKind::DEFINED:
            res = un_op_to_json("Defined", node)
        case parser::NodeKind::ERROR:
            res = un_op_to_json("Error", node)
        case parser::NodeKind::NULL:
            res = json::make_object()
            res["kind"] = "Null"
        case parser::NodeKind::UNDEF:
            res = json::make_object()
            res["kind"] = "Undef"
        case parser::NodeKind::RANGE:
            res = bin_op_to_json("Range", node)
        case parser::NodeKind::RANGE_INC:
            res = bin_op_to_json("RangeInc", node)
        case parser::NodeKind::ARRAY_LIT:
            res = json::make_object()
            res["kind"] = "ArrayLit"
            res["body"] = node_vec_to_json(node.value.body)
        case parser::NodeKind::STRUCT_LIT:
            res = struct_lit_to_json(node)
        case parser::NodeKind::MEMBER_ACCESS:
            res = bin_op_to_json("MemberAccess", node)
        case parser::NodeKind::CAST:
            res = bin_op_to_json("Cast", node)
        case parser::NodeKind::SIZE_OF:
            res = un_op_to_json("SizeOf", node)
        case parser::NodeKind::ALIGN_OF:
            res = un_op_to_json("AlignOf", node)
        case parser::NodeKind::TYPE_OF_T:
            res = un_op_to_json("TypeOf", node)
        case parser::NodeKind::ADD:
            res = bin_op_to_json("Add", node)
        case parser::NodeKind::SUB:
            res = bin_op_to_json("Sub", node)
        case parser::NodeKind::MUL:
            res = bin_op_to_json("Mul", node)
        case parser::NodeKind::DIV:
            res = bin_op_to_json("Div", node)
        case parser::NodeKind::MOD:
            res = bin_op_to_json("Mod", node)
        case parser::NodeKind::AND:
            res = bin_op_to_json("And", node)
        case parser::NodeKind::OR:
            res = bin_op_to_json("Or", node)
        case parser::NodeKind::UADD:
            res = un_op_to_json("UAdd", node)
        case parser::NodeKind::USUB:
            res = un_op_to_json("USub", node)
        case parser::NodeKind::PTR:
            res = un_op_to_json("Ptr", node)
        case parser::NodeKind::DEREF:
            res = un_op_to_json("Deref", node)
        case parser::NodeKind::BNOT:
            res = un_op_to_json("BNot", node)
        case parser::NodeKind::NOT:
            res = un_op_to_json("Not", node)
        case parser::NodeKind::BAND:
            res = bin_op_to_json("BAnd", node)
        case parser::NodeKind::BOR:
            res = bin_op_to_json("BOr", node)
        case parser::NodeKind::BXOR:
            res = bin_op_to_json("BXor", node)
        case parser::NodeKind::SHL:
            res = bin_op_to_json("Shl", node)
        case parser::NodeKind::SHR:
            res = bin_op_to_json("Shr", node)
        case parser::NodeKind::PADD:
            res = bin_op_to_json("PAdd", node)
        case parser::NodeKind::PSUB:
            res = bin_op_to_json("PSub", node)
        case parser::NodeKind::EQ:
            res = bin_op_to_json("Eq", node)
        case parser::NodeKind::NEQ:
            res = bin_op_to_json("NEq", node)
        case parser::NodeKind::GT:
            res = bin_op_to_json("Gt", node)
        case parser::NodeKind::LT:
            res = bin_op_to_json("Lt", node)
        case parser::NodeKind::GEQ:
            res = bin_op_to_json("GEq", node)
        case parser::NodeKind::LEQ:
            res = bin_op_to_json("LEq", node)
        case parser::NodeKind::PADD_EQ:
            res = bin_op_to_json("PAddEq", node)
        case parser::NodeKind::PSUB_EQ:
            res = bin_op_to_json("PSubEq", node)
        case parser::NodeKind::ADD_EQ:
            res = bin_op_to_json("AddEq", node)
        case parser::NodeKind::SUB_EQ:
            res = bin_op_to_json("SubEq", node)
        case parser::NodeKind::MUL_EQ:
            res = bin_op_to_json("MulEq", node)
        case parser::NodeKind::DIV_EQ:
            res = bin_op_to_json("DivEq", node)
        case parser::NodeKind::MOD_EQ:
            res = bin_op_to_json("ModEq", node)
        case parser::NodeKind::AND_EQ:
            res = bin_op_to_json("AndEq", node)
        case parser::NodeKind::OR_EQ:
            res = bin_op_to_json("OrEq", node)
        case parser::NodeKind::XOR_EQ:
            res = bin_op_to_json("XorEq", node)
        case parser::NodeKind::SHL_EQ:
            res = bin_op_to_json("ShlEq", node)
        case parser::NodeKind::SHR_EQ:
            res = bin_op_to_json("ShrEq", node)
        case parser::NodeKind::IMPORT:
            res = json::make_object()
            res["kind"] = "Import"
            res["body"] = node_vec_to_json(node.value.body)
        case parser::NodeKind::IMPORT_MODULE:
            res = import_module_to_json(node) 
        case parser::NodeKind::ASSIGN:
            res = assign_to_json(node)
        case parser::NodeKind::DEF:
            res = def_to_json(node)
        case parser::NodeKind::PARAMETER:
            res = parameter_to_json(node)
        case parser::NodeKind::SWITCH:
            res = switch_to_json(node)
        case parser::NodeKind::CASE:
            res = case_to_json(node)
        case parser::NodeKind::IF_EXPR:
            res = if_expr_to_json(node)
        case parser::NodeKind::IF:
            res = if_to_json(node, false)
        case parser::NodeKind::STATIC_IF:
            res = if_to_json(node, true)
        case parser::NodeKind::ELSE_IF:
            res = else_if_to_json(node)
        case parser::NodeKind::ELSE:
            res = else_to_json(node)
        case parser::NodeKind::LOOP:
            res = loop_to_json(node)
        case parser::NodeKind::WHILE:
            res = while_to_json(node)
        case parser::NodeKind::FOR:
            res = for_to_json(node)
        case parser::NodeKind::FOR_ID_DECL:
            res = for_id_decl_to_json(node)
        case parser::NodeKind::BREAK:
            res = json::make_object()
            res["kind"] = "Break"
        case parser::NodeKind::CONTINUE:
            res = json::make_object()
            res["kind"] = "Continue"
        case parser::NodeKind::RETURN:
            res = json::make_object()
            res["kind"] = "Return"
            res["body"] = node_vec_to_json(node.value.body)
        case parser::NodeKind::YIELD:
            res = json::make_object()
            res["kind"] = "Yield"
            res["body"] = node_vec_to_json(node.value.body)
        case parser::NodeKind::DEFER:
            res = json::make_object()
            res["kind"] = "Defer"
            res["body"] = node_vec_to_json(node.value.body)
        case parser::NodeKind::ASSERT:
            res = assert_to_json(node)
        case parser::NodeKind::ARRAY_SUBSCRIPT:
            res = bin_op_to_json("ArraySubscript", node)
        case parser::NodeKind::FUNC_CALL:
            res = func_call_to_json(node)
        case parser::NodeKind::TYPE_DECL:
            res = type_decl_to_json(node)
        case parser::NodeKind::VAR_DECL:
            res = var_decl_to_json(node)
        case parser::NodeKind::ID_DECL:
            res = id_decl_to_json(node)
        case parser::NodeKind::ID_ASSIGN:
            res = id_assign_to_json(node)
        case parser::NodeKind::NAMED_ARG:
            res = named_arg_to_json(node)
        case parser::NodeKind::ID_DECL_STRUCT:
            res = id_decl_struct_to_json(node)
        case parser::NodeKind::ID_DECL_ENUM:
            res = id_decl_enum_to_json(node)
        case parser::NodeKind::ENUM_T:
            res = enum_to_json(node)
        case parser::NodeKind::STRUCT_T:
            res = json::make_object()
            res["kind"] = "Struct"
            res["body"] = node_vec_to_json(node.value.body)
        case parser::NodeKind::UNION_T:
            res = json::make_object()
            res["kind"] = "Union"
            res["body"] = node_vec_to_json(node.value.body)
        case parser::NodeKind::FUNCTION_T, parser::NodeKind::CLOSURE_T:
            res = function_t_to_json(node)
        case parser::NodeKind::UNSIGNED_T:
            res = unsigned_to_json(node)
        case parser::NodeKind::PTR_T:
            res = ptrarray_to_json("PtrT", node)
        case parser::NodeKind::REF_T:
            res = ptrarray_to_json("RefT", node)
        case parser::NodeKind::ARRAY_T:
            res = ptrarray_to_json("ArrayT", node)
        case parser::NodeKind::WEAK_REF_T:
            res = ptrarray_to_json("WeakRefT", node)
        case parser::NodeKind::WORD_T:
            res = json::make_object()
            res["kind"] = "Word"
            res["size"] = node.value.i !double
        case parser::NodeKind::ARRAY_STATIC_T:
            res = array_static_to_json(node)
        case parser::NodeKind::TYPE_T:
            res = un_op_to_json("TypeT", node)
        case parser::NodeKind::STRUCTURAL_T:
            res = json::make_object()
            res["kind"] = "StructuralT"
            res["body"] = node_vec_to_json(node.value.body)
        case parser::NodeKind::STRUCTURAL_T_MEMBER:
            res = structural_member_to_json(node)
        case parser::NodeKind::TYPE_CONSTRUCTOR:
            res = type_constructor_to_json(node)
        case:
            error(node.kind, "\n")
            assert

    }
    return res
}

def function_t_to_string(tpe: &typechecking::Type, full_name: bool) -> &string {
    var ret: &string = "def (" if tpe.kind == typechecking::TypeKind::FUNCTION else "("
    var len = vector::length(tpe.parameter_t)
    for var i in 0..len {
        let param = tpe.parameter_t[i]
        if param.varargs {
            ret += "..."
        } else {
            ret += type_to_str(param.tpe, full_name)
        }
        if i < len - 1 {
            ret += ", "
        }
    }

    ret += ") -> ("
    len = vector::length(tpe.return_t)
    for var i in 0..len {
        ret += type_to_str(tpe.return_t[i])
        if i < len - 1 {
            ret += ", "
        }
    }
    ret += ')'

    return ret
}

def pointer_t_to_string(tpe: &typechecking::Type, full_name: bool) -> &string {
    var ret: &string = "*"
    if tpe.kw == parser::VarDecl::LET {
        ret += "let "
    }
    if tpe.tpe { 
        ret += type_to_str(tpe.tpe, full_name)
    }
    return ret
}

def reference_t_to_string(tpe: &typechecking::Type, full_name: bool) -> &string {
    var ret: &string = "&"
    if tpe.kw == parser::VarDecl::LET {
        ret += "let "
    }
    if tpe.tpe { 
        ret += type_to_str(tpe.tpe, full_name)
    }
    return ret
}

def weak_ref_t_to_string(tpe: &typechecking::Type, full_name: bool) -> &string {
    var ret: &string = "weak_ref("
    
    if tpe.kw == parser::VarDecl::LET {
        ret += "let "
    }
    if tpe.tpe {
        ret += type_to_str(tpe.tpe, full_name)
    }

    ret += ')'
    return ret
}

def array_t_to_string(tpe: &typechecking::Type, full_name: bool) -> &string {
    var ret: &string = "["
    if tpe.kw == parser::VarDecl::LET {
        ret += "let "
    }
    if tpe.tpe {
        ret += type_to_str(tpe.tpe, full_name)
    }
    ret += ']'
    return ret
}

def static_array_t_to_string(tpe: &typechecking::Type, full_name: bool) -> &string {
    var ret: &string = "["
    if tpe.length !uint64 == std::MAX_UINT64 {
        ret += '?'
    } else {
        ret += tpe.length
    }
    ret += "; "
    if tpe.kw == parser::VarDecl::LET {
        ret += "let "
    }
    ret += type_to_str(tpe.tpe, full_name)
    ret += ']'
    return ret
}

def tuple_t_to_string(tpe: &typechecking::Type, full_name: bool) -> &string {
    var ret: &string = "("
    let len = vector::length(tpe.return_t)
    for var i in 0..len {
        let rtpe = tpe.return_t[i]
        ret += type_to_str(rtpe, full_name)
        if i < len - 1 {
            ret += ", "
        }
    }
    ret += ')'
    return ret
}

def word_t_to_string(tpe: &typechecking::Type) -> &string {
    if tpe.unsig {
        return "uint"+ tpe.size * 8
    }
    return "int" + tpe.size * 8
}

def float_t_to_string(tpe: &typechecking::Type) -> &string {
    return "float" + tpe.size * 8
}

def type_def_t_to_string(tpe: &typechecking::Type, full_name: bool) -> &string {
    return "Type<" + type_to_str(tpe.tpe, full_name) + '>'
}

def variant_t_to_string(tpe: &typechecking::Type, full_name: bool) -> &string {
    if not tpe.variants {
        return "any"
    }

    var ret: &string = "("
    let len = vector::length(tpe.variants)
    for var i in 0..len {
        let vtpe = tpe.variants[i]
        ret += type_to_str(vtpe, full_name)
        if i < len - 1 {
            ret += " | "
        }
    }
    ret += ')'
    return ret
}

def tc_args_to_string(args: &Vector(&typechecking::Type), full_name: bool) -> &string {
    var ret: &string = "("
    let len = vector::length(args)
    for var i in 0..len {
        let arg = args[i]
        if arg and arg.kind == typechecking::TypeKind::TYPE_DEF {
            ret += "type"
        } else {
            ret += type_to_str(arg, full_name)
        }
        if i < len - 1 {
            ret += ", "
        }
    }
    ret += ')'
    return ret
}

def generic_t_to_string(tpe: &typechecking::Type, full_name: bool) -> &string {
    var ret: &string
    if full_name {
        ret = tpe.tpe.type_name
    } else {
        ret = tpe.tpe.name
    }
    ret += tc_args_to_string(tpe.tc_args, full_name)
    return ret
}

def tc_args_to_string(tpe: &typechecking::Type, full_name: bool) -> &string {
    var ret: &string
    if full_name {
        ret = tpe.tc_tpe.type_name
    } else {
        ret = tpe.tc_tpe.name
    }
    ret += tc_args_to_string(tpe.tc_args, full_name)
    return ret
}

export def type_to_str(tpe: &typechecking::Type, full_name: bool = false) -> &string {
    if not tpe { return "(none)" }
    if tpe.tc_tpe { return tc_args_to_string(tpe, full_name) }
    switch tpe.kind !int {
        case typechecking::TypeKind::BOX:
            return "Box<" + type_to_str(tpe.weak, full_name) + ">"
        case typechecking::TypeKind::VOID:
            return "void"
        case typechecking::TypeKind::BOOL:
            return "bool"
        case typechecking::TypeKind::CHAR:
            return "char"
        case typechecking::TypeKind::WORD:
            if full_name { return word_t_to_string(tpe) }
            return tpe.name
        case typechecking::TypeKind::FLOAT:
            if full_name { return float_t_to_string(tpe) }
            return tpe.name
        case typechecking::TypeKind::ENUM,
            typechecking::TypeKind::STRUCT, typechecking::TypeKind::UNION,
            typechecking::TypeKind::STRUCTURAL,
            typechecking::TypeKind::TYPE_CONSTRUCTOR:
            return tpe.type_name if full_name else tpe.name
        case typechecking::TypeKind::TYPE:
            return "type"
        case typechecking::TypeKind::TYPE_DEF:
            return type_def_t_to_string(tpe, full_name)
        case typechecking::TypeKind::FUNCTION, typechecking::TypeKind::CLOSURE:
            return function_t_to_string(tpe, full_name)
        case typechecking::TypeKind::TUPLE:
            return tuple_t_to_string(tpe, full_name)
        case typechecking::TypeKind::POINTER:
            return pointer_t_to_string(tpe, full_name)
        case typechecking::TypeKind::REFERENCE:
            return reference_t_to_string(tpe, full_name)
        case typechecking::TypeKind::WEAK_REF:
            return weak_ref_t_to_string(tpe, full_name)
        case typechecking::TypeKind::ARRAY:
            return array_t_to_string(tpe, full_name)
        case typechecking::TypeKind::STATIC_ARRAY:
            return static_array_t_to_string(tpe, full_name)
        case typechecking::TypeKind::NAMESPACE:
            return tpe.type_name if full_name else tpe.name
        case typechecking::TypeKind::RANGE:
            return "Range"
        case typechecking::TypeKind::RANGE_INC:
            return "RangeInc"
        case typechecking::TypeKind::STUB:
            return tpe.type_name if full_name else tpe.name
        case typechecking::TypeKind::NULL:
            return "null"
        case typechecking::TypeKind::UNDEF:
            return "undef"
        case typechecking::TypeKind::GENERIC:
            return generic_t_to_string(tpe, full_name)
        case typechecking::TypeKind::VARIANT:
            return variant_t_to_string(tpe, full_name)
        case:
            error(tpe.kind, "\n")
            assert
    }
}

export var verbose = false
let start_time = util::millis()

export def trace(msg: &string...) {
    if verbose {
        let now = util::millis()
        let time_offset = (now - start_time) !double / 1000
        cstd::printf("[%4.1lfs] ".value, time_offset)

        for var i in 0..msg.size {
            print(msg[i])
        }
        print("\n")
    }
}