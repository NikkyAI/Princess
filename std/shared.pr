import cstd
import std
import runtime

#if defined WIN32 {
    import windows
    // TODO
} else {
    import linux

    const RTLD_NOW = 2
    const ET_DYN = 3

    export type Library = struct {
        path: &string
        handle: *
        symbols: &[Symbol]
    }

    export type SymbolKind = enum {
        OBJECT
        FUNCTION
    }

    export type Symbol = struct {
        kind: SymbolKind
        name: &string
        value: *
    }

    export def destruct(this: *Library) {
        close_library(this)
    }

    export def load_library(path: &string) -> Library {
        let fh = open(path, "rb")
        defer close(fh)

        seek(fh, 0, SEEK_END)
        let size: size_t = tell(fh)
        rewind(fh)

        let bytes = linux::mmap(null, size, 1 /*PROT_READ*/, 2 /*MAP_PRIVATE*/, linux::fileno(fh), 0)
        defer linux::munmap(bytes, size)
        
        // Read elf header
        var elf_hdr: linux::Elf64_Ehdr
        memmove(*elf_hdr, bytes, size_of linux::Elf64_Ehdr)

        print(elf_hdr, "\n")
        
        // TODO Actually use the elf magic values here
        assert (elf_hdr.e_ident[1] == 'E' and
            elf_hdr.e_ident[2] == 'L' and 
            elf_hdr.e_ident[3] == 'F'), "Not an ELF file"
        assert elf_hdr.e_type == ET_DYN, "Not a shared object"

        let handle = linux::dlopen(path.value, RTLD_NOW)
        if not handle { abort("Couldn't open shared library " + path + "\n") }
        return {
            path,
            handle
        } !Library
    }

    export def close_library(library: *Library) {
        linux::dlclose(library.handle)
    }

    export def find_symbol(library: Library, name: &string) -> Symbol {

    }
}