import cstd
import runtime

#if defined WIN32 {
    import windows
} else {
    import linux
}

export type File = *cstd::s__IO_FILE

export def make_string(ptr: *char) -> string {
    var s: string
    s.value = ptr
    s.size = strlen(ptr) + 1
    return s
}

export def print(args: &...) -> int {
    return fprint(cstd::stdout, args)
}

export def error(args: &...) -> int {
    return fprint(cstd::stderr, args)
}

def print_val(file: File, tpe: *runtime::Type, value: *) -> int {
    if not tpe {
        return cstd::fprintf(file, "%p".value, @(value !**))
    } else if tpe == string {
        return cstd::fprintf(file, "%s".value, (@(value !*string)).value)
    } else if tpe.kind == runtime::TypeKind::STATIC_ARRAY and tpe.tpe == char {
        return cstd::fprintf(file, "%s".value, value !*char)
    } else if tpe == type *char {
        return cstd::fprintf(file, "%s".value, @(value !**char))
    } else if tpe == size_t {
        return cstd::fprintf(file, "%zu".value, @(value !*size_t))
    } else if tpe == char {
        return cstd::fprintf(file, "%c".value, @(value !*char))
    } else if tpe == int8 {
        return cstd::fprintf(file, "%hhd".value, @(value !*int8))
    } else if tpe == uint8 {
        return cstd::fprintf(file, "%hhu".value, @(value !*uint8))
    } else if tpe == int16 {
        return cstd::fprintf(file, "%hd".value, @(value !*int16))
    } else if tpe == uint16 {
        return cstd::fprintf(file, "%hu".value, @(value !*uint16))
    } else if tpe == int32 {
        return cstd::fprintf(file, "%d".value, @(value !*int32))
    } else if tpe == uint32 {
        return cstd::fprintf(file, "%u".value, @(value !*uint32))
    } else if tpe == int64 {
        return cstd::fprintf(file, "%ld".value, @(value !*int64))
    } else if tpe == uint64 {
        return cstd::fprintf(file, "%lu".value, @(value !*uint64))
    } else if tpe == float64 {
        return cstd::fprintf(file, "%lf".value, @(value !*float64))
    } else if tpe == float32 {
        return cstd::fprintf(file, "%f".value, @(value !*float32))
    } else if tpe == bool {
        if @(value !*bool) {
            return cstd::fprintf(file, "true".value)
        } else {
            return cstd::fprintf(file, "false".value)
        } 
    } else if tpe.kind == runtime::TypeKind::POINTER {
        return cstd::fprintf(file, "%p".value, @(value !**))
    } else if tpe.kind == runtime::TypeKind::REFERENCE {
        let v = (value !&) !runtime::Ref
        return print_val(file, tpe.tpe, v.value)
    } else if tpe.kind == runtime::TypeKind::ARRAY {
        let arr = @(value !*[*])
        let size = arr.size
        let elements = arr.value
        var sum = 0

        sum += cstd::fprintf(file, "[".value)
        for var i in 0..size {
            sum += print_val(file, tpe.tpe, elements ++ i * tpe.tpe.size)
            if i < size - 1 {
                sum += cstd::fprintf(file, ", ".value)
            }
        }
        sum += cstd::fprintf(file, "]".value)
        return sum
    } else if tpe.kind == runtime::TypeKind::STATIC_ARRAY {
        let size = tpe.length
        var sum = 0

        sum += cstd::fprintf(file, "[".value)
        for var i in 0..size {
            sum += print_val(file, tpe.tpe, value ++ i * tpe.tpe.size)
            if i < size - 1 {
                sum += cstd::fprintf(file, ", ".value)
            }
        }
        sum += cstd::fprintf(file, "]".value)
        return sum
    } else if tpe.kind == runtime::TypeKind::STRUCT or tpe.kind == runtime::TypeKind::UNION {
        let fields = tpe.fields
        var sum = 0
        sum += cstd::fprintf(file, "{".value)
        for var i in 0..fields.size {
            let field = fields[i]
            sum += cstd::fprintf(file, "%s = ".value, field.name.value)
            sum += print_val(file, field.tpe, value ++ field.offset)
            if i < fields.size - 1 {
                sum += cstd::fprintf(file, ", ".value)
            }
        }
        sum += cstd::fprintf(file, "} !%s".value, tpe.name.value)
        return sum
    } else if tpe.kind == runtime::TypeKind::ENUM {
        var v: int64 = 0
        for var i in 0..tpe.tpe.size {
            v |= (@((value ++ i) !*byte)) !int64 << (i * 8)
        }

        var str = "INVALID!!"
        for var i in 0..tpe.enum_values.size {
            let ev = tpe.enum_values[i]
            if ev.value == v {
                str = ev.name
            }
        }
        return cstd::fprintf(file, "%s".value, str.value)
    }
}

export def fprint(file: File, args: &...) -> int {
    var sum = 0
    for var i in 0..args.size {
        let arg = args[i]
        sum += print_val(file, runtime::ref_type(arg), arg !*)
    }
    return sum
}

// Deprecated
export def concat(base: string, to_append: string) {
    cstd::memcpy(base.value ++ strlen(base.value), to_append.value, to_append.size)
}

export def length(s: string) -> size_t {
    return s.size - 1
}

// Allocators
export def allocate(size: size_t) -> * {
    return cstd::malloc(size)
}

export def allocate(type T) -> *T {
    return cstd::malloc(T.size) !*T
}

export def allocate(type T, size: size_t) -> [T] {
    var arr: [T]
    arr.size = size
    arr.value = cstd::malloc(T.size * size) !*T
    return arr
}

// TODO These functions should accept strings but for now they need to be like this
export def #extern starts_with(str: *char, pre: *char) -> int8 {
    return (cstd::strncmp(pre, str, cstd::strlen(pre)) == 0) !int8
}

export def #extern absolute_path(pathname: *char, resolved: *char) {
    #if defined WIN32 {
        windows::GetFullPathNameA(pathname, MAX_PATH, resolved, null)
    } else {
        linux::realpath(pathname, resolved)
    }
}

export def #extern executable_file(resolved: *char) {
    #if defined WIN32 {
        // TODO Windows
    } else {
        var len = linux::readlink("/proc/self/exe".value, resolved, PATH_MAX)
        if len != -1 {
            resolved[len] = '\0'
        }
    }
}