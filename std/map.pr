import optional

const INITIAL_SIZE = 16
export let sentinel = 1 !*

export type Entry(type K, type V) = struct {
    key: K
    value: V
    next: &Entry(K, V)
    // We maintain a linked list for ordering
    l_prev: &Entry(K, V)
    l_next: &Entry(K, V)
}

export type Map(type K, type V) = struct {
    size: size_t
    entries: [&Entry(K, V)]
    tail: &Entry(K, V)
    head: &Entry(K, V)
}

export type SMap(type V) = Map(&string, V)

export def destruct(map: *Map(type K, type V)) {
    delete(map.entries)
}

export def construct(copy: *Map(type K, type V), this: *Map(K, V)) {
    copy.size = this.size
    copy.entries = zero_allocate(type &Entry(K, V), this.entries.size)
    for var i in 0..this.entries.size {
        copy.entries[i] = this.entries[i]
    }
    copy.tail = this.tail
    copy.head = this.head
}

def hash(str: &string) -> uint32 {
    var r: uint32 = 7
    for var i in 0..str.length {
        r = r * 31 + str[i]
    }
    return r
}

def maybe_rehash(map: &Map(type K, type V)) {
    let allocated = map.entries.size
    if map.size / (allocated !double) < 0.7 {
        return
    }
    
    let new_map = {
        entries = zero_allocate(type &Entry(K, V), allocated * 2)
    } !&Map(K, V)

    var entry = map.head
    while entry != null {
        do_put(new_map, entry.key, entry.value)
        let next = entry.l_next
        entry = next
    }
    
    assert new_map.size == map.size
    @map = @new_map
}

export def make(type K, type V, size: size_t) -> &Map(K, V) {
    return {
        entries = zero_allocate(type &Entry(K, V), size),
        size = 0
    } !Map(K, V)
}

export def make(type V, size: size_t) -> &SMap(V) {
    return make(type &string, V, size)
}

export def make(type K, type V) -> &Map(K, V) {
    return make(K, V, INITIAL_SIZE)
}

export def make(type V) -> &SMap(V) {
    return make(V, INITIAL_SIZE)
}

export def get(map: &Map(type K, type V), key: K) -> Optional(V) {
    let h = hash(key)
    let index = h % map.entries.size
    var entry = map.entries[index]
    if entry {
        if entry.key == key {
            return optional::some(entry.value)
        }
        while entry.next {
            entry = entry.next
            if entry.key == key {
                return optional::some(entry.value)
            }
        }
    }
    return optional::none(V)
}

export def get_item(map: &Map(type K, type V), key: K) -> V {
    let value = get(map, key)
    if value.exists { return value.value }
    abort("Key" + key + "does not exist")
}

export def contains(map: &Map(type K, type V), key: string) -> bool {
    let value = get(map, key)
    return value.exists
}

def do_put(map: &Map(type K, type V), key: K, value: V) {
    let entries = map.entries
    let h = hash(key)
    let index = h % entries.size
    var entry = entries[index]

    if entry {
        while entry.next and entry.key != key {
            entry = entry.next
        }
        
        if entry.key == key {
            entry.value = value
            if map.tail == entry { return }
        
            if entry.l_prev { entry.l_prev.l_next = entry.l_next }
            else { map.head = entry.l_next }
            if entry.l_next { entry.l_next.l_prev = entry.l_prev }
            if map.tail { map.tail.l_next = entry }
            entry.l_prev = map.tail
            entry.l_next = null
            map.tail = entry

            return
        }

        var entry2 = {
            key = key,
            value = value,
            l_prev = map.tail
        } !&Entry(K, V)
        if map.tail { map.tail.l_next = entry2 }
        map.tail = entry2
        entry.next = entry2
    } else {
        entry = {
            key = key,
            value = value,
            l_prev = map.tail
        } !&Entry(K, V)
        if not map.head { map.head = entry }
        if map.tail { map.tail.l_next = entry }
        map.tail = entry
        entries[index] = entry
    }
    map.size += 1
}

export def set_item(map: &Map(type K, type V), key: K, value: V) {
    maybe_rehash(map)
    do_put(map, key, value)
}

export def remove(map: &Map(type K, type V), key: string) {
    let h = hash(key)
    let index = h % map.entries.size
    var entry = map.entries[index]
    if entry {
        if entry.key == key {
            map.size -= 1
            map.entries[index] = entry.next

            // TODO Once we have nested functions this needs to go
            if entry.l_prev { entry.l_prev.l_next = entry.l_next }
            if entry.l_next { entry.l_next.l_prev = entry.l_prev }
            if map.head == entry { map.head = entry.l_next }
            if map.tail == entry { map.tail = entry.l_prev }
        } else {
            var entry2 = entry.next
            while entry2 {
                if entry2.key == key {
                    map.size -= 1
                    entry.next = entry2.next

                    if entry2.l_prev { entry2.l_prev.l_next = entry2.l_next }
                    if entry2.l_next { entry2.l_next.l_prev = entry2.l_prev }
                    if map.head == entry2 { map.head = entry2.l_next }
                    if map.tail == entry2 { map.tail = entry2.l_prev }
                }
                
                let entry3 = entry
                entry = entry2
                entry2 = entry3.next
            }
        }
    }
}

export def size(map: &Map(type K, type V)) -> size_t {
    return map.size
}

export def keys(map: &Map(type K, type V)) -> [K] {
    let keys = allocate(K, size(map))
    var index = 0
    var entry = map.head
    while entry != null {
        keys[index] = entry.key
        entry = entry.l_next
        index += 1
    }
    return keys
}

export def reverse_keys(map: &Map(type K, type V)) -> [string] {
    let keys = allocate(string, size(map))
    var index = 0
    var entry = map.tail
    while entry != null {
        keys[index] = entry.key
        entry = entry.l_prev
        index += 1
    }
    return keys
}

export def clear(map: &Map(type K, type V)) {
    if map.size == 0 { return }
    map.size = 0
    delete(map.entries)
    map.head = null 
    map.tail = null
    map.entries = zero_allocate(type &Entry(K, V), INITIAL_SIZE)
}