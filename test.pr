type Vector(type T) = struct {
    size: size_t
    allocated: size_t
    elements: *T
}

type List(type T) = interface {
    def get(index: size_t) -> T
    def set(index: size_t, value: T)
    def size -> size_t
}

def make_vector(type T) -> Vector(T) {
    return { 
        size = 0, 
        allocated = 0, 
        elements = allocate(T, 0) 
    } !Vector(T)
}
// Auto generated
def make_vector(type<int>) -> Vector(int) { ... }
// This checks what interfaces fit to Vector(int) and adds
// Vector(int) to the list of types implementing List(int).
// If the type argument of List can't be infered it is added
// to the list of interfaces referenced by List(T)

def get(v: &Vector(type T), index: size_t) -> T {
    return v.elements[index]
} 
def set(v: &Vector(type T), index: size_t, value: T) {
    v.elements[index] = value
}

let a: &List(int) = make_vector(int)
let b = a.get(i)    // This generates the function below
let c = a.last()

// Auto generated
// This function gets generated by codegen
def get(v: &List(int), index: size_t) -> int {
    // This generates an entry for every value in the list
    // with key List(int) or List(T)
    if ref_type(v) == type &Vector(int) {
        return get::(&Vector(int), size_t)(v !&Vector(int), index)
    }
    assert
}

def last(v: &List(type T)) -> T {
    return v.get(v.size - 1)
}

// Auto generated
def size(v: &List(int)) -> int {
    if ref_type(v) == type &Vector(int) {
        return (v !&Vector(int)).size
    }
    assert
}

// Auto generated
def last(v: &List(int)) -> T {
    return get(v, size(v) - 1)
} 